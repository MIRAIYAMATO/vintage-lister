<!DOCTYPE html>
<!--
    VintageLister v2.9.6 - ASYNC ARCHITECTURE + BUG FIXES
    
    CHANGELOG:
    v2.9.6 (2026-01-30):
    - CRITICAL FIX: AI classification now triggers when entering closeup from ANY mode
      (not just main‚Üícloseup). Fixes workflow: main ‚Üí weight ‚Üí closeup
    - HIGH FIX: resizeImageForAI() now has error handler - prevents infinite hang on corrupt images
    - FIX: Weight photo status CSS class now toggles properly
    - FIX: Object URL memory leak in photo grid - old URLs now revoked
    - ADDED: Handheld timing tracking (start/end/duration in KPIs)
    - ADDED: Full template object in jsonData (n8n knows expected measurements)
    - REMOVED: Dead code (generateParsedMeasurements, rawExtractedValues)
    - CLEANUP: Removed all stale v2.9.4 comment references
    
    v2.9.5 (2026-01-29):
    - MAJOR: Async architecture - AI processing moved to n8n
    - Weight camera replaces USB scale (Dymo M10 removed)
    - 4-camera workflow: MAIN, CLOSEUP, WEIGHT, HANDHELD
    - Comprehensive KPI timing system
    - Simplified S3 folder structure
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VintageLister v2.9.6</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/quagga/0.12.1/quagga.min.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --accent-blue: #3b82f6;
            --accent-green: #22c55e;
            --accent-yellow: #eab308;
            --accent-orange: #f97316;
            --accent-red: #ef4444;
            --accent-purple: #a855f7;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --border-color: #475569;
            --radius: 8px;
        }
        
        html, body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }
        
        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            height: 100vh;
            overflow: hidden;
        }
        
        @media (max-width: 1200px) {
            .app-container { grid-template-columns: 260px 1fr 260px; }
        }
        
        .panel {
            background: var(--bg-primary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .panel-right { border-right: none; border-left: 1px solid var(--border-color); }
        
        .panel-scroll {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        
        /* Header */
        .header-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 16px;
            background: linear-gradient(135deg, var(--accent-blue), #2563eb);
            flex-shrink: 0;
        }
        
        .timer-section { text-align: left; }
        .timer { font-size: 28px; font-weight: 700; font-family: 'Courier New', monospace; color: white; }
        .timer-label { font-size: 9px; color: rgba(255,255,255,0.7); text-transform: uppercase; }
        
        .stats-section { text-align: center; }
        .stats-row { display: flex; gap: 12px; }
        .stat-item { text-align: center; }
        .stat-value { font-size: 16px; font-weight: 700; color: white; }
        .stat-label { font-size: 8px; color: rgba(255,255,255,0.7); text-transform: uppercase; }
        
        .version-info { text-align: right; }
        .version-badge { font-size: 10px; color: rgba(255,255,255,0.9); background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px; display: block; margin-bottom: 4px; }
        .retry-badge { font-size: 9px; color: var(--accent-yellow); display: none; }
        .retry-badge.visible { display: block; }
        
        /* Section Cards */
        .section-card {
            background: var(--bg-secondary);
            border-radius: var(--radius);
            padding: 12px;
            margin-bottom: 10px;
        }
        
        .section-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        
        /* SKU Input - Fixed Layout */
        .sku-row {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
            flex-wrap: nowrap;
        }
        
        .sku-input {
            flex: 1;
            min-width: 0;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 600;
        }
        
        .sku-input:focus { outline: none; border-color: var(--accent-blue); }
        
        .sku-btn {
            padding: 10px 12px;
            border: none;
            border-radius: var(--radius);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .sku-btn-scan { background: var(--accent-purple); color: white; }
        .sku-btn-start { background: var(--accent-green); color: white; font-weight: 600; }
        .sku-btn:hover { filter: brightness(1.1); }
        
        .sku-display {
            display: none;
            padding: 12px;
            background: var(--accent-green);
            border-radius: var(--radius);
            font-size: 18px;
            font-weight: 700;
            text-align: center;
            cursor: pointer;
        }
        
        .sku-display.visible { display: block; }
        .sku-display:hover { background: #16a34a; }
        
        /* Classification */
        .classification-box {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 12px;
        }
        
        .classification-box.ready { border-color: var(--accent-green); }
        .classification-category { font-size: 18px; font-weight: 700; color: var(--accent-yellow); }
        .classification-template { font-size: 12px; color: var(--text-secondary); margin-top: 4px; }
        .classification-template span { color: var(--accent-blue); font-weight: 600; }
        
        /* Tag Data */
        .tag-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 10px;
        }
        
        .tag-item {
            background: var(--bg-secondary);
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 11px;
        }
        
        .tag-label { color: var(--text-secondary); font-size: 9px; text-transform: uppercase; }
        .tag-value { font-weight: 600; margin-top: 2px; }
        
        /* Folder Display */
        .folder-display {
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 11px;
            margin-bottom: 8px;
            color: var(--text-secondary);
            cursor: pointer;
        }
        
        .folder-display.set { color: var(--accent-green); }
        
        /* Photo Grid */
        .photo-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
        
        .photo-thumb {
            position: relative;
            aspect-ratio: 1;
            border-radius: 6px;
            overflow: hidden;
            background: var(--bg-tertiary);
        }
        
        .photo-thumb img { width: 100%; height: 100%; object-fit: cover; }
        
        .photo-thumb-label {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.8);
            padding: 3px;
            font-size: 8px;
            text-align: center;
            color: var(--accent-yellow);
        }
        
        .photo-thumb-delete {
            position: absolute;
            top: 2px; right: 2px;
            width: 18px; height: 18px;
            border-radius: 50%;
            border: none;
            background: var(--accent-red);
            color: white;
            font-size: 10px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .photo-thumb:hover .photo-thumb-delete { opacity: 1; }
        
        /* Camera Panel */
        .camera-panel {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: #000;
        }
        
        .camera-tabs {
            display: flex;
            gap: 4px;
            padding: 8px;
            background: var(--bg-secondary);
            flex-shrink: 0;
        }
        
        .camera-tab {
            flex: 1;
            padding: 12px 8px;
            border: none;
            border-radius: var(--radius);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .camera-tab:hover { background: var(--bg-primary); color: var(--text-primary); }
        .camera-tab.active { background: var(--accent-blue); color: white; }
        .camera-tab.closeup.active { background: var(--accent-orange); }
        .camera-tab.weight.active { background: var(--accent-green); }
        .camera-tab.handheld.active { background: var(--accent-purple); }
        
        /* Camera Info */
        .camera-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 12px;
            background: rgba(0,0,0,0.5);
            font-size: 11px;
            color: var(--text-secondary);
            flex-shrink: 0;
        }
        
        .camera-name { font-weight: 600; color: var(--text-primary); }
        .resolution-badge { background: var(--bg-secondary); padding: 3px 8px; border-radius: 4px; }
        .photo-count-badge { background: var(--accent-green); color: white; padding: 3px 10px; border-radius: 4px; font-weight: 600; }
        
        /* Video */
        .video-container {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
        }
        
        .video-container video { width: 100%; height: 100%; object-fit: contain; }
        .video-placeholder { color: var(--text-secondary); text-align: center; padding: 40px; }
        
        .capture-flash {
            position: absolute;
            inset: 0;
            background: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
        
        .capture-flash.active { opacity: 0.7; }
        
        /* Capture Area - Complete Button */
        .capture-area {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            padding: 16px;
            background: var(--bg-secondary);
            flex-shrink: 0;
        }
        
        .capture-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 4px solid var(--text-primary);
            background: transparent;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .capture-btn::after {
            content: '';
            position: absolute;
            inset: 5px;
            border-radius: 50%;
            background: var(--text-primary);
            transition: all 0.2s;
        }
        
        .capture-btn:hover::after { background: var(--accent-blue); }
        .capture-btn:active { transform: scale(0.95); }
        
        .complete-btn-camera {
            padding: 14px 24px;
            border: none;
            border-radius: var(--radius);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            background: var(--accent-green);
            color: white;
            transition: all 0.2s;
        }
        
        .complete-btn-camera:hover { filter: brightness(1.1); }
        .complete-btn-camera:disabled { opacity: 0.5; cursor: not-allowed; }
        
        /* AI Overlay */
        .ai-overlay {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        
        .ai-overlay.active { opacity: 1; visibility: visible; }
        .spinner { width: 36px; height: 36px; border: 3px solid var(--bg-tertiary); border-top-color: var(--accent-blue); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* Measurements */
        .measurement-list { display: flex; flex-direction: column; gap: 6px; }
        
        .measurement-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 12px;
        }
        
        .measurement-item.completed {
            background: linear-gradient(90deg, rgba(34,197,94,0.2), transparent);
            border-left: 3px solid var(--accent-green);
        }
        
        .measurement-num {
            width: 22px; height: 22px;
            border-radius: 50%;
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            margin-right: 8px;
            flex-shrink: 0;
        }
        
        .measurement-name { flex: 1; }
        .measurement-value { font-weight: 600; color: var(--accent-green); }
        
        /* Transcript Display */
        .transcript-box {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            font-size: 11px;
            color: var(--text-secondary);
            display: none;
        }
        
        .transcript-box.visible { display: block; }
        .transcript-label { font-weight: 600; color: var(--text-primary); margin-bottom: 4px; }
        .transcript-text { font-style: italic; }
        
        /* Buttons */
        .btn {
            padding: 12px 16px;
            border: none;
            border-radius: var(--radius);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            margin-bottom: 8px;
        }
        
        .btn-primary { background: var(--accent-green); color: white; }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); }
        .btn-record { background: var(--accent-red); color: white; }
        .btn-stop { background: #dc2626; color: white; animation: pulse-stop 1s infinite; }
        .btn:hover { filter: brightness(1.1); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        @keyframes pulse-stop { 
            0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7); } 
            50% { opacity: 0.9; box-shadow: 0 0 0 10px rgba(220, 38, 38, 0); } 
        }
        
        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        
        .modal-overlay.active { opacity: 1; visibility: visible; }
        
        .modal {
            background: var(--bg-secondary);
            border-radius: var(--radius);
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .modal-title { font-size: 16px; font-weight: 600; }
        
        .modal-close {
            width: 30px; height: 30px;
            border: none;
            border-radius: 50%;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 16px;
            cursor: pointer;
        }
        
        .modal-body { padding: 16px; }
        .form-group { margin-bottom: 14px; }
        .form-label { display: block; font-size: 11px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase; }
        
        .form-select, .form-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 13px;
        }
        
        .form-select:focus, .form-input:focus { outline: none; border-color: var(--accent-blue); }
        
        /* Barcode Scanner */
        .barcode-container {
            position: relative;
            background: #000;
            aspect-ratio: 4/3;
            border-radius: var(--radius);
            overflow: hidden;
        }
        
        .barcode-container video, .barcode-container canvas { width: 100%; height: 100%; object-fit: cover; }
        
        .barcode-target {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 200px; height: 80px;
            border: 3px solid var(--accent-yellow);
            border-radius: 8px;
        }
        
        .barcode-status {
            position: absolute;
            bottom: 10px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
        }
        
        .barcode-status.success { background: var(--accent-green); }
        
        /* Toast */
        .toast-container {
            position: fixed;
            top: 20px; right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .toast {
            padding: 10px 16px;
            border-radius: var(--radius);
            font-size: 13px;
            font-weight: 500;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        
        .toast.success { background: var(--accent-green); color: white; }
        .toast.error { background: var(--accent-red); color: white; }
        .toast.warning { background: var(--accent-yellow); color: black; }
        .toast.info { background: var(--accent-blue); color: white; }
        
        /* v2.9.5: Weight Photo Status (replaces Dymo Scale) */
        .weight-photo-status {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: var(--radius);
            border: 1px dashed var(--border-color);
        }
        
        .weight-photo-status.captured {
            border: 1px solid var(--accent-green);
            background: rgba(34, 197, 94, 0.1);
        }
        
        .weight-status-icon {
            font-size: 20px;
        }
        
        .weight-status-text {
            font-size: 13px;
            color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="toast-container" id="toast-container"></div>
    
    <div class="app-container">
        <!-- Left Panel -->
        <div class="panel panel-left">
            <div class="header-bar">
                <div class="timer-section">
                    <div class="timer" id="timer">0:00</div>
                    <div class="timer-label">Item Time</div>
                </div>
                <div class="stats-section">
                    <div class="stats-row">
                        <div class="stat-item">
                            <div class="stat-value" id="item-count">0</div>
                            <div class="stat-label">Items</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="avg-time">0:00</div>
                            <div class="stat-label">Avg</div>
                        </div>
                    </div>
                </div>
                <div class="version-info">
                    <span class="version-badge" id="version-badge">v2.9.6</span>
                    <span class="retry-badge" id="retry-badge">‚ö†Ô∏è 0 pending</span>
                </div>
            </div>
            
            <div class="panel-scroll">
                <!-- SKU - Fixed Layout -->
                <div class="section-card">
                    <div class="section-title">üè∑Ô∏è Item SKU</div>
                    <div class="sku-row" id="sku-row">
                        <input type="text" class="sku-input" id="sku-input" placeholder="Scan or type SKU...">
                        <button class="sku-btn sku-btn-scan" onclick="openBarcodeScanner()">üì∑</button>
                        <button class="sku-btn sku-btn-start" onclick="startNewItem()">START</button>
                    </div>
                    <div class="sku-display" id="sku-display" onclick="cancelItem()"></div>
                </div>
                
                <!-- Classification -->
                <div class="section-card">
                    <div class="section-title">ü§ñ AI Classification</div>
                    <div class="classification-box" id="classification-box">
                        <div class="classification-category" id="classification-category">Waiting...</div>
                        <div class="classification-template">Template: <span id="classification-template">-</span></div>
                    </div>
                    <div class="tag-grid" id="tag-grid" style="display: none;">
                        <div class="tag-item"><div class="tag-label">Brand</div><div class="tag-value" id="tag-brand">-</div></div>
                        <div class="tag-item"><div class="tag-label">Size</div><div class="tag-value" id="tag-size">-</div></div>
                        <div class="tag-item"><div class="tag-label">Materials</div><div class="tag-value" id="tag-materials">-</div></div>
                        <div class="tag-item"><div class="tag-label">Country</div><div class="tag-value" id="tag-country">-</div></div>
                    </div>
                </div>
                
                <!-- Save Location -->
                <div class="section-card">
                    <div class="section-title">üíæ Save Location</div>
                    <div class="folder-display" id="folder-display" onclick="chooseSaveFolder()">üìÅ Click to choose folder</div>
                </div>
                
                <!-- Weight Photo Status (replaces USB Scale) -->
                <div class="section-card">
                    <div class="section-title">‚öñÔ∏è Weight Photo</div>
                    <div class="weight-photo-status" id="weight-photo-status">
                        <span class="weight-status-icon">üì∑</span>
                        <span class="weight-status-text" id="weight-status-text">No weight photo</span>
                    </div>
                    <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">
                        Switch to WEIGHT camera to capture scale display
                    </div>
                </div>
                
                <!-- Photos -->
                <div class="section-card">
                    <div class="section-title">üì∏ Photos (<span id="photo-count">0</span>)</div>
                    <div class="photo-grid" id="photo-grid"></div>
                </div>
                
                <button class="btn btn-secondary" onclick="openSettings()">‚öôÔ∏è Settings</button>
            </div>
        </div>
        
        <!-- Camera Panel -->
        <div class="panel camera-panel">
            <div class="camera-tabs">
                <button class="camera-tab active" data-mode="main" onclick="switchCameraMode('main')">üì∑ MAIN</button>
                <button class="camera-tab closeup" data-mode="closeup" onclick="switchCameraMode('closeup')">üîç CLOSEUP</button>
                <button class="camera-tab weight" data-mode="weight" onclick="switchCameraMode('weight')">‚öñÔ∏è WEIGHT</button>
                <button class="camera-tab handheld" data-mode="handheld" onclick="switchCameraMode('handheld')">üì± HANDHELD</button>
            </div>
            
            <div class="camera-info">
                <span class="camera-name" id="camera-name">No camera</span>
                <span class="resolution-badge" id="resolution-badge">-</span>
                <span class="photo-count-badge"><span id="mode-photo-count">0</span> photos</span>
            </div>
            
            <div class="video-container">
                <video id="video-preview" autoplay playsinline muted></video>
                <div class="video-placeholder" id="video-placeholder">üì∑ Select a camera in Settings</div>
                <div class="capture-flash" id="capture-flash"></div>
                <div class="ai-overlay" id="ai-overlay">
                    <div class="spinner"></div>
                    <div style="font-size: 13px; color: var(--text-secondary);">AI analyzing photos...</div>
                </div>
            </div>
            
            <div class="capture-area">
                <button class="capture-btn" id="capture-btn" onclick="capturePhoto()"></button>
                <button class="complete-btn-camera" id="complete-btn-camera" onclick="completeItem()" disabled>‚úÖ COMPLETE</button>
            </div>
        </div>
        
        <!-- Right Panel - REMOVED COMPLETE & SAVE BUTTON -->
        <div class="panel panel-right">
            <div class="panel-scroll">
                <div class="section-card">
                    <div class="section-title">üìè Measurements</div>
                    <div class="measurement-list" id="measurement-list">
                        <div style="color: var(--text-secondary); font-size: 12px; text-align: center; padding: 16px;">
                            Classify item first
                        </div>
                    </div>
                    <div class="transcript-box" id="transcript-box">
                        <div class="transcript-label">üìù Transcript:</div>
                        <div class="transcript-text" id="transcript-text"></div>
                    </div>
                </div>
                
                <!-- Recording button - Changes to TAP TO STOP when recording -->
                <button class="btn btn-record" id="record-btn" onclick="toggleRecording()">üé§ TAP TO RECORD</button>
                
                <!-- NOTE: "COMPLETE & SAVE" button REMOVED from here per user request -->
                <!-- The COMPLETE button in the camera capture area is the only submit option -->
            </div>
        </div>
    </div>
    
    <!-- Barcode Modal -->
    <div class="modal-overlay" id="barcode-modal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">üì∑ Scan Barcode</div>
                <button class="modal-close" onclick="closeBarcodeScanner()">√ó</button>
            </div>
            <div class="modal-body" style="padding: 0;">
                <div class="barcode-container" id="barcode-container">
                    <div class="barcode-target"></div>
                    <div class="barcode-status" id="barcode-status">Starting scanner...</div>
                </div>
                <div style="padding: 12px; text-align: center;">
                    <button class="btn btn-secondary" onclick="closeBarcodeScanner()">Cancel</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div class="modal-overlay" id="settings-modal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">‚öôÔ∏è Settings</div>
                <button class="modal-close" onclick="closeSettings()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Main Camera</label>
                    <select class="form-select" id="camera-main"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Closeup Camera</label>
                    <select class="form-select" id="camera-closeup"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Weight Camera (above scale)</label>
                    <select class="form-select" id="camera-weight"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Handheld Camera</label>
                    <select class="form-select" id="camera-handheld"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Barcode Scanner Camera</label>
                    <select class="form-select" id="camera-barcode"></select>
                </div>
                <hr style="border-color: var(--border-color); margin: 16px 0;">
                <div class="form-group">
                    <label class="form-label">Photographer ID</label>
                    <input type="text" class="form-input" id="photographer-id" placeholder="photographer_1" value="photographer_1">
                </div>
                <hr style="border-color: var(--border-color); margin: 16px 0;">
                <div class="form-group">
                    <label class="form-label">Lambda URL</label>
                    <input type="text" class="form-input" id="lambda-url" placeholder="https://...">
                </div>
                <button class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
            </div>
        </div>
    </div>
    
    <canvas id="capture-canvas" style="display: none;"></canvas>
    <canvas id="resize-canvas" style="display: none;"></canvas>
    
    <script>
        // =============================================================================
        // VINTAGELISTER v2.9.6 - ASYNC ARCHITECTURE + WEIGHT CAMERA
        // 
        // v2.9.6 FIXES:
        // - AI trigger now fires when entering closeup from ANY mode
        // - resizeImageForAI() has error handler (prevents infinite hang)
        // - Weight photo status CSS class toggles properly
        // - Object URL memory leak fixed
        // - Handheld timing tracking added
        // - Dead code removed
        //
        // v2.9.5 ARCHITECTURE:
        //
        // 1. ASYNC AI PROCESSING
        //    - Removed blocking AI from completeItem()
        //    - OCR, Image Processing, Photo Routing, Full Pipeline ‚Üí n8n
        //    - COMPLETE ‚Üí uploads ~2-3 sec ‚Üí UI resets
        //
        // 2. WEIGHT CAMERA (replaces Dymo USB scale)
        //    - 4th camera mode: WEIGHT
        //    - Photo of scale display, n8n OCRs the value
        //
        // 3. S3 FOLDER STRUCTURE
        //    - main/, closeup/, weight/, handheld/, measurements/, data/
        //
        // 4. DETAILED KPI TIMING
        //    - Granular timestamps for each workflow phase
        //    - Per-photographer, per-category analysis
        //
        // AI IN BROWSER: classify, whisper
        // AI IN N8N: OCR, imageProcessing, photoRouting, fullPipeline
        // =============================================================================
        
        const VERSION = '2.9.6';
        const DEFAULT_LAMBDA_URL = 'https://6t5wk2ae23foojyfwmddauorey0pjqji.lambda-url.us-east-2.on.aws/';
        const AI_IMAGE_MAX_SIZE = 1024;
        const MAX_RETRIES = 3;
        const RETRY_DELAY = 5000;
        
        const state = {
            lambdaUrl: localStorage.getItem('lambdaUrl') || DEFAULT_LAMBDA_URL,
            lambdaVersion: null,
            currentSKU: '',
            currentMode: 'main',
            currentStream: null,
            cameras: {
                main: { deviceId: localStorage.getItem('camera-main') || null },
                closeup: { deviceId: localStorage.getItem('camera-closeup') || null },
                weight: { deviceId: localStorage.getItem('camera-weight') || null },
                handheld: { deviceId: localStorage.getItem('camera-handheld') || null },
                barcode: { deviceId: localStorage.getItem('camera-barcode') || null }
            },
            availableCameras: [],
            photos: { main: [], closeup: [], weight: [], handheld: [] },
            classification: null,
            templateKey: null,
            template: null,
            tagData: null,
            measurements: {},
            rawTranscript: '',
            audioBlob: null,
            saveDirectoryHandle: null,
            timerStart: null,
            timerInterval: null,
            isRecording: false,
            mediaRecorder: null,
            audioChunks: [],
            aiTriggered: false,
            // v2.9.5: Detailed KPI timing for each workflow phase
            timing: {
                itemStartTime: null,          // When SKU entered/scanned
                classificationTime: null,     // When AI classification completed
                mainPhotosStartTime: null,    // When started taking main photos
                mainPhotosEndTime: null,      // When switched away from MAIN
                closeupStartTime: null,       // When switched to CLOSEUP
                closeupEndTime: null,         // When switched away from CLOSEUP
                weightStartTime: null,        // When switched to WEIGHT
                weightEndTime: null,          // When switched away from WEIGHT
                handheldStartTime: null,      // v2.9.6: When switched to HANDHELD
                handheldEndTime: null,        // v2.9.6: When switched away from HANDHELD
                measurementsStartTime: null,  // When started recording
                measurementsEndTime: null,    // When recording stopped
                completeTime: null            // When COMPLETE clicked
            },
            // Stats
            completedItems: parseInt(localStorage.getItem('completedItems') || '0'),
            totalTime: parseInt(localStorage.getItem('totalTime') || '0'),
            // Retry queue
            retryQueue: JSON.parse(localStorage.getItem('retryQueue') || '[]'),
            // v2.9.5: Removed Dymo USB Scale - using weight camera instead
            // Discarded recordings for QC
            discardedRecordings: [],
            recordingStartTime: null,
            // v2.9.5: Photographer ID from settings
            photographerId: localStorage.getItem('photographerId') || 'photographer_1'
        };
        
        // =====================================================================
        // INIT
        // =====================================================================
        async function init() {
            console.log(`%c VintageLister v${VERSION} `, 'background: #3b82f6; color: white; font-size: 14px;');
            document.getElementById('lambda-url').value = state.lambdaUrl;
            updateStats();
            updateRetryBadge();
            await checkLambda();
            await enumerateCameras();
            if (state.cameras.main.deviceId) await startCamera('main');
            
            // SPACE key for pedal capture
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && !e.target.matches('input, textarea')) {
                    e.preventDefault();
                    capturePhoto();
                }
            });
            
            // Process retry queue
            processRetryQueue();
            
            console.log('‚úÖ Init complete - SPACE key enabled, scale fix applied');
        }
        
        // =====================================================================
        // LAMBDA
        // =====================================================================
        async function checkLambda() {
            try {
                const res = await fetch(state.lambdaUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'diagnostics' })
                });
                const data = await res.json();
                if (data.success) {
                    state.lambdaVersion = data.version;
                    document.getElementById('version-badge').textContent = `v${VERSION} | Œª${data.version}`;
                    console.log(`‚úÖ Lambda v${data.version} healthy`);
                    showToast('success', `Connected to Lambda v${data.version}`);
                }
            } catch (err) {
                console.error('Lambda check failed:', err);
                showToast('error', 'Lambda connection failed');
            }
        }
        
        async function callLambda(action, body = {}) {
            const res = await fetch(state.lambdaUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action, ...body })
            });
            return res.json();
        }
        
        // =====================================================================
        // CAMERA
        // =====================================================================
        async function enumerateCameras() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                stream.getTracks().forEach(t => t.stop());
                const devices = await navigator.mediaDevices.enumerateDevices();
                state.availableCameras = devices.filter(d => d.kind === 'videoinput');
                console.log(`üìπ Found ${state.availableCameras.length} cameras`);
                populateCameraSelects();
            } catch (err) {
                console.error('Camera enum failed:', err);
            }
        }
        
        function populateCameraSelects() {
            // v2.9.5: Include weight camera
            ['main', 'closeup', 'weight', 'handheld', 'barcode'].forEach(mode => {
                const sel = document.getElementById(`camera-${mode}`);
                if (!sel) return;
                sel.innerHTML = '<option value="">Select camera...</option>';
                state.availableCameras.forEach((cam, i) => {
                    const opt = document.createElement('option');
                    opt.value = cam.deviceId;
                    opt.textContent = cam.label || `Camera ${i + 1}`;
                    if (cam.deviceId === state.cameras[mode].deviceId) opt.selected = true;
                    sel.appendChild(opt);
                });
            });
            
            // v2.9.5: Load photographer ID into settings
            const photographerInput = document.getElementById('photographer-id');
            if (photographerInput) {
                photographerInput.value = state.photographerId;
            }
        }
        
        async function startCamera(mode) {
            const deviceId = state.cameras[mode].deviceId;
            if (!deviceId) {
                document.getElementById('video-placeholder').style.display = 'block';
                return;
            }
            if (state.currentStream) state.currentStream.getTracks().forEach(t => t.stop());
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { deviceId: { exact: deviceId }, width: { ideal: 4096 }, height: { ideal: 2160 } }
                });
                state.currentStream = stream;
                document.getElementById('video-preview').srcObject = stream;
                document.getElementById('video-placeholder').style.display = 'none';
                const settings = stream.getVideoTracks()[0].getSettings();
                document.getElementById('resolution-badge').textContent = `${settings.width}√ó${settings.height}`;
                const cam = state.availableCameras.find(c => c.deviceId === deviceId);
                document.getElementById('camera-name').textContent = cam?.label || 'Camera';
                console.log(`üìπ Started ${mode}: ${settings.width}√ó${settings.height}`);
            } catch (err) {
                console.error('Start camera failed:', err);
            }
        }
        
        function switchCameraMode(mode) {
            const prevMode = state.currentMode;
            const now = Date.now();
            
            // v2.9.5: Track end time for previous mode
            if (state.currentSKU) {
                if (prevMode === 'main' && state.timing.mainPhotosStartTime) {
                    state.timing.mainPhotosEndTime = now;
                } else if (prevMode === 'closeup' && state.timing.closeupStartTime) {
                    state.timing.closeupEndTime = now;
                } else if (prevMode === 'weight' && state.timing.weightStartTime) {
                    state.timing.weightEndTime = now;
                } else if (prevMode === 'handheld' && state.timing.handheldStartTime) {
                    state.timing.handheldEndTime = now;
                }
            }
            
            state.currentMode = mode;
            document.querySelectorAll('.camera-tab').forEach(t => t.classList.toggle('active', t.dataset.mode === mode));
            startCamera(mode);
            updatePhotoCount();
            
            // v2.9.6: Track start time for new mode (including handheld)
            if (state.currentSKU) {
                if (mode === 'closeup' && !state.timing.closeupStartTime) {
                    state.timing.closeupStartTime = now;
                } else if (mode === 'weight' && !state.timing.weightStartTime) {
                    state.timing.weightStartTime = now;
                } else if (mode === 'handheld' && !state.timing.handheldStartTime) {
                    state.timing.handheldStartTime = now;
                }
            }
            
            // v2.9.6: Trigger AI when entering closeup from ANY mode (not just main)
            // This allows workflows like: main ‚Üí weight ‚Üí closeup
            if (mode === 'closeup' && !state.aiTriggered && state.photos.main.length > 0) {
                triggerAI();
            }
        }
        
        // =====================================================================
        // PHOTO CAPTURE
        // =====================================================================
        function capturePhoto() {
            if (!state.currentStream) {
                showToast('warning', 'No camera active');
                return;
            }
            if (!state.currentSKU) {
                showToast('warning', 'Start an item first');
                return;
            }
            
            const video = document.getElementById('video-preview');
            const canvas = document.getElementById('capture-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0);
            
            const flash = document.getElementById('capture-flash');
            flash.classList.add('active');
            setTimeout(() => flash.classList.remove('active'), 100);
            
            const currentMode = state.currentMode;
            
            canvas.toBlob(async blob => {
                const photo = { blob, mode: currentMode, timestamp: Date.now() };
                state.photos[currentMode].push(photo);
                updatePhotoGrid();
                updatePhotoCount();
                console.log(`üì∑ Captured ${currentMode} #${state.photos[currentMode].length}`);
                showToast('success', 'Photo captured');
                
                // v2.9.5: Update weight photo status
                if (currentMode === 'weight') {
                    updateWeightPhotoStatus();
                }
            }, 'image/jpeg', 0.92);
        }
        
        // v2.9.5: Update weight photo status display
        function updateWeightPhotoStatus() {
            const statusText = document.getElementById('weight-status-text');
            const statusContainer = document.getElementById('weight-photo-status');
            const count = state.photos.weight.length;
            if (count > 0) {
                statusText.textContent = `‚úÖ ${count} weight photo${count > 1 ? 's' : ''} captured`;
                statusText.style.color = 'var(--accent-green)';
                statusContainer.classList.add('captured');
            } else {
                statusText.textContent = 'No weight photo';
                statusText.style.color = 'var(--text-secondary)';
                statusContainer.classList.remove('captured');
            }
        }
        
        function updatePhotoCount() {
            const total = state.photos.main.length + state.photos.closeup.length + state.photos.weight.length + state.photos.handheld.length;
            document.getElementById('photo-count').textContent = total;
            document.getElementById('mode-photo-count').textContent = state.photos[state.currentMode].length;
        }
        
        function updatePhotoGrid() {
            const grid = document.getElementById('photo-grid');
            // v2.9.6: Revoke old Object URLs to prevent memory leak
            grid.querySelectorAll('img').forEach(img => {
                if (img.src.startsWith('blob:')) URL.revokeObjectURL(img.src);
            });
            const all = [...state.photos.main, ...state.photos.closeup, ...state.photos.weight, ...state.photos.handheld];
            grid.innerHTML = all.map((p, i) => `
                <div class="photo-thumb">
                    <img src="${URL.createObjectURL(p.blob)}">
                    <div class="photo-thumb-label">${p.label || p.mode}</div>
                    <button class="photo-thumb-delete" onclick="deletePhoto(${i})">√ó</button>
                </div>
            `).join('');
        }
        
        function deletePhoto(idx) {
            let count = 0;
            for (const mode of ['main', 'closeup', 'weight', 'handheld']) {
                if (idx < count + state.photos[mode].length) {
                    state.photos[mode].splice(idx - count, 1);
                    // v2.9.5: Update weight status if deleting weight photo
                    if (mode === 'weight') updateWeightPhotoStatus();
                    break;
                }
                count += state.photos[mode].length;
            }
            updatePhotoGrid();
            updatePhotoCount();
        }
        
        // =====================================================================
        // AI CLASSIFICATION
        // =====================================================================
        async function triggerAI() {
            if (state.photos.main.length === 0) return;
            state.aiTriggered = true;
            document.getElementById('ai-overlay').classList.add('active');
            
            try {
                console.log(`ü§ñ AI: ${state.photos.main.length} photos`);
                const mainPhotos = await Promise.all(state.photos.main.slice(0, 4).map(p => resizeImageForAI(p.blob)));
                let tagPhoto = null;
                if (state.photos.closeup.length > 0) tagPhoto = await resizeImageForAI(state.photos.closeup[0].blob);
                
                const result = await callLambda('classify', { mainPhotos, tagPhoto });
                if (result.success) {
                    state.classification = result.category;
                    state.templateKey = result.templateKey;
                    state.template = result.template;
                    state.tagData = result.tagData;
                    
                    // v2.9.5: Record classification time for KPI
                    state.timing.classificationTime = Date.now();
                    
                    // Update photo labels from AI
                    if (result.photoLabels) {
                        state.photos.main.forEach((p, i) => {
                            if (result.photoLabels[i]) p.label = result.photoLabels[i];
                        });
                    }
                    
                    updateClassificationDisplay();
                    updatePhotoGrid();
                    updateMeasurementList();
                    console.log(`‚úÖ Classified: ${result.category}`);
                    showToast('success', `Classified: ${result.category}`);
                } else {
                    throw new Error(result.error || 'Classification failed');
                }
            } catch (err) {
                console.error('AI error:', err);
                showToast('error', 'AI failed: ' + err.message);
            } finally {
                document.getElementById('ai-overlay').classList.remove('active');
            }
        }
        
        async function resizeImageForAI(blob) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const objectUrl = URL.createObjectURL(blob);
                img.onload = () => {
                    const canvas = document.getElementById('resize-canvas');
                    const ctx = canvas.getContext('2d');
                    let w = img.width, h = img.height;
                    if (w > AI_IMAGE_MAX_SIZE || h > AI_IMAGE_MAX_SIZE) {
                        if (w > h) { h = Math.round(h * AI_IMAGE_MAX_SIZE / w); w = AI_IMAGE_MAX_SIZE; }
                        else { w = Math.round(w * AI_IMAGE_MAX_SIZE / h); h = AI_IMAGE_MAX_SIZE; }
                    }
                    canvas.width = w;
                    canvas.height = h;
                    ctx.drawImage(img, 0, 0, w, h);
                    URL.revokeObjectURL(objectUrl);
                    resolve(canvas.toDataURL('image/jpeg', 0.8).split(',')[1]);
                };
                img.onerror = () => {
                    URL.revokeObjectURL(objectUrl);
                    reject(new Error('Failed to load image for resize'));
                };
                img.src = objectUrl;
            });
        }
        
        function updateClassificationDisplay() {
            document.getElementById('classification-box').classList.add('ready');
            document.getElementById('classification-category').textContent = state.classification || 'Unknown';
            document.getElementById('classification-template').textContent = `${state.template?.name || '-'} (${state.template?.count || 0})`;
            if (state.tagData && !state.tagData.error) {
                document.getElementById('tag-grid').style.display = 'grid';
                document.getElementById('tag-brand').textContent = state.tagData.brand || '-';
                document.getElementById('tag-size').textContent = state.tagData.size || '-';
                document.getElementById('tag-materials').textContent = state.tagData.materials || '-';
                document.getElementById('tag-country').textContent = state.tagData.country || '-';
            }
        }
        
        function updateMeasurementList() {
            const list = document.getElementById('measurement-list');
            if (!state.template?.measurements) {
                list.innerHTML = '<div style="color: var(--text-secondary); font-size: 12px; text-align: center;">Classify first</div>';
                return;
            }
            list.innerHTML = state.template.measurements.map((m, i) => `
                <div class="measurement-item" data-idx="${i}">
                    <span class="measurement-num">${i + 1}</span>
                    <span class="measurement-name">${m}</span>
                    <span class="measurement-value" id="mv-${i}">-</span>
                </div>
            `).join('');
            document.getElementById('complete-btn-camera').disabled = false;
            
            // Track measurements start time (when template loaded, before recording)
            if (!state.timing.measurementsStartTime) {
                state.timing.measurementsStartTime = Date.now();
            }
        }
        
        // =====================================================================
        // VOICE RECORDING
        // - Button shows "üõë TAP TO STOP" when recording
        // - Discarded recordings saved for QC
        // - Recording duration tracked for KPIs
        // =====================================================================
        async function toggleRecording() {
            if (state.isRecording) stopRecording();
            else startRecording();
        }
        
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                state.mediaRecorder = new MediaRecorder(stream);
                state.audioChunks = [];
                state.recordingStartTime = Date.now(); // Track duration
                
                // v2.9.5: Track measurements start time
                if (!state.timing.measurementsStartTime) {
                    state.timing.measurementsStartTime = Date.now();
                }
                
                state.mediaRecorder.ondataavailable = e => state.audioChunks.push(e.data);
                state.mediaRecorder.onstop = async () => {
                    const recordingDuration = (Date.now() - state.recordingStartTime) / 1000;
                    const blob = new Blob(state.audioChunks, { type: 'audio/webm' });
                    
                    // If there was a previous recording, save it as discarded
                    if (state.audioBlob) {
                        state.discardedRecordings.push({
                            blob: state.audioBlob,
                            duration: state.lastRecordingDuration || 0,
                            timestamp: new Date().toISOString()
                        });
                        console.log(`üìº Previous recording saved as discarded (${state.discardedRecordings.length} total)`);
                    }
                    
                    state.audioBlob = blob;
                    state.lastRecordingDuration = recordingDuration;
                    stream.getTracks().forEach(t => t.stop());
                    await transcribeAudio(blob);
                };
                
                state.mediaRecorder.start();
                state.isRecording = true;
                
                // Update button to stop state
                const btn = document.getElementById('record-btn');
                btn.classList.remove('btn-record');
                btn.classList.add('btn-stop');
                btn.textContent = 'üõë TAP TO STOP';
                
            } catch (err) {
                showToast('error', 'Mic access denied');
            }
        }
        
        function stopRecording() {
            if (state.mediaRecorder && state.isRecording) {
                state.mediaRecorder.stop();
                state.isRecording = false;
                
                // Track measurements end time
                state.timing.measurementsEndTime = Date.now();
                
                // Reset button to record state
                const btn = document.getElementById('record-btn');
                btn.classList.remove('btn-stop');
                btn.classList.add('btn-record');
                btn.textContent = 'üé§ TAP TO RECORD';
            }
        }
        
        async function transcribeAudio(blob) {
            try {
                showToast('info', 'Transcribing...');
                const reader = new FileReader();
                reader.readAsDataURL(blob);
                reader.onloadend = async () => {
                    const base64 = reader.result.split(',')[1];
                    const result = await callLambda('whisper', { audio: base64, filename: 'audio.webm' });
                    if (result.success && result.text) {
                        state.rawTranscript = result.text;
                        console.log('üìù Transcribed:', result.text);
                        
                        // Show transcript
                        document.getElementById('transcript-text').textContent = result.text;
                        document.getElementById('transcript-box').classList.add('visible');
                        
                        parseMeasurements(result.text);
                        showToast('success', 'Transcription done');
                    }
                };
            } catch (err) {
                showToast('error', 'Transcription failed');
            }
        }
        
        function parseMeasurements(text) {
            // Extract numbers for immediate UI display only
            // Actual field matching happens in n8n via fullPipeline
            // This is user feedback - final values come from AI
            
            const regex = /(\d+(?:\.\d+)?)\s*(?:and\s+(?:a\s+)?(?:half|quarter|three[- ]?quarter)s?)?(?:\s*inches?|\s*in|\s*")?/gi;
            const matches = [...text.matchAll(regex)];
            if (!state.template) return;
            
            // Show extracted values but mark as "pending AI"
            const extractedValues = matches.map(m => {
                let val = parseFloat(m[1]);
                const fullMatch = m[0].toLowerCase();
                if (fullMatch.includes('half')) val += 0.5;
                else if (fullMatch.includes('quarter') && !fullMatch.includes('three')) val += 0.25;
                else if (fullMatch.includes('three') && fullMatch.includes('quarter')) val += 0.75;
                return val;
            });
            
            console.log(`üìè Extracted ${extractedValues.length} values from transcript:`, extractedValues);
            
            // For UI display only - show that we got values but AI will match them
            // Don't try to assign to specific fields (that's what caused the swap bug)
            extractedValues.forEach((val, i) => {
                if (i < state.template.measurements.length) {
                    const el = document.getElementById(`mv-${i}`);
                    if (el) {
                        // Show value with indicator that AI will verify
                        el.textContent = `${val}" ‚è≥`;
                        el.title = 'AI will match to correct field';
                        el.closest('.measurement-item').classList.add('completed');
                    }
                }
            });
            
            // v2.9.6: Removed rawExtractedValues - was never used
            // n8n will re-parse transcript with Full Pipeline
        }
        
        // =====================================================================
        // LOCAL FOLDER SAVE
        // =====================================================================
        async function chooseSaveFolder() {
            try {
                state.saveDirectoryHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                const display = document.getElementById('folder-display');
                display.textContent = `üìÅ ${state.saveDirectoryHandle.name}`;
                display.classList.add('set');
                showToast('success', `Folder: ${state.saveDirectoryHandle.name}`);
            } catch (err) {
                if (err.name !== 'AbortError') showToast('error', 'Folder selection failed');
            }
        }
        
        async function saveToLocalFolder(itemData) {
            if (!state.saveDirectoryHandle || !itemData.sku) return false;
            try {
                const skuFolder = await state.saveDirectoryHandle.getDirectoryHandle(itemData.sku, { create: true });
                
                // v2.9.5: Simplified folder structure (matches S3)
                const folders = ['main', 'closeup', 'weight', 'handheld', 'measurements', 'data'];
                for (const f of folders) {
                    await skuFolder.getDirectoryHandle(f, { create: true });
                }
                
                // Save main photos
                const mainFolder = await skuFolder.getDirectoryHandle('main', { create: true });
                if (itemData.photos.main.length > 0) {
                    for (let i = 0; i < itemData.photos.main.length; i++) {
                        const photo = itemData.photos.main[i];
                        const filename = `${itemData.sku}_main_${String(i + 1).padStart(2, '0')}.jpg`;
                        const fileHandle = await mainFolder.getFileHandle(filename, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(photo.blob);
                        await writable.close();
                    }
                } else {
                    await createNAFile(mainFolder, null, itemData.sku);
                }
                
                // v2.9.5: Save ALL closeup photos to closeup/ folder (n8n categorizes later)
                const closeupFolder = await skuFolder.getDirectoryHandle('closeup', { create: true });
                if (itemData.photos.closeup.length > 0) {
                    for (let i = 0; i < itemData.photos.closeup.length; i++) {
                        const photo = itemData.photos.closeup[i];
                        const filename = `${itemData.sku}_closeup_${String(i + 1).padStart(2, '0')}.jpg`;
                        const fileHandle = await closeupFolder.getFileHandle(filename, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(photo.blob);
                        await writable.close();
                    }
                } else {
                    await createNAFile(closeupFolder, null, itemData.sku);
                }
                
                // v2.9.5: Save weight PHOTOS (not Dymo text file)
                const weightFolder = await skuFolder.getDirectoryHandle('weight', { create: true });
                if (itemData.photos.weight.length > 0) {
                    for (let i = 0; i < itemData.photos.weight.length; i++) {
                        const photo = itemData.photos.weight[i];
                        const filename = `${itemData.sku}_weight_${String(i + 1).padStart(2, '0')}.jpg`;
                        const fileHandle = await weightFolder.getFileHandle(filename, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(photo.blob);
                        await writable.close();
                    }
                } else {
                    await createNAFile(weightFolder, null, itemData.sku);
                }
                
                // v2.9.5: Save handheld photos
                const handheldFolder = await skuFolder.getDirectoryHandle('handheld', { create: true });
                if (itemData.photos.handheld.length > 0) {
                    for (let i = 0; i < itemData.photos.handheld.length; i++) {
                        const photo = itemData.photos.handheld[i];
                        const filename = `${itemData.sku}_handheld_${String(i + 1).padStart(2, '0')}.jpg`;
                        const fileHandle = await handheldFolder.getFileHandle(filename, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(photo.blob);
                        await writable.close();
                    }
                } else {
                    await createNAFile(handheldFolder, null, itemData.sku);
                }
                
                // Save measurements folder contents
                const measurementsFolder = await skuFolder.getDirectoryHandle('measurements', { create: true });
                
                // Final audio
                if (itemData.audioBlob) {
                    const audioHandle = await measurementsFolder.getFileHandle(`${itemData.sku}_audio_final.webm`, { create: true });
                    const audioWritable = await audioHandle.createWritable();
                    await audioWritable.write(itemData.audioBlob);
                    await audioWritable.close();
                }
                
                // Discarded recordings for QC
                if (itemData.discardedRecordings && itemData.discardedRecordings.length > 0) {
                    for (let i = 0; i < itemData.discardedRecordings.length; i++) {
                        const discarded = itemData.discardedRecordings[i];
                        const discardHandle = await measurementsFolder.getFileHandle(`${itemData.sku}_audio_discard_${String(i + 1).padStart(2, '0')}.webm`, { create: true });
                        const discardWritable = await discardHandle.createWritable();
                        await discardWritable.write(discarded.blob);
                        await discardWritable.close();
                    }
                }
                
                // Raw transcript
                if (itemData.rawTranscript) {
                    const transcriptHandle = await measurementsFolder.getFileHandle(`${itemData.sku}_transcript_raw.txt`, { create: true });
                    const transcriptWritable = await transcriptHandle.createWritable();
                    await transcriptWritable.write(itemData.rawTranscript);
                    await transcriptWritable.close();
                }
                
                // Master JSON
                const dataFolder = await skuFolder.getDirectoryHandle('data', { create: true });
                const dataHandle = await dataFolder.getFileHandle(`${itemData.sku}_data.json`, { create: true });
                const dataWritable = await dataHandle.createWritable();
                await dataWritable.write(JSON.stringify(itemData.jsonData, null, 2));
                await dataWritable.close();
                
                return true;
            } catch (err) {
                console.error('Local save error:', err);
                return false;
            }
        }
        
        async function createNAFile(parentFolderOrNull, folderName, sku) {
            let folder;
            if (folderName) {
                folder = await parentFolderOrNull.getDirectoryHandle(folderName, { create: true });
            } else {
                folder = parentFolderOrNull; // Already the folder
            }
            const fileHandle = await folder.getFileHandle(`${sku}_NA.txt`, { create: true });
            const writable = await fileHandle.createWritable();
            await writable.write(`No data for ${sku}`);
            await writable.close();
        }
        
        // =====================================================================
        // S3 UPLOAD - v2.9.5 SIMPLIFIED FOLDER STRUCTURE
        // main/ - all main camera photos
        // closeup/ - all closeup photos (n8n categorizes later)
        // weight/ - scale display photos
        // handheld/ - handheld camera photos
        // measurements/ - audio, transcript
        // data/ - JSON file
        // =====================================================================
        async function uploadToS3(itemData) {
            const files = [];
            const sku = itemData.sku;
            
            // Main photos
            for (let i = 0; i < itemData.photos.main.length; i++) {
                const p = itemData.photos.main[i];
                const filename = `${sku}_main_${String(i + 1).padStart(2, '0')}.jpg`;
                files.push({
                    name: `main/${filename}`,
                    contentType: 'image/jpeg',
                    blob: p.blob
                });
            }
            if (itemData.photos.main.length === 0) {
                files.push({ name: `main/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No main photos for ${sku}`]) });
            }
            
            // v2.9.5: ALL closeup photos go to closeup/ folder
            // n8n will categorize them later (tag/feature/defect)
            for (let i = 0; i < itemData.photos.closeup.length; i++) {
                const p = itemData.photos.closeup[i];
                const filename = `${sku}_closeup_${String(i + 1).padStart(2, '0')}.jpg`;
                files.push({
                    name: `closeup/${filename}`,
                    contentType: 'image/jpeg',
                    blob: p.blob
                });
            }
            if (itemData.photos.closeup.length === 0) {
                files.push({ name: `closeup/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No closeup photos for ${sku}`]) });
            }
            
            // v2.9.5: Weight photos (scale display) - n8n will OCR to get value
            for (let i = 0; i < itemData.photos.weight.length; i++) {
                const p = itemData.photos.weight[i];
                const filename = `${sku}_weight_${String(i + 1).padStart(2, '0')}.jpg`;
                files.push({
                    name: `weight/${filename}`,
                    contentType: 'image/jpeg',
                    blob: p.blob
                });
            }
            if (itemData.photos.weight.length === 0) {
                files.push({ name: `weight/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No weight photo for ${sku}`]) });
            }
            
            // Handheld photos
            for (let i = 0; i < itemData.photos.handheld.length; i++) {
                const p = itemData.photos.handheld[i];
                const filename = `${sku}_handheld_${String(i + 1).padStart(2, '0')}.jpg`;
                files.push({
                    name: `handheld/${filename}`,
                    contentType: 'image/jpeg',
                    blob: p.blob
                });
            }
            if (itemData.photos.handheld.length === 0) {
                files.push({ name: `handheld/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No handheld photos for ${sku}`]) });
            }
            
            // Measurements folder - audio and transcript
            if (itemData.audioBlob) {
                files.push({ name: `measurements/${sku}_audio_final.webm`, contentType: 'audio/webm', blob: itemData.audioBlob });
            }
            
            // Discarded recordings for QC
            if (itemData.discardedRecordings && itemData.discardedRecordings.length > 0) {
                for (let i = 0; i < itemData.discardedRecordings.length; i++) {
                    const discarded = itemData.discardedRecordings[i];
                    files.push({
                        name: `measurements/${sku}_audio_discard_${String(i + 1).padStart(2, '0')}.webm`,
                        contentType: 'audio/webm',
                        blob: discarded.blob
                    });
                }
            }
            
            if (itemData.rawTranscript) {
                files.push({ name: `measurements/${sku}_transcript_raw.txt`, contentType: 'text/plain', blob: new Blob([itemData.rawTranscript]) });
            }
            
            // Master JSON with processingStatus: "pending"
            files.push({ name: `data/${sku}_data.json`, contentType: 'application/json', blob: new Blob([JSON.stringify(itemData.jsonData, null, 2)]) });
            
            // Get presigned URLs
            const presign = await callLambda('presign', {
                sku: sku,
                files: files.map(f => ({ name: f.name, contentType: f.contentType }))
            });
            
            if (!presign.success) throw new Error(presign.error || 'Presign failed');
            
            // Upload all files
            for (const f of files) {
                const url = presign.urls[f.name];
                if (url) {
                    await fetch(url, { method: 'PUT', body: f.blob, headers: { 'Content-Type': f.contentType } });
                }
            }
            
            return true;
        }
        
        // =====================================================================
        // COMPLETE ITEM - v2.9.5+ ASYNC ARCHITECTURE
        // Browser captures data and uploads quickly (2-3 sec), then resets.
        // n8n handles all heavy AI processing asynchronously:
        // - OCR on closeup photos
        // - Weight OCR from scale photos
        // - Photo routing (tag/feature/defect categorization)
        // - Full Pipeline (measurement parsing/matching)
        // =====================================================================
        async function completeItem() {
            if (!state.currentSKU) { showToast('warning', 'No SKU'); return; }
            
            // v2.9.5: Record completion time
            state.timing.completeTime = Date.now();
            
            // v2.9.5: ASYNC ARCHITECTURE - No blocking AI processing!
            // All AI (OCR, Image Processing, Photo Routing, Full Pipeline) moved to n8n
            // Browser just captures data and uploads quickly
            
            showToast('info', 'üì§ Uploading...');
            const uploadStartTime = Date.now();
            
            // ===== Calculate detailed KPI timing =====
            const now = Date.now();
            const totalDuration = Math.round((now - state.timerStart) / 1000);
            
            // Calculate phase durations from detailed timing
            const mainPhotosDuration = state.timing.mainPhotosEndTime && state.timing.mainPhotosStartTime 
                ? Math.round((state.timing.mainPhotosEndTime - state.timing.mainPhotosStartTime) / 1000) 
                : 0;
            const closeupDuration = state.timing.closeupEndTime && state.timing.closeupStartTime 
                ? Math.round((state.timing.closeupEndTime - state.timing.closeupStartTime) / 1000) 
                : 0;
            const weightDuration = state.timing.weightEndTime && state.timing.weightStartTime 
                ? Math.round((state.timing.weightEndTime - state.timing.weightStartTime) / 1000) 
                : 0;
            const handheldDuration = state.timing.handheldEndTime && state.timing.handheldStartTime 
                ? Math.round((state.timing.handheldEndTime - state.timing.handheldStartTime) / 1000) 
                : 0;
            const measurementsDuration = state.timing.measurementsEndTime && state.timing.measurementsStartTime 
                ? Math.round((state.timing.measurementsEndTime - state.timing.measurementsStartTime) / 1000) 
                : 0;
            
            // Recording KPI
            const recordingDuration = state.lastRecordingDuration || 0;
            const recordingRating = recordingDuration <= 30 ? 'excellent' : recordingDuration <= 60 ? 'good' : 'needs_improvement';
            
            // v2.9.5: Build item data - NO AI results yet, just raw capture data
            // processingStatus: "pending" tells n8n this needs AI processing
            const itemData = {
                sku: state.currentSKU,
                category: state.classification,  // From initial classify (template selection)
                templateKey: state.templateKey,
                template: state.template,
                tagData: null,  // Will be filled by n8n OCR
                measurements: state.measurements,  // Basic parsed values, n8n will improve with Matcher
                rawTranscript: state.rawTranscript,
                audioBlob: state.audioBlob,
                discardedRecordings: state.discardedRecordings,
                photos: {
                    main: state.photos.main.map(p => ({ blob: p.blob, label: p.label })),
                    closeup: state.photos.closeup.map(p => ({ blob: p.blob, label: p.label })),
                    weight: state.photos.weight.map(p => ({ blob: p.blob, label: p.label })),
                    handheld: state.photos.handheld.map(p => ({ blob: p.blob, label: p.label }))
                },
                jsonData: {
                    sku: state.currentSKU,
                    timestamp: new Date().toISOString(),
                    version: VERSION,
                    // Processing status for n8n to track
                    processingStatus: 'pending',
                    // Classification from initial AI (template selection only)
                    category: state.classification,
                    templateKey: state.templateKey,
                    // v2.9.6: Include full template so n8n knows expected measurements
                    template: state.template,
                    // Tag data will be populated by n8n OCR
                    tagData: null,
                    // Measurements placeholder - n8n will populate via fullPipeline
                    measurements: {},
                    rawTranscript: state.rawTranscript,
                    // Weight from photo (n8n will OCR)
                    weight: {
                        source: 'photo',
                        photoCount: state.photos.weight.length,
                        value: null  // n8n will OCR from photo
                    },
                    // Audio recording metadata
                    audioRecordings: {
                        final: {
                            duration: recordingDuration,
                            timestamp: new Date().toISOString()
                        },
                        discarded: state.discardedRecordings.map((d, i) => ({
                            index: i + 1,
                            duration: d.duration,
                            timestamp: d.timestamp
                        })),
                        totalAttempts: state.discardedRecordings.length + 1,
                        kpiTargets: {
                            targetDuration: 60,
                            excellentDuration: 30,
                            actualDuration: recordingDuration,
                            rating: recordingRating
                        }
                    },
                    // v2.9.6: Detailed KPI timing for analysis
                    timing: {
                        itemStartTime: state.timing.itemStartTime ? new Date(state.timing.itemStartTime).toISOString() : null,
                        classificationTime: state.timing.classificationTime ? new Date(state.timing.classificationTime).toISOString() : null,
                        mainPhotosStartTime: state.timing.mainPhotosStartTime ? new Date(state.timing.mainPhotosStartTime).toISOString() : null,
                        mainPhotosEndTime: state.timing.mainPhotosEndTime ? new Date(state.timing.mainPhotosEndTime).toISOString() : null,
                        closeupStartTime: state.timing.closeupStartTime ? new Date(state.timing.closeupStartTime).toISOString() : null,
                        closeupEndTime: state.timing.closeupEndTime ? new Date(state.timing.closeupEndTime).toISOString() : null,
                        weightStartTime: state.timing.weightStartTime ? new Date(state.timing.weightStartTime).toISOString() : null,
                        weightEndTime: state.timing.weightEndTime ? new Date(state.timing.weightEndTime).toISOString() : null,
                        handheldStartTime: state.timing.handheldStartTime ? new Date(state.timing.handheldStartTime).toISOString() : null,
                        handheldEndTime: state.timing.handheldEndTime ? new Date(state.timing.handheldEndTime).toISOString() : null,
                        measurementsStartTime: state.timing.measurementsStartTime ? new Date(state.timing.measurementsStartTime).toISOString() : null,
                        measurementsEndTime: state.timing.measurementsEndTime ? new Date(state.timing.measurementsEndTime).toISOString() : null,
                        completeTime: state.timing.completeTime ? new Date(state.timing.completeTime).toISOString() : null,
                        // Calculated durations in seconds
                        durations: {
                            mainPhotos: mainPhotosDuration,
                            closeup: closeupDuration,
                            weight: weightDuration,
                            handheld: handheldDuration,
                            measurements: measurementsDuration,
                            total: totalDuration
                        }
                    },
                    // Photo counts
                    photoCount: {
                        main: state.photos.main.length,
                        closeup: state.photos.closeup.length,
                        weight: state.photos.weight.length,
                        handheld: state.photos.handheld.length
                    },
                    // Photographer tracking
                    photographerId: state.photographerId,
                    // Placeholders for n8n to fill
                    aiResults: null,  // n8n will populate with OCR, routing, pipeline results
                    qcFlags: null,
                    eraEstimation: null,
                    tagSizeAnalysis: null
                }
            };
            
            // Update stats
            state.completedItems++;
            state.totalTime += totalDuration;
            localStorage.setItem('completedItems', state.completedItems);
            localStorage.setItem('totalTime', state.totalTime);
            updateStats();
            
            // IMMEDIATELY reset UI for next item - no waiting for upload
            showToast('success', `${state.currentSKU} submitted!`);
            stopTimer();
            resetItem();
            
            // Process upload in background with retry
            processItemInBackground(itemData);
        }
        
        // =====================================================================
        // BACKGROUND PROCESSING - ASYNC ARCHITECTURE
        // No AI processing here - just upload to S3 and trigger n8n
        // n8n handles: OCR, image processing, photo routing, full pipeline
        // =====================================================================
        async function processItemInBackground(itemData, retryCount = 0) {
            const sku = itemData.sku;
            console.log(`üîÑ [${sku}] Starting save/upload...`);
            
            try {
                // =================================================================
                // STEP 1: SAVE TO LOCAL FOLDER
                // =================================================================
                console.log(`üíæ [${sku}] Step 1: Saving to local folder...`);
                
                if (state.saveDirectoryHandle) {
                    await saveToLocalFolder(itemData);
                    console.log(`‚úÖ [${sku}] Saved to local folder`);
                }
                
                // =================================================================
                // STEP 2: UPLOAD TO S3
                // =================================================================
                console.log(`‚òÅÔ∏è [${sku}] Step 2: Uploading to S3...`);
                
                await uploadToS3(itemData);
                console.log(`‚úÖ [${sku}] Uploaded to S3`);
                
                // =================================================================
                // STEP 3: SEND TO N8N
                // =================================================================
                console.log(`üì§ [${sku}] Step 3: Sending to n8n...`);
                
                await callLambda('n8n', { formData: itemData.jsonData });
                console.log(`‚úÖ [${sku}] Sent to n8n`);
                
                console.log(`üéâ [${sku}] Background processing complete!`);
                
            } catch (err) {
                console.error(`‚ùå [${sku}] Background process failed:`, err);
                
                if (retryCount < MAX_RETRIES) {
                    console.log(`‚Üª [${sku}] Retry ${retryCount + 1}/${MAX_RETRIES} in ${RETRY_DELAY/1000}s...`);
                    setTimeout(() => processItemInBackground(itemData, retryCount + 1), RETRY_DELAY);
                } else {
                    showToast('warning', `‚ö†Ô∏è ${sku} upload incomplete - queued for retry`);
                    addToRetryQueue(itemData);
                }
            }
        }
        
        function addToRetryQueue(itemData) {
            // Store minimal data (can't store blobs in localStorage)
            const queueItem = {
                sku: itemData.sku,
                jsonData: itemData.jsonData,
                timestamp: Date.now()
            };
            state.retryQueue.push(queueItem);
            localStorage.setItem('retryQueue', JSON.stringify(state.retryQueue));
            updateRetryBadge();
        }
        
        function updateRetryBadge() {
            const badge = document.getElementById('retry-badge');
            if (state.retryQueue.length > 0) {
                badge.textContent = `‚ö†Ô∏è ${state.retryQueue.length} pending`;
                badge.classList.add('visible');
            } else {
                badge.classList.remove('visible');
            }
        }
        
        async function processRetryQueue() {
            if (state.retryQueue.length === 0) return;
            
            const toRetry = [...state.retryQueue];
            state.retryQueue = [];
            
            for (const item of toRetry) {
                try {
                    await callLambda('n8n', { formData: item.jsonData });
                    console.log(`‚úÖ Retry success: ${item.sku}`);
                } catch (e) {
                    state.retryQueue.push(item);
                }
            }
            
            localStorage.setItem('retryQueue', JSON.stringify(state.retryQueue));
            updateRetryBadge();
        }
        
        // =====================================================================
        // SKU & TIMER
        // =====================================================================
        function startNewItem() {
            const sku = document.getElementById('sku-input').value.trim().toUpperCase();
            if (!sku) { showToast('warning', 'Enter a SKU'); return; }
            
            const now = Date.now();
            state.currentSKU = sku;
            state.photos = { main: [], closeup: [], weight: [], handheld: [] };
            state.classification = null;
            state.templateKey = null;
            state.template = null;
            state.tagData = null;
            state.measurements = {};
            state.rawTranscript = '';
            state.audioBlob = null;
            state.aiTriggered = false;
            // v2.9.5: Detailed timing for KPIs
            state.timing = {
                itemStartTime: now,
                classificationTime: null,
                mainPhotosStartTime: now,  // Starting in main mode
                mainPhotosEndTime: null,
                closeupStartTime: null,
                closeupEndTime: null,
                weightStartTime: null,
                weightEndTime: null,
                measurementsStartTime: null,
                measurementsEndTime: null,
                completeTime: null
            };
            state.discardedRecordings = [];
            state.lastRecordingDuration = 0;
            
            document.getElementById('sku-row').style.display = 'none';
            document.getElementById('sku-display').textContent = sku;
            document.getElementById('sku-display').classList.add('visible');
            
            document.getElementById('classification-box').classList.remove('ready');
            document.getElementById('classification-category').textContent = 'Waiting...';
            document.getElementById('classification-template').textContent = '-';
            document.getElementById('tag-grid').style.display = 'none';
            document.getElementById('measurement-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 12px; text-align: center;">Classify first</div>';
            document.getElementById('transcript-box').classList.remove('visible');
            document.getElementById('complete-btn-camera').disabled = true;
            
            // v2.9.5: Reset weight photo status
            updateWeightPhotoStatus();
            
            updatePhotoGrid();
            updatePhotoCount();
            startTimer();
            switchCameraMode('main');
            showToast('success', `Started: ${sku}`);
        }
        
        function cancelItem() {
            if (!confirm(`Cancel item ${state.currentSKU}?`)) return;
            resetItem();
            showToast('info', 'Item cancelled');
        }
        
        function resetItem() {
            state.currentSKU = '';
            state.photos = { main: [], closeup: [], weight: [], handheld: [] };
            state.classification = null;
            state.templateKey = null;
            state.template = null;
            state.tagData = null;
            state.measurements = {};
            state.rawTranscript = '';
            state.audioBlob = null;
            state.aiTriggered = false;
            // v2.9.6: Reset detailed timing (including handheld)
            state.timing = {
                itemStartTime: null,
                classificationTime: null,
                mainPhotosStartTime: null,
                mainPhotosEndTime: null,
                closeupStartTime: null,
                closeupEndTime: null,
                weightStartTime: null,
                weightEndTime: null,
                handheldStartTime: null,
                handheldEndTime: null,
                measurementsStartTime: null,
                measurementsEndTime: null,
                completeTime: null
            };
            state.discardedRecordings = [];
            state.lastRecordingDuration = 0;
            
            document.getElementById('sku-input').value = '';
            document.getElementById('sku-row').style.display = 'flex';
            document.getElementById('sku-display').classList.remove('visible');
            
            document.getElementById('classification-box').classList.remove('ready');
            document.getElementById('classification-category').textContent = 'Waiting...';
            document.getElementById('classification-template').textContent = '-';
            document.getElementById('tag-grid').style.display = 'none';
            document.getElementById('measurement-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 12px; text-align: center;">Classify first</div>';
            document.getElementById('transcript-box').classList.remove('visible');
            document.getElementById('complete-btn-camera').disabled = true;
            
            // v2.9.5: Reset weight photo status
            updateWeightPhotoStatus();
            
            // Reset recording button state
            const btn = document.getElementById('record-btn');
            btn.classList.remove('btn-stop');
            btn.classList.add('btn-record');
            btn.textContent = 'üé§ TAP TO RECORD';
            
            updatePhotoGrid();
            updatePhotoCount();
            stopTimer();
            document.getElementById('timer').textContent = '0:00';
        }
        
        function startTimer() {
            stopTimer();
            state.timerStart = Date.now();
            state.timerInterval = setInterval(() => {
                const s = Math.floor((Date.now() - state.timerStart) / 1000);
                document.getElementById('timer').textContent = `${Math.floor(s / 60)}:${String(s % 60).padStart(2, '0')}`;
            }, 1000);
        }
        
        function stopTimer() {
            if (state.timerInterval) clearInterval(state.timerInterval);
        }
        
        function updateStats() {
            document.getElementById('item-count').textContent = state.completedItems;
            if (state.completedItems > 0) {
                const avg = Math.round(state.totalTime / state.completedItems);
                document.getElementById('avg-time').textContent = `${Math.floor(avg / 60)}:${String(avg % 60).padStart(2, '0')}`;
            }
        }
        
        // =====================================================================
        // BARCODE SCANNER (with debounce to prevent rapid-fire detection)
        // =====================================================================
        let barcodeDetected = false;
        
        function openBarcodeScanner() {
            barcodeDetected = false;
            document.getElementById('barcode-modal').classList.add('active');
            document.getElementById('barcode-status').textContent = 'Starting...';
            document.getElementById('barcode-status').classList.remove('success');
            
            const deviceId = state.cameras.barcode.deviceId || state.availableCameras[0]?.deviceId;
            
            Quagga.init({
                inputStream: {
                    type: 'LiveStream',
                    target: document.getElementById('barcode-container'),
                    constraints: { deviceId: deviceId ? { exact: deviceId } : undefined, facingMode: 'environment' },
                    willReadFrequently: true
                },
                decoder: { readers: ['code_128_reader', 'ean_reader', 'ean_8_reader', 'upc_reader', 'upc_e_reader'] },
                locate: true,
                frequency: 10
            }, err => {
                if (err) {
                    document.getElementById('barcode-status').textContent = 'Scanner error';
                    console.error('Quagga init error:', err);
                    return;
                }
                document.getElementById('barcode-status').textContent = 'Point at barcode...';
                Quagga.start();
                Quagga.onDetected(result => {
                    if (barcodeDetected) return;
                    barcodeDetected = true;
                    Quagga.stop();
                    
                    const code = result.codeResult.code;
                    console.log('üìä Barcode detected:', code);
                    document.getElementById('barcode-status').textContent = code;
                    document.getElementById('barcode-status').classList.add('success');
                    document.getElementById('sku-input').value = code;
                    
                    setTimeout(() => { 
                        closeBarcodeScanner(); 
                        showToast('success', `Scanned: ${code}`); 
                    }, 500);
                });
            });
        }
        
        function closeBarcodeScanner() {
            barcodeDetected = false;
            try { Quagga.stop(); Quagga.offDetected(); } catch {}
            document.getElementById('barcode-modal').classList.remove('active');
        }
        
        // =====================================================================
        // SETTINGS
        // =====================================================================
        function openSettings() { document.getElementById('settings-modal').classList.add('active'); }
        function closeSettings() { document.getElementById('settings-modal').classList.remove('active'); }
        
        function saveSettings() {
            // v2.9.5: Include weight camera
            ['main', 'closeup', 'weight', 'handheld', 'barcode'].forEach(mode => {
                const sel = document.getElementById(`camera-${mode}`);
                if (sel) {
                    state.cameras[mode].deviceId = sel.value;
                    localStorage.setItem(`camera-${mode}`, sel.value);
                }
            });
            const url = document.getElementById('lambda-url').value.trim();
            if (url) { state.lambdaUrl = url; localStorage.setItem('lambdaUrl', url); }
            
            // v2.9.5: Save photographer ID
            const photographerId = document.getElementById('photographer-id').value.trim() || 'photographer_1';
            state.photographerId = photographerId;
            localStorage.setItem('photographerId', photographerId);
            
            closeSettings();
            showToast('success', 'Settings saved');
            startCamera(state.currentMode);
            checkLambda();
        }
        
        // =====================================================================
        // v2.9.5: DYMO USB SCALE REMOVED
        // Weight is now captured via photo of scale display
        // n8n will OCR the weight photo to extract the value
        // =====================================================================
        
        // =====================================================================
        // TOAST
        // =====================================================================
        function showToast(type, msg) {
            const c = document.getElementById('toast-container');
            const t = document.createElement('div');
            t.className = `toast ${type}`;
            t.textContent = msg;
            c.appendChild(t);
            setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 300); }, 3000);
        }
        
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>

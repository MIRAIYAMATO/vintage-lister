<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VintageLister - Desktop Station</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root { 
            /* Primary Colors */
            --color-primary: #3b82f6; 
            --color-primary-dark: #2563eb; 
            --color-primary-light: #dbeafe;
            --color-primary-lighter: #eff6ff;
            
            /* Status Colors */
            --color-success: #22c55e;
            --color-success-dark: #16a34a;
            --color-warning: #f59e0b;
            --color-warning-dark: #d97706;
            --color-warning-light: #fef3c7;
            --color-warning-lighter: #fffbeb;
            --color-warning-text: #92400e;
            --color-error: #ef4444;
            --color-error-dark: #dc2626;
            --color-error-light: #fef2f2;
            
            /* Neutral Colors */
            --color-surface: #ffffff; 
            --color-background: #f1f5f9; 
            --color-text: #1e293b; 
            --color-text-muted: #64748b; 
            --color-text-light: #94a3b8;
            --color-border: #e2e8f0;
            --color-border-dark: #cbd5e1;
            
            /* Dark UI Colors */
            --color-dark: #1e293b;
            --color-dark-lighter: #334155;
            --color-dark-border: #475569;
            
            /* Spacing */
            --radius-sm: 6px;
            --radius-md: 8px;
            --radius-lg: 10px;
            --radius-xl: 12px;
            
            /* Transitions */
            --transition-fast: 0.1s ease;
            --transition-normal: 0.2s ease;
        }
        
        /* Utility Classes */
        .text-success { color: var(--color-success) !important; }
        .text-success-dark { color: var(--color-success-dark) !important; }
        .text-error { color: var(--color-error) !important; }
        .text-warning { color: var(--color-warning) !important; }
        .text-warning-text { color: var(--color-warning-text) !important; }
        .text-primary { color: var(--color-primary) !important; }
        .text-muted { color: var(--color-text-muted) !important; }
        .bg-success { background: var(--color-success) !important; }
        .bg-error { background: var(--color-error) !important; }
        .bg-warning { background: var(--color-warning-light) !important; }
        * { box-sizing: border-box; }
        html, body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #0f172a; margin: 0; padding: 0; height: 100vh; overflow: hidden; }
        
        /* TOAST NOTIFICATIONS */
        .toast-container { position: fixed; top: 20px; right: 20px; z-index: 9999; display: flex; flex-direction: column; gap: 10px; pointer-events: none; }
        .toast { background: #1e293b; color: white; padding: 14px 20px; border-radius: 10px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); display: flex; align-items: center; gap: 12px; min-width: 280px; max-width: 400px; animation: slideIn 0.3s ease; pointer-events: auto; }
        .toast.success { background: linear-gradient(135deg, #059669, #047857); }
        .toast.error { background: linear-gradient(135deg, #dc2626, #b91c1c); }
        .toast.warning { background: linear-gradient(135deg, #d97706, #b45309); }
        .toast.info { background: linear-gradient(135deg, #2563eb, #1d4ed8); }
        .toast-icon { font-size: 20px; flex-shrink: 0; }
        .toast-content { flex: 1; }
        .toast-title { font-weight: 700; font-size: 14px; margin-bottom: 2px; }
        .toast-message { font-size: 12px; opacity: 0.9; line-height: 1.4; }
        .toast-close { background: rgba(255,255,255,0.2); border: none; color: white; width: 24px; height: 24px; border-radius: 50%; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; }
        .toast-close:hover { background: rgba(255,255,255,0.3); }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideOut { from { transform: translateX(0); opacity: 1; } to { transform: translateX(100%); opacity: 0; } }
        .toast.hiding { animation: slideOut 0.3s ease forwards; }
        
        /* PIN LOCK SCREEN */
        .pin-screen { position: fixed; inset: 0; z-index: 1000; background: linear-gradient(135deg, #1e293b, #0f172a); display: flex; flex-direction: column; align-items: center; justify-content: center; }
        .pin-screen.hidden { display: none; }
        .pin-box { background: white; border-radius: 20px; padding: 32px; width: 340px; text-align: center; box-shadow: 0 25px 50px rgba(0,0,0,0.3); }
        .pin-title { font-size: 24px; font-weight: 800; margin-bottom: 8px; }
        .pin-subtitle { color: var(--color-text-muted); font-size: 14px; margin-bottom: 20px; }
        .pin-input { width: 100%; padding: 16px; font-size: 32px; text-align: center; letter-spacing: 12px; border: 2px solid var(--color-border); border-radius: var(--radius-xl); font-family: monospace; margin-bottom: 16px; transition: var(--transition-fast); }
        .pin-input:focus { outline: none; border-color: var(--color-primary); }
        .pin-input.shake { animation: shake 0.3s; border-color: var(--color-error); }
        @keyframes shake { 0%,100%{transform:translateX(0)} 25%{transform:translateX(-8px)} 75%{transform:translateX(8px)} }
        .photographer-select { width: 100%; padding: 12px; border: 2px solid var(--color-border); border-radius: var(--radius-lg); font-size: 14px; margin-bottom: 20px; transition: var(--transition-fast); }
        .photographer-select:focus { outline: none; border-color: var(--color-primary); }
        .pin-btn { width: 100%; padding: 16px; background: var(--color-primary); color: white; border: none; border-radius: var(--radius-xl); font-size: 16px; font-weight: 700; cursor: pointer; transition: var(--transition-fast); }
        .pin-btn:hover { background: var(--color-primary-dark); }
        .pin-btn:active { transform: scale(0.98); }
        .pin-version { color: #475569; font-size: 12px; margin-top: 16px; }
        
        .desktop-layout { display: grid; grid-template-columns: 420px 1fr 280px; height: 100vh; overflow: hidden; }
        .form-panel { background: var(--color-surface); display: flex; flex-direction: column; overflow: hidden; }
        .camera-panel { background: #000; display: flex; flex-direction: column; overflow: hidden; height: 100%; max-height: 100vh; }
        .photos-panel { background: var(--color-background); overflow-y: auto; padding: 16px; border-left: 1px solid var(--color-border); }
        
        /* FLOATING TIMER */
        .floating-timer { position: sticky; top: 0; z-index: 10; background: linear-gradient(135deg, var(--color-primary), var(--color-primary-dark)); color: white; padding: 12px 16px; display: flex; justify-content: space-between; align-items: center; box-shadow: 0 4px 12px rgba(59,130,246,0.3); }
        .timer-main { font-size: 28px; font-weight: 800; font-family: monospace; }
        .timer-stats { text-align: right; font-size: 11px; opacity: 0.9; }
        .timer-label { font-size: 10px; opacity: 0.7; }
        .photographer-badge { background: rgba(255,255,255,0.2); padding: 4px 10px; border-radius: 6px; font-size: 11px; font-weight: 600; cursor: pointer; }
        .version-badge { background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px; font-size: 10px; font-weight: 600; font-family: monospace; }
        .folder-btn { background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 4px 10px; border-radius: 6px; font-size: 10px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
        .folder-btn:hover { background: rgba(255,255,255,0.25); }
        .folder-btn.active { background: rgba(34,197,94,0.3); border-color: #22c55e; }
        
        /* PROGRESS BAR */
        .progress-bar { display: flex; justify-content: center; align-items: center; gap: 8px; padding: 12px 16px; background: var(--color-background); border-bottom: 1px solid var(--color-border); flex-wrap: wrap; }
        .progress-dot { width: 12px; height: 12px; border-radius: 50%; background: var(--color-border); cursor: pointer; transition: all 0.2s; }
        .progress-dot.active { background: var(--color-primary); transform: scale(1.3); }
        .progress-dot.complete { background: var(--color-success); }
        .progress-label { font-size: 11px; color: var(--color-text-muted); font-weight: 600; margin-left: 8px; }
        .category-badge { font-size: 11px; color: var(--color-primary); font-weight: 700; text-transform: uppercase; margin-left: 4px; }
        .sku-badge { font-size: 10px; background: var(--color-success); color: white; font-weight: 700; padding: 2px 8px; border-radius: 10px; margin-left: 8px; font-family: monospace; display: none; }
        .sku-badge.visible { display: inline-block; }
        
        /* STEP CONTAINER */
        .step-area { flex: 1; overflow-y: auto; padding: 16px; }
        .step-container { display: none; }
        .step-container.active { display: block; }
        
        .section-card { background: var(--color-background); border: 1px solid var(--color-border); border-radius: 12px; padding: 14px; margin-bottom: 12px; }
        .section-label { font-size: 12px; font-weight: 700; color: var(--color-text); margin-bottom: 10px; display: flex; align-items: center; gap: 6px; }
        .check-circle { width: 20px; height: 20px; border-radius: 50%; background: var(--color-border); color: #999; display: flex; align-items: center; justify-content: center; font-size: 11px; }
        .check-circle.complete { background: var(--color-success); color: white; }
        
        .btn { padding: 10px 12px; border-radius: var(--radius-md); font-size: 12px; font-weight: 600; cursor: pointer; border: 2px solid transparent; transition: var(--transition-fast); text-align: center; }
        .btn:active { transform: scale(0.97); }
        .btn-tertiary { background: white; color: var(--color-text-muted); border: 1px solid var(--color-border); }
        .btn-tertiary:hover { background: var(--color-background); }
        .btn-tertiary.selected { border: 2px solid var(--color-primary) !important; background: var(--color-primary) !important; color: white !important; }
        /* btn-hero = selected state */
        /* btn-hero = solid blue (confirmed selection) */
        .btn-hero { background: var(--color-primary); color: white !important; border: 2px solid var(--color-primary-dark) !important; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .btn-hero:hover { background: var(--color-primary-dark); }
        .btn-hero:active { transform: scale(0.98); }
        .btn-hero.selected { background: var(--color-primary-dark); box-shadow: 0 0 0 3px rgba(59,130,246,0.3); }
        /* btn-secondary = white with gray border (other options) */
        .btn-secondary { background: white; color: var(--color-text); border: 2px solid var(--color-border); }
        .btn-secondary:hover { background: var(--color-background); border-color: var(--color-border-dark); }
        .btn-secondary:active { transform: scale(0.98); }
        .btn-secondary.selected { border-color: var(--color-primary); background: var(--color-primary-light); }
        .btn-grid { display: grid; gap: 8px; }
        .btn-grid-2 { grid-template-columns: repeat(2, 1fr); }
        .btn-grid-3 { grid-template-columns: repeat(3, 1fr); }
        .btn-grid-4 { grid-template-columns: repeat(4, 1fr); }
        
        .form-input, .form-select { width: 100%; padding: 10px 12px; border: 2px solid var(--color-border); border-radius: var(--radius-md); font-size: 14px; transition: var(--transition-fast); }
        .form-input:focus, .form-select:focus { outline: none; border-color: var(--color-primary); }
        
        .sub-label { font-size: 11px; color: var(--color-text-muted); font-weight: 600; margin: 10px 0 8px 0; }
        .nested-section { background: rgba(59,130,246,0.05); border: 1px solid rgba(59,130,246,0.2); border-radius: 8px; padding: 12px; margin-top: 10px; }
        .nested-amber { background: rgba(245,158,11,0.1); border-color: rgba(245,158,11,0.3); }
        
        /* Super Category */
        .super-btn { display: flex; flex-direction: column; align-items: center; gap: 4px; padding: 16px 12px; font-size: 11px; font-weight: 700; }
        .super-btn .emoji { font-size: 24px; }
        .super-btn.selected { background: var(--color-primary) !important; color: white !important; border-color: var(--color-primary) !important; }
        
        /* Category buttons */
        .cat-hero { padding: 16px; font-size: 15px; font-weight: 700; border-radius: 8px; border: 2px solid var(--color-border); cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 8px; width: 100%; margin-bottom: 8px; background: white; color: var(--color-text); transition: all 0.15s; }
        .cat-hero:hover { background: var(--color-background); border-color: var(--color-primary); }
        .cat-hero.selected { background: var(--color-primary) !important; color: white !important; border: 2px solid var(--color-primary) !important; box-shadow: 0 0 0 4px rgba(59,130,246,0.3); }
        .cat-secondary { background: white; color: var(--color-text); border: 2px solid var(--color-border); padding: 12px; font-size: 13px; font-weight: 600; border-radius: 8px; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 6px; transition: all 0.15s; }
        .cat-secondary:hover { background: var(--color-background); border-color: var(--color-primary); }
        .cat-secondary.selected { border-color: var(--color-primary) !important; background: var(--color-primary) !important; color: white !important; box-shadow: 0 0 0 3px rgba(59,130,246,0.3); }
        .cat-other { background: white; color: var(--color-text-muted); border: 1px solid var(--color-border); padding: 8px; font-size: 11px; font-weight: 600; border-radius: 6px; cursor: pointer; transition: all 0.15s; }
        .cat-other:hover { border-color: var(--color-primary); color: var(--color-text); }
        .cat-other.selected { border-color: var(--color-primary); background: var(--color-primary); color: white; box-shadow: 0 0 0 2px rgba(59,130,246,0.3); }
        
        /* Color grid */
        .color-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 8px; }
        /* V97 style: color-item with label below */
        .color-item { display: flex; flex-direction: column; align-items: center; cursor: pointer; padding: 4px; border-radius: 10px; transition: all 0.15s ease; border: 3px solid transparent; }
        .color-item:hover { transform: scale(1.02); }
        .color-item:active { transform: scale(0.95); }
        .color-item span { font-size: 9px; color: #64748b; margin-top: 4px; text-align: center; line-height: 1.1; }
        .color-item.selected { border-color: var(--color-primary); background: #dbeafe; }
        .color-item.selected span { color: var(--color-primary); font-weight: 700; }
        .color-swatch { width: 100%; aspect-ratio: 1; min-height: 40px; border-radius: 8px; border: 2px solid transparent; transition: all 0.15s ease; }
        
        /* Cards */
        .cards-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 10px; }
        .card { background: white; border: 2px solid var(--color-border); border-radius: 8px; padding: 12px; cursor: pointer; position: relative; }
        .card:hover { background: var(--color-background); }
        .card.selected { border-color: var(--color-primary); background: var(--color-primary); }
        .card.selected .card-name { color: white !important; }
        .card.selected .card-desc { color: rgba(255,255,255,0.9) !important; }
        .card.priority-1 { grid-column: span 2; background: linear-gradient(135deg, #eff6ff, #dbeafe); border: 2px dashed var(--color-primary); }
        .card.priority-1.selected { border-style: solid; background: var(--color-primary); }
        .card.dimmed { opacity: 0.3; pointer-events: none; }
        .card-name { font-size: 13px; font-weight: 700; color: var(--color-text); }
        .card-desc { font-size: 10px; color: var(--color-text-muted); margin-top: 6px; line-height: 1.3; }
        .card-help { position: absolute; top: 6px; right: 6px; width: 18px; height: 18px; border-radius: 50%; background: rgba(59,130,246,0.1); color: var(--color-primary); font-size: 10px; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .card.selected .card-help { background: rgba(255,255,255,0.2); color: white; }
        /* Reference Modal (Visual Search) */
        .ref-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 9999; display: flex; align-items: center; justify-content: center; opacity: 0; visibility: hidden; transition: all 0.2s ease; }
        .ref-modal-overlay.visible { opacity: 1; visibility: visible; }
        .ref-modal { background: white; border-radius: 16px; padding: 24px; max-width: 340px; width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.3); transform: scale(0.9); transition: transform 0.2s ease; text-align: center; }
        .ref-modal-overlay.visible .ref-modal { transform: scale(1); }
        .ref-modal-title { font-size: 20px; font-weight: 700; color: var(--color-text); margin-bottom: 8px; }
        .ref-modal-desc { font-size: 14px; color: var(--color-text-muted); line-height: 1.5; margin-bottom: 20px; }
        .ref-modal-link { display: block; width: 100%; padding: 14px; background: var(--color-primary); color: white; border: none; border-radius: 10px; font-size: 15px; font-weight: 600; cursor: pointer; text-decoration: none; margin-bottom: 12px; }
        .ref-modal-link:hover { background: var(--color-primary-dark); }
        .ref-modal-close { width: 100%; padding: 12px; background: #f1f5f9; color: var(--color-text-muted); border: none; border-radius: 10px; font-size: 14px; font-weight: 600; cursor: pointer; }
        
        /* Help panel */
        .help-btn { width: 100%; padding: 10px; background: var(--color-warning-light); border: 2px dashed var(--color-warning); border-radius: var(--radius-md); font-size: 12px; font-weight: 600; color: var(--color-warning-text); cursor: pointer; transition: var(--transition-fast); }
        .help-btn:hover { background: var(--color-warning-lighter); border-color: var(--color-warning-dark); }
        .help-btn:active { transform: scale(0.98); }
        .help-panel { background: #fffbeb; border: 2px solid #f59e0b; border-radius: 8px; padding: 12px; margin-top: 10px; }
        .help-panel.hidden { display: none; }
        .filter-row { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px; }
        .filter-btn { padding: 8px 10px; font-size: 10px; font-weight: 700; text-transform: uppercase; background: white; border: 1px solid var(--color-border); border-radius: var(--radius-sm); color: var(--color-text-muted); cursor: pointer; transition: var(--transition-fast); min-width: fit-content; }
        .filter-btn:hover { background: var(--color-background); border-color: var(--color-border-dark); }
        .filter-btn:active { transform: scale(0.97); }
        .filter-btn.active { background: var(--color-primary); border-color: var(--color-primary); color: white; }
        .help-text { background: #fef3c7; border-radius: 6px; padding: 8px 10px; font-size: 11px; color: #92400e; margin-top: 8px; }
        .help-text.hidden { display: none; }
        
        .tag-warning { background: #fef2f2; border: 2px solid #fca5a5; border-radius: 8px; padding: 10px; font-size: 11px; font-weight: 600; color: #b91c1c; text-align: center; margin-bottom: 10px; }
        .tag-warning.hidden { display: none; }
        
        /* Defect buttons with emoji */
        .defect-card { display: flex; flex-direction: column; align-items: center; padding: 12px 8px; gap: 4px; }
        .defect-card .emoji { font-size: 24px; }
        .defect-card .label { font-size: 10px; font-weight: 700; }
        
        /* Navigation */
        .nav-buttons { display: flex; gap: 12px; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--color-border); }
        .nav-btn { flex: 1; padding: 14px; border-radius: var(--radius-lg); font-size: 14px; font-weight: 700; cursor: pointer; border: none; transition: var(--transition-fast); }
        .nav-btn:active { transform: scale(0.98); }
        .nav-btn-back { background: white; color: var(--color-text); border: 2px solid var(--color-border); }
        .nav-btn-back:hover { background: var(--color-background); border-color: var(--color-border-dark); }
        .nav-btn-next { background: var(--color-primary); color: white; flex: 2; }
        .nav-btn-next:hover { background: var(--color-primary-dark); }
        
        /* Camera */
        .camera-header { background: #111; padding: 10px 16px; display: flex; justify-content: space-between; align-items: center; gap: 12px; border-bottom: 1px solid #333; flex-shrink: 0; }
        .camera-select { background: var(--color-dark); border: 1px solid var(--color-dark-border); color: white; padding: 8px 12px; border-radius: var(--radius-sm); font-size: 12px; flex: 1; max-width: 220px; transition: var(--transition-fast); }
        .camera-select:focus { outline: none; border-color: var(--color-primary); }
        .camera-status { font-size: 11px; font-weight: 700; color: #555; }
        .camera-status.live { color: #22c55e; }
        .camera-status.live::before { content: '●'; margin-right: 6px; animation: pulse 2s infinite; }
        @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:0.5} }
        .camera-view { flex: 1; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; background: #000; min-height: 0; }
        .camera-view-container { position: relative; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; overflow: hidden; }
        .camera-view video { 
            max-height: 100%;
            max-width: 100%;
            object-fit: contain;
            transition: opacity 0.15s ease, transform 0.3s ease;
        }
        .camera-view video.switching { opacity: 0.3; }
        .camera-placeholder { color: #444; text-align: center; position: absolute; z-index: 1; }
        .camera-placeholder-icon { font-size: 48px; margin-bottom: 12px; }
        .camera-overlay { position: absolute; inset: 0; pointer-events: none; display: none; }
        /* Stabilizer indicator */
        .stabilizer-indicator { position: absolute; top: 12px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.7); padding: 6px 14px; border-radius: 20px; z-index: 10; }
        .stabilizer-dot { width: 14px; height: 14px; border-radius: 50%; background: #ef4444; transition: background 0.2s ease; }
        .stabilizer-dot.stable { background: #22c55e; animation: pulse-green 1s ease-in-out infinite; }
        @keyframes pulse-green { 0%, 100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.6); } 50% { box-shadow: 0 0 0 8px rgba(34, 197, 94, 0); } }
        .stabilizer-text { color: white; font-size: 11px; font-weight: 700; letter-spacing: 0.5px; }
        .camera-footer { background: #111; padding: 16px; display: flex; justify-content: center; align-items: center; gap: 16px; border-top: 1px solid #333; flex-shrink: 0; }
        .shutter-btn { width: 70px; height: 70px; border-radius: 50%; background: white; border: 4px solid var(--color-dark-border); cursor: pointer; transition: var(--transition-fast); }
        .shutter-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(255,255,255,0.3); }
        .shutter-btn:active { transform: scale(0.95); background: var(--color-background); }
        .shutter-btn.flash { animation: btnflash 0.15s; }
        @keyframes btnflash { 0%{background:white} 50%{background:var(--color-primary)} 100%{background:white} }
        .shutter-hint { color: #555; font-size: 11px; text-align: center; }
        .shutter-hint kbd { background: #333; padding: 3px 6px; border-radius: 4px; font-family: monospace; color: #aaa; }
        .mode-btn { padding: 10px 16px; background: var(--color-dark); border: 2px solid var(--color-dark-border); color: var(--color-text-light); border-radius: var(--radius-md); font-size: 12px; font-weight: 600; cursor: pointer; line-height: 1.3; min-width: 80px; transition: var(--transition-fast); }
        .mode-btn:hover { border-color: var(--color-primary); }
        .mode-btn:active { transform: scale(0.97); }
        .mode-btn.active { background: var(--color-primary); border-color: var(--color-primary); color: white; }
        
        /* Split-screen Defect Closeup View */
        .split-defect-view { display: flex; width: 100%; height: 100%; gap: 4px; padding: 8px; box-sizing: border-box; }
        .split-left { flex: 0 0 45%; display: flex; flex-direction: column; background: #1a1a1a; border-radius: 12px; overflow: hidden; }
        .split-right { flex: 1; display: flex; flex-direction: column; background: #1a1a1a; border-radius: 12px; overflow: hidden; position: relative; }
        .split-header { display: flex; align-items: center; background: #111; padding: 0; flex-shrink: 0; }
        .split-tab { flex: 1; padding: 12px 16px; font-size: 13px; font-weight: 700; text-align: center; cursor: pointer; border: none; background: #333; color: #888; transition: all 0.15s; }
        .split-tab:first-child { border-radius: 12px 0 0 0; }
        .split-tab:last-child { border-radius: 0 12px 0 0; }
        .split-tab:hover { background: #444; color: #ccc; }
        .split-tab.active { background: #dc2626; color: white; }
        .split-tab.has-defects::after { content: '●'; margin-left: 6px; color: #22c55e; }
        .split-tab-count { display: inline-block; background: rgba(255,255,255,0.2); padding: 2px 8px; border-radius: 10px; font-size: 11px; margin-left: 6px; }
        .split-label { background: #dc2626; color: white; padding: 8px 16px; font-size: 12px; font-weight: 700; text-align: center; flex-shrink: 0; }
        .split-right .split-label { background: #059669; }
        .split-photo-area { flex: 1; display: flex; flex-direction: column; min-height: 0; }
        .split-photo-container { flex: 1; position: relative; display: flex; align-items: center; justify-content: center; padding: 12px; min-height: 0; overflow: hidden; }
        /* Image wrapper ensures dots are positioned relative to image */
        .split-photo-wrapper { position: relative; display: inline-block; max-width: 100%; max-height: 100%; }
        .split-photo-wrapper img { display: block; max-width: 100%; max-height: 100%; object-fit: contain; border-radius: 8px; }
        .split-defect-dot { position: absolute; width: 44px; height: 44px; border-radius: 50%; cursor: pointer; transform: translate(-50%, -50%); display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: 700; color: white; border: 3px solid white; box-shadow: 0 2px 10px rgba(0,0,0,0.5); transition: transform 0.15s, box-shadow 0.15s; z-index: 10; }
        .split-defect-dot:hover { transform: translate(-50%, -50%) scale(1.15); box-shadow: 0 4px 20px rgba(0,0,0,0.7); }
        .split-defect-dot.selected { transform: translate(-50%, -50%) scale(1.2); box-shadow: 0 0 0 4px white, 0 0 20px rgba(255,255,255,0.5); animation: pulse-selected 1.5s infinite; }
        @keyframes pulse-selected { 0%, 100% { box-shadow: 0 0 0 4px white, 0 0 20px rgba(255,255,255,0.5); } 50% { box-shadow: 0 0 0 6px white, 0 0 30px rgba(255,255,255,0.7); } }
        .split-defect-dot-label { position: absolute; top: 100%; left: 50%; transform: translateX(-50%); margin-top: 6px; background: rgba(0,0,0,0.9); color: white; padding: 4px 10px; border-radius: 6px; font-size: 11px; font-weight: 600; white-space: nowrap; pointer-events: none; }
        .split-selection { background: #333; color: white; padding: 12px 16px; font-size: 13px; font-weight: 600; text-align: center; flex-shrink: 0; }
        .split-selection.has-selection { background: #22c55e; }
        .split-right video { flex: 1; width: 100%; object-fit: contain; background: #000; min-height: 0; }
        .split-stabilizer { position: absolute; top: 50px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 8px; background: rgba(0,0,0,0.7); padding: 6px 14px; border-radius: 20px; z-index: 10; }
        .split-no-photo { color: #666; text-align: center; padding: 40px 20px; font-size: 14px; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; }
        .split-no-photo-icon { font-size: 48px; margin-bottom: 12px; opacity: 0.5; }
        .split-instruction { background: #0ea5e9; color: white; padding: 10px 16px; font-size: 12px; text-align: center; flex-shrink: 0; }
        
        
        
        .mode-btn small { display: block; }
        
        /* Defect Markers on Camera Preview */
        .defect-markers-layer { position: absolute; pointer-events: none; z-index: 5; inset: 0; }
        .defect-markers-layer.active { pointer-events: auto; cursor: crosshair; }
        .defect-markers-layer:not(.active) .defect-marker { display: none; } /* Hide markers when not in main mode */
        .defect-marker { position: absolute; width: 36px; height: 36px; border-radius: 50%; transform: translate(-50%, -50%); cursor: pointer; pointer-events: auto; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 700; color: white; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.5); transition: transform 0.15s ease; }
        .defect-marker:hover { transform: translate(-50%, -50%) scale(1.2); }
        .defect-marker.stain { background: #eab308; }
        .defect-marker.hole { background: #3b82f6; }
        .defect-marker.repair { background: #f97316; }
        .defect-marker-delete { position: absolute; top: -8px; right: -8px; width: 20px; height: 20px; background: #ef4444; border-radius: 50%; border: 2px solid white; font-size: 12px; display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.15s; }
        .defect-marker:hover .defect-marker-delete { opacity: 1; }
        
        /* Defect Type Popup */
        .defect-popup { position: fixed; z-index: 10000; background: white; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); padding: 12px; display: none; max-width: 280px; }
        .defect-popup.visible { display: block; }
        .defect-popup-title { font-size: 11px; font-weight: 700; color: #64748b; margin-bottom: 8px; text-align: center; }
        .defect-popup-btns { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
        .defect-popup-btn { padding: 10px 12px; border: none; border-radius: 8px; font-size: 12px; font-weight: 700; cursor: pointer; display: flex; flex-direction: column; align-items: center; gap: 4px; min-width: 75px; transition: transform 0.1s; }
        .defect-popup-btn:hover { transform: scale(1.05); }
        .defect-popup-btn:active { transform: scale(0.95); }
        .defect-popup-btn.stain { background: #fef9c3; color: #a16207; border: 2px solid #eab308; }
        .defect-popup-btn.hole { background: #dbeafe; color: #1d4ed8; border: 2px solid #3b82f6; }
        .defect-popup-btn.tear { background: #fce7f3; color: #be185d; border: 2px solid #ec4899; }
        .defect-popup-btn.fade { background: #f3e8ff; color: #7c3aed; border: 2px solid #a855f7; }
        .defect-popup-btn.repair { background: #ffedd5; color: #c2410c; border: 2px solid #f97316; }
        .defect-popup-btn.other { background: #f1f5f9; color: #475569; border: 2px solid #64748b; }
        .defect-popup-btn span:first-child { font-size: 20px; }
        .defect-popup-cancel { width: 100%; margin-top: 8px; padding: 8px; background: #f1f5f9; border: 1px solid #cbd5e1; border-radius: 6px; font-size: 11px; color: #64748b; cursor: pointer; }
        .defect-popup-cancel:hover { background: #e2e8f0; }
        
        /* Defect Mode Indicator */
        .defect-mode-banner { position: absolute; bottom: 130px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.85); color: white; padding: 10px 20px; border-radius: 20px; font-size: 12px; font-weight: 600; z-index: 10; display: none; }
        .defect-mode-banner.visible { display: flex; align-items: center; gap: 8px; }
        .defect-mode-banner .marker-count { background: #3b82f6; padding: 2px 8px; border-radius: 10px; }
        
        /* Defect Side Selector Panel */
        .defect-side-panel { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); color: white; padding: 10px 16px; border-radius: 12px; font-size: 12px; font-weight: 600; z-index: 11; display: none; align-items: center; gap: 12px; }
        .defect-side-panel.visible { display: flex; }
        .defect-side-btn { padding: 10px 16px; border: 2px solid #444; border-radius: 8px; background: #333; color: white; font-size: 13px; font-weight: 700; cursor: pointer; transition: all 0.15s; display: flex; align-items: center; gap: 8px; }
        .defect-side-btn:hover { background: #444; border-color: #666; }
        .defect-side-btn:active { transform: scale(0.97); }
        .defect-side-btn kbd { background: rgba(255,255,255,0.2); padding: 2px 6px; border-radius: 4px; font-size: 11px; }
        #side-btn-front:hover, #side-btn-front.active { background: #0ea5e9; border-color: #0ea5e9; }
        #side-btn-back:hover, #side-btn-back.active { background: #8b5cf6; border-color: #8b5cf6; }
        
        /* Defect Close-up Link Panel & Feature Type Panel */
        .closeup-link-panel { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); background: rgba(220,38,38,0.95); color: white; padding: 10px 16px; border-radius: 12px; font-size: 11px; z-index: 10; display: none; flex-direction: column; gap: 8px; min-width: 280px; max-width: 400px; }
        .closeup-link-panel.visible { display: flex; }
        .closeup-link-panel .link-buttons { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; }
        .closeup-link-panel .link-btn { padding: 6px 12px; background: rgba(255,255,255,0.2); border: none; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.15s; }
        .closeup-link-panel .link-btn:hover { background: rgba(255,255,255,0.3); }
        .closeup-link-panel .link-btn.active { background: white; color: #dc2626; }
        .closeup-link-panel .link-btn-none { padding: 6px 12px; background: rgba(255,255,255,0.1); border: 1px dashed rgba(255,255,255,0.4); border-radius: 6px; color: rgba(255,255,255,0.7); font-size: 10px; cursor: pointer; margin-top: 4px; }
        .closeup-link-panel .link-btn-none:hover { background: rgba(255,255,255,0.2); }
        .feature-type-btn { padding: 6px 10px; background: rgba(255,255,255,0.2); border: none; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.15s; }
        .feature-type-btn:hover { background: rgba(255,255,255,0.3); }
        .feature-type-btn.active { background: white; color: #7c3aed; }
        
        /* Feature Type Panel - fixed positioning to avoid overflow:hidden issues */
        /* Feature Type Panel - fixed positioning to avoid overflow:hidden issues */
        .feature-type-panel { 
            position: fixed !important; 
            bottom: 120px !important; 
            left: 50% !important; 
            transform: translateX(-50%) !important; 
            background: rgba(124,58,237,0.98) !important; 
            color: white !important; 
            padding: 16px 24px !important; 
            border-radius: 16px !important; 
            font-size: 13px !important; 
            z-index: 999999 !important; 
            display: none; 
            flex-direction: column !important; 
            gap: 12px !important; 
            min-width: 360px !important; 
            max-width: 500px !important; 
            box-shadow: 0 10px 40px rgba(0,0,0,0.6) !important; 
            border: 3px solid rgba(255,255,255,0.5) !important;
        }
        .feature-type-panel.visible { display: flex !important; }
        .feature-type-buttons { display: flex; flex-wrap: wrap; gap: 6px; justify-content: center; }
        .feature-type-clear { padding: 6px 12px; background: rgba(255,255,255,0.1); border: 1px dashed rgba(255,255,255,0.4); border-radius: 6px; color: rgba(255,255,255,0.8); font-size: 11px; cursor: pointer; margin-top: 4px; }
        .feature-type-clear:hover { background: rgba(255,255,255,0.2); }
        
        /* Photos panel */
        .photos-header { font-size: 13px; font-weight: 700; margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center; }
        .photo-count { background: var(--color-primary-light); color: var(--color-primary-dark); padding: 3px 10px; border-radius: 12px; font-size: 11px; font-weight: 700; }
        .photo-section { margin-bottom: 16px; }
        .photo-section-title { font-size: 10px; font-weight: 700; color: var(--color-text-muted); text-transform: uppercase; margin-bottom: 8px; display: flex; justify-content: space-between; }
        .photo-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 6px; }
        .photo-thumb { aspect-ratio: 3/4; border-radius: 6px; overflow: hidden; background: white; border: 2px solid var(--color-border); position: relative; cursor: pointer; transition: transform 0.1s, border-color 0.1s; }
        .photo-thumb.square { aspect-ratio: 1/1; } /* Square for tag/defect photos */
        .photo-thumb:hover { transform: scale(1.02); border-color: var(--color-primary); }
        .photo-thumb img { width: 100%; height: 100%; object-fit: cover; }
        .photo-thumb-delete { position: absolute; top: 2px; right: 2px; width: 18px; height: 18px; background: rgba(0,0,0,0.7); color: white; border: none; border-radius: 50%; cursor: pointer; font-size: 11px; display: flex; align-items: center; justify-content: center; opacity: 0; }
        .photo-thumb:hover .photo-thumb-delete { opacity: 1; }
        .photo-thumb-empty { display: flex; align-items: center; justify-content: center; color: var(--color-border); font-size: 18px; cursor: pointer; }
        .stats-section { margin-top: 16px; padding-top: 12px; border-top: 1px solid var(--color-border); }
        .stats-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; text-align: center; }
        .stat-value { font-size: 20px; font-weight: 800; }
        .stat-label { font-size: 9px; color: var(--color-text-muted); text-transform: uppercase; }
        
        .fullres-btn { background: var(--color-success); color: white; padding: 3px 8px; border-radius: 4px; font-size: 9px; font-weight: 700; border: none; cursor: pointer; transition: var(--transition-fast); }
        .fullres-btn:hover { background: var(--color-success-dark); }
        .fullres-btn:active { transform: scale(0.97); }
        
        /* Camera flip transform */
        .camera-flipped { transform: rotate(180deg) !important; }
        .camera-rotated-90 { transform: rotate(90deg) !important; }
        .camera-rotated-90.camera-flipped { transform: rotate(90deg) rotate(180deg) !important; }
        
        /* Centering Grid Overlay */
        .grid-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 5;
            display: none;
        }
        .grid-overlay.visible { display: block; }
        .grid-overlay::before,
        .grid-overlay::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.4);
        }
        /* Vertical center line */
        .grid-overlay::before {
            left: 50%;
            top: 0;
            bottom: 0;
            width: 1px;
            transform: translateX(-50%);
        }
        /* Horizontal center line */
        .grid-overlay::after {
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            transform: translateY(-50%);
        }
        /* Rule of thirds lines */
        .grid-thirds {
            position: absolute;
            inset: 0;
        }
        .grid-thirds::before {
            content: '';
            position: absolute;
            left: 33.33%;
            top: 0;
            bottom: 0;
            width: 1px;
            background: rgba(255,255,255,0.25);
            box-shadow: calc(33.33vw) 0 0 rgba(255,255,255,0.25);
        }
        .grid-thirds::after {
            content: '';
            position: absolute;
            top: 33.33%;
            left: 0;
            right: 0;
            height: 1px;
            background: rgba(255,255,255,0.25);
            box-shadow: 0 calc(33.33vh) 0 rgba(255,255,255,0.25);
        }
        .grid-line-v {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 1px;
            background: rgba(255,255,255,0.25);
        }
        .grid-line-h {
            position: absolute;
            left: 0;
            right: 0;
            height: 1px;
            background: rgba(255,255,255,0.25);
        }
        
        /* Locked SKU Badge in Header */
        .sku-locked { display: inline-flex; align-items: center; gap: 6px; background: var(--color-success); color: white; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 700; font-family: monospace; }
        .sku-locked .lock-icon { font-size: 10px; }
        
        .submit-btn { width: 100%; padding: 16px; background: var(--color-success); color: white; border: none; border-radius: var(--radius-lg); font-size: 15px; font-weight: 700; cursor: pointer; transition: var(--transition-fast); }
        .submit-btn:hover { background: var(--color-success-dark); }
        .submit-btn:active { transform: scale(0.98); }
        .submit-btn:disabled { background: var(--color-border); cursor: not-allowed; }
        
        .flash-overlay { position: fixed; inset: 0; background: white; z-index: 500; opacity: 0; pointer-events: none; }
        .flash-overlay.flash { opacity: 1; }
        .hidden { display: none !important; }
        .recording { animation: pulse-red 1s infinite; }
        @keyframes pulse-red { 0%,100%{opacity:1} 50%{opacity:0.7} }
        
        /* Photo Preview Modal */
        .preview-modal { position: fixed; inset: 0; z-index: 600; background: rgba(0,0,0,0.98); display: none; flex-direction: column; }
        .preview-modal.active { display: flex; }
        .preview-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 20px; background: #000; flex-shrink: 0; }
        .preview-title { color: white; font-size: 14px; font-weight: 700; }
        .preview-badge { background: var(--color-primary); color: white; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; }
        .preview-close { background: none; border: none; color: white; font-size: 28px; cursor: pointer; padding: 8px; }
        .preview-close:hover { color: #f87171; }
        .preview-body { flex: 1; display: flex; align-items: center; justify-content: center; padding: 0; position: relative; overflow: hidden; min-height: 0; }
        .preview-image { width: auto; height: 100%; max-width: 100vw; max-height: calc(100vh - 100px); object-fit: contain; }
        .preview-nav { position: absolute; top: 50%; transform: translateY(-50%); background: rgba(255,255,255,0.1); border: none; color: white; font-size: 32px; padding: 16px 12px; cursor: pointer; border-radius: 8px; z-index: 10; }
        .preview-nav:hover { background: rgba(255,255,255,0.2); }
        .preview-nav.prev { left: 20px; }
        .preview-nav.next { right: 20px; }
        .preview-nav:disabled { opacity: 0.3; cursor: not-allowed; }
        .preview-footer { display: flex; justify-content: center; gap: 12px; padding: 12px; background: #000; flex-shrink: 0; }
        .preview-btn { padding: 12px 24px; border-radius: var(--radius-md); font-size: 13px; font-weight: 600; cursor: pointer; border: none; transition: var(--transition-fast); }
        .preview-btn:active { transform: scale(0.97); }
        .preview-btn-delete { background: var(--color-error); color: white; }
        .preview-btn-delete:hover { background: var(--color-error-dark); }
        .preview-btn-close { background: var(--color-dark-border); color: white; }
        .preview-btn-close:hover { background: var(--color-text-muted); }
        .preview-counter { color: #9ca3af; font-size: 12px; position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); }
        
        /* Visual Defect Picker Modal */
        .defect-picker-modal { position: fixed; inset: 0; z-index: 700; background: rgba(0,0,0,0.95); display: none; flex-direction: column; }
        .defect-picker-modal.active { display: flex; }
        .defect-picker-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 20px; background: #dc2626; flex-shrink: 0; }
        .defect-picker-title { color: white; font-size: 14px; font-weight: 700; }
        .defect-picker-close { background: none; border: none; color: white; font-size: 28px; cursor: pointer; padding: 8px; }
        .defect-picker-close:hover { color: #fca5a5; }
        .defect-picker-body { flex: 1; display: flex; align-items: center; justify-content: center; padding: 20px; overflow: auto; }
        .defect-picker-photos { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; align-items: center; }
        .defect-picker-photo-container { position: relative; max-width: 600px; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
        .defect-picker-photo-container img { display: block; width: 100%; height: auto; }
        .defect-picker-photo-label { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: 600; }
        .defect-picker-dot { position: absolute; width: 44px; height: 44px; border-radius: 50%; cursor: pointer; transform: translate(-50%, -50%); display: flex; align-items: center; justify-content: center; font-size: 16px; font-weight: 700; color: white; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4); transition: transform 0.15s, box-shadow 0.15s; }
        .defect-picker-dot:hover { transform: translate(-50%, -50%) scale(1.15); box-shadow: 0 4px 16px rgba(0,0,0,0.6); }
        .defect-picker-dot.selected { transform: translate(-50%, -50%) scale(1.25); box-shadow: 0 0 0 4px white, 0 4px 16px rgba(0,0,0,0.6); }
        .defect-picker-dot-label { position: absolute; top: 100%; left: 50%; transform: translateX(-50%); margin-top: 4px; background: rgba(0,0,0,0.8); color: white; padding: 2px 8px; border-radius: 4px; font-size: 10px; white-space: nowrap; pointer-events: none; }
        .defect-picker-footer { display: flex; justify-content: center; align-items: center; gap: 16px; padding: 12px 20px; background: #111; flex-shrink: 0; }
        .defect-picker-selected { color: white; font-size: 14px; font-weight: 600; padding: 8px 16px; background: rgba(255,255,255,0.1); border-radius: 8px; min-width: 200px; text-align: center; }
        .defect-picker-selected.has-selection { background: #22c55e; }
        .defect-picker-btn-none { padding: 10px 20px; background: rgba(255,255,255,0.1); border: 1px dashed rgba(255,255,255,0.4); border-radius: 8px; color: rgba(255,255,255,0.7); font-size: 13px; cursor: pointer; }
        .defect-picker-btn-none:hover { background: rgba(255,255,255,0.2); }
        .defect-picker-btn-close { padding: 10px 24px; background: #dc2626; border: none; border-radius: 8px; color: white; font-size: 13px; font-weight: 600; cursor: pointer; }
        .defect-picker-btn-close:hover { background: #b91c1c; }
        .defect-picker-empty { color: rgba(255,255,255,0.5); font-size: 16px; text-align: center; padding: 40px; }
        
        /* Updated defect link panel - now a clickable preview */
        .defect-link-preview { position: absolute; bottom: 80px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.9); padding: 8px; border-radius: 12px; z-index: 10; display: none; cursor: pointer; transition: transform 0.15s; }
        .defect-link-preview.visible { display: block; }
        .defect-link-preview:hover { transform: translateX(-50%) scale(1.02); }
        .defect-link-preview-inner { display: flex; align-items: center; gap: 12px; }
        .defect-link-preview-thumb { width: 80px; height: 60px; border-radius: 6px; object-fit: cover; border: 2px solid #dc2626; }
        .defect-link-preview-info { color: white; }
        .defect-link-preview-title { font-size: 11px; font-weight: 700; color: #dc2626; margin-bottom: 4px; }
        .defect-link-preview-text { font-size: 12px; }
        .defect-link-preview-hint { font-size: 10px; color: rgba(255,255,255,0.6); margin-top: 2px; }

        /* SKU with scan button */
        .sku-row { display: flex; gap: 8px; }
        .sku-row input { flex: 1; }
        .scan-btn { background: var(--color-dark); color: white; border: none; padding: 10px 16px; border-radius: var(--radius-md); font-size: 18px; cursor: pointer; transition: var(--transition-fast); }
        .scan-btn:hover { background: var(--color-dark-lighter); }
        .scan-btn:active { transform: scale(0.97); }
        
        /* Review cards */
        .review-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 16px; }
        .review-card { border-radius: 10px; padding: 14px; cursor: pointer; transition: transform 0.1s; }
        .review-card:hover { transform: scale(0.98); }
        .review-card:active { transform: scale(0.96); }
        .card-green { border-left: 4px solid var(--color-success); background: #f0fdf4; }
        .card-yellow { border-left: 4px solid var(--color-warning); background: #fffbeb; }
        .review-card-header { display: flex; align-items: center; gap: 6px; margin-bottom: 6px; }
        .review-card-header .icon { font-size: 16px; }
        .review-card-header .title { font-size: 12px; font-weight: 700; color: var(--color-text); }
        .review-card-summary { font-size: 11px; color: var(--color-text-muted); line-height: 1.4; }
        .review-banner { background: var(--color-success); color: white; padding: 14px; border-radius: 10px; text-align: center; font-weight: 700; margin-bottom: 12px; }
        .flag-banner { background: #fef3c7; border: 2px solid #f59e0b; color: #92400e; padding: 12px; border-radius: 10px; text-align: center; font-weight: 700; margin-bottom: 12px; }
        .flag-unusual-btn { width:100%; padding:14px; background:linear-gradient(135deg, var(--color-warning-lighter), var(--color-warning-light)); border:2px dashed var(--color-warning); border-radius: var(--radius-lg); font-weight:700; color: var(--color-warning-text); cursor:pointer; margin-bottom:12px; text-align:center; transition: var(--transition-normal); }
        .flag-unusual-btn:hover { background:linear-gradient(135deg, var(--color-warning-light), #fde68a); }
        .flag-unusual-btn:active { transform: scale(0.98); }
        .flag-unusual-btn.flagged { background:linear-gradient(135deg,#fde68a,#fbbf24); border-style:solid; border-color: var(--color-warning-dark); }
        .elastic-section { background:#f0fdf4; border:1px solid #86efac; border-radius:10px; padding:12px; margin-top:10px; }
        
        /* Debug Panel */
        .debug-panel { position:fixed; bottom:10px; right:10px; width:320px; max-height:300px; background:rgba(0,0,0,0.9); color:#0f0; font-family:monospace; font-size:10px; border-radius:8px; z-index:99999; overflow:hidden; display:none; }
        .debug-panel.visible { display:block; }
        .debug-header { padding:8px 12px; background:#1a1a1a; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #333; }
        .debug-header span { font-weight:bold; color:#0f0; }
        .debug-close { background:none; border:none; color:#f00; cursor:pointer; font-size:14px; }
        .debug-content { padding:8px; max-height:240px; overflow-y:auto; }
        .debug-log { margin:2px 0; padding:2px 4px; border-radius:2px; word-break:break-all; }
        .debug-log.error { background:#330000; color:#ff6666; }
        .debug-log.warn { background:#332200; color:#ffaa00; }
        .debug-log.info { background:#002233; color:#66aaff; }
        .debug-log.success { background:#003300; color:#66ff66; }
        .debug-toggle { position:fixed; bottom:10px; right:10px; width:40px; height:40px; background:#1a1a1a; border:2px solid #0f0; border-radius:50%; color:#0f0; font-size:18px; cursor:pointer; z-index:99998; display:flex; align-items:center; justify-content:center; }
        .debug-toggle:hover { background:#0f0; color:#000; }
        
        /* Draft indicator */
        .draft-indicator { position:fixed; top:10px; left:50%; transform:translateX(-50%); background:#f59e0b; color:#000; padding:6px 16px; border-radius:20px; font-size:11px; font-weight:700; z-index:9999; display:none; }
        .draft-indicator.visible { display:block; }
    </style>
    <!-- QuaggaJS Barcode Scanner Library - works in all browsers -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/quagga/0.12.1/quagga.min.js"></script>
</head>
<body>
    <!-- Toast Notifications -->
    <div id="toast-container" class="toast-container"></div>
    
    <!-- Reference Modal (Visual Search) -->
    <div id="ref-modal-overlay" class="ref-modal-overlay" onclick="closeRefModal()">
        <div class="ref-modal" onclick="event.stopPropagation()">
            <div class="ref-modal-title" id="ref-modal-title">Fabric Name</div>
            <div class="ref-modal-desc" id="ref-modal-desc">Description</div>
            <a id="ref-modal-link" class="ref-modal-link" href="#" target="_blank">🔍 See Examples on Google</a>
            <button class="ref-modal-close" onclick="closeRefModal()">Close</button>
        </div>
    </div>
    
    <!-- Defect Type Popup -->
    <div id="defect-popup" class="defect-popup" onclick="event.stopPropagation()">
        <div class="defect-popup-title">WHAT TYPE OF DEFECT?</div>
        <div class="defect-popup-btns">
            <button class="defect-popup-btn stain" onclick="event.stopPropagation(); confirmDefectMarker('stain')">
                <span>💧</span>
                <span>Stain</span>
            </button>
            <button class="defect-popup-btn hole" onclick="event.stopPropagation(); confirmDefectMarker('hole')">
                <span>🕳️</span>
                <span>Hole</span>
            </button>
            <button class="defect-popup-btn tear" onclick="event.stopPropagation(); confirmDefectMarker('tear')">
                <span>📐</span>
                <span>Tear</span>
            </button>
            <button class="defect-popup-btn fade" onclick="event.stopPropagation(); confirmDefectMarker('fade')">
                <span>🌫️</span>
                <span>Fade</span>
            </button>
            <button class="defect-popup-btn repair" onclick="event.stopPropagation(); confirmDefectMarker('repair')">
                <span>🧵</span>
                <span>Repair</span>
            </button>
            <button class="defect-popup-btn other" onclick="event.stopPropagation(); confirmDefectMarker('other')">
                <span>❓</span>
                <span>Other</span>
            </button>
        </div>
        <button class="defect-popup-cancel" onclick="event.stopPropagation(); cancelDefectMarker()">Cancel</button>
    </div>
    
    <!-- PIN LOCK SCREEN -->
    <div id="pin-screen" class="pin-screen">
        <div class="pin-box">
            <div class="pin-title">VintageLister</div>
            <div class="pin-subtitle">Enter Warehouse PIN</div>
            <input type="tel" id="pin-input" class="pin-input" maxlength="4" placeholder="••••" inputmode="numeric" autocomplete="off">
            <div class="sub-label">Photographer</div>
            <select id="photographer-select" class="photographer-select">
                <option value="P01">P01 – Jeff Koga</option>
                <option value="P02" selected>P02 – Elaine Donato</option>
                <option value="P03">P03 – Kobe Gaza</option>
            </select>
            <button onclick="checkPin()" class="pin-btn">START LISTING →</button>
        </div>
        <div class="pin-version" id="pin-version">v100.67 Desktop Station</div>
    </div>
    
    <!-- SKU GATE: Must scan SKU before starting -->
    <div class="flash-overlay" id="flash-overlay"></div>
    
    <!-- PHOTO PREVIEW MODAL -->
    <div class="preview-modal" id="preview-modal">
        <div class="preview-header">
            <span class="preview-title">Photo Preview</span>
            <span class="preview-badge" id="preview-type">MAIN</span>
            <button class="preview-close" onclick="closePreview()">×</button>
        </div>
        <div class="preview-body">
            <button class="preview-nav prev" id="preview-prev" onclick="navigatePreview(-1)">‹</button>
            <img id="preview-image" class="preview-image" src="" alt="Preview">
            <button class="preview-nav next" id="preview-next" onclick="navigatePreview(1)">›</button>
            <div class="preview-counter" id="preview-counter">1 / 1</div>
        </div>
        <div class="preview-footer">
            <button class="preview-btn preview-btn-delete" onclick="deleteFromPreview()">🗑️ Delete Photo</button>
            <button class="preview-btn preview-btn-close" onclick="closePreview()">Close</button>
        </div>
    </div>
    
    <!-- Visual Defect Picker Modal -->
    <div class="defect-picker-modal" id="defect-picker-modal">
        <div class="defect-picker-header">
            <span class="defect-picker-title">📍 Click on a defect to link your closeup photo</span>
            <button class="defect-picker-close" onclick="closeDefectPicker()">×</button>
        </div>
        <div class="defect-picker-body">
            <div class="defect-picker-photos" id="defect-picker-photos">
                <!-- Main photos with clickable defect dots will be rendered here -->
            </div>
        </div>
        <div class="defect-picker-footer">
            <div class="defect-picker-selected" id="defect-picker-selected">No defect selected</div>
            <button class="defect-picker-btn-none" onclick="clearDefectSelection()">Clear Selection</button>
            <button class="defect-picker-btn-close" onclick="closeDefectPicker()">Done</button>
        </div>
    </div>
    
    <div class="desktop-layout">
        <!-- LEFT: Form Panel -->
        <div class="form-panel">
            <div class="floating-timer">
                <div>
                    <div class="timer-label">CURRENT ITEM</div>
                    <div class="timer-main" id="timer-current">0:00</div>
                </div>
                <div class="timer-stats">
                    <div>Avg: <strong id="timer-avg">--</strong></div>
                    <div>Last: <strong id="timer-last">--</strong></div>
                </div>
                <div style="display:flex;align-items:center;gap:6px;margin-left:auto;">
                    <button id="folder-btn" class="folder-btn" onclick="selectSaveFolder()" title="Select folder to auto-save photos" style="white-space:nowrap;">📁 No Folder</button>
                </div>
                <div style="display:flex;align-items:center;gap:6px;">
                    <span id="photographer-badge" class="photographer-badge" onclick="showPinScreen()">P02</span>
                    <span class="version-badge" id="header-version">...</span>
                </div>
            </div>
            
            <div class="progress-bar">
                <div class="progress-dot active" id="dot-1" onclick="goToStep(1)"></div>
                <div class="progress-dot" id="dot-2" onclick="goToStep(2)"></div>
                <div class="progress-dot" id="dot-3" onclick="goToStep(3)"></div>
                <div class="progress-dot" id="dot-4" onclick="goToStep(4)"></div>
                <span class="progress-label" id="step-label">Step 1: Tag</span>
                <span class="category-badge" id="category-label"></span>
                <span class="sku-locked hidden" id="sku-locked-badge"><span class="lock-icon">🔒</span> <span id="sku-locked-value"></span></span>
            </div>
            
            <div class="step-area">
                <!-- STEP 1: TAG -->
                <div id="step-1" class="step-container active">
                    <!-- SKU Input - First thing in Step 1 -->
                    <div class="section-card" style="background:linear-gradient(135deg,#eff6ff,#dbeafe);border:2px solid var(--color-primary);">
                        <div class="section-label" style="color:var(--color-primary);"><span id="check-sku" class="check-circle">○</span> SKU</div>
                        <div style="display:flex;gap:8px;align-items:center;">
                            <input type="text" id="sku-input" placeholder="Scan or type SKU..." 
                                autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
                                oninput="onSkuInput()" onkeydown="if(event.key==='Enter'){event.preventDefault();onSkuInput();}"
                                style="flex:1;padding:12px 16px;font-size:18px;font-family:monospace;font-weight:700;text-align:center;border:2px solid var(--color-border);border-radius:10px;transition:var(--transition-fast);">
                            <button onclick="focusSkuInput()" style="padding:12px 16px;background:var(--color-dark);color:white;border:none;border-radius:10px;font-size:18px;cursor:pointer;" title="Focus for barcode scanner">🔍</button>
                        </div>
                        <div id="sku-status" style="margin-top:8px;font-size:12px;color:var(--color-text-muted);text-align:center;"></div>
                    </div>
                    
                    <div class="section-card">
                        <div class="section-label"><span id="check-category" class="check-circle">○</span> What is it?</div>
                        <div class="btn-grid btn-grid-3" style="margin-bottom:12px;">
                            <button onclick="setSuperCategory('tops', this)" class="btn btn-hero super-btn selected"><span class="emoji">👕</span>TOPS</button>
                            <button onclick="setSuperCategory('bottoms', this)" class="btn btn-secondary super-btn"><span class="emoji">👖</span>BOTTOMS</button>
                            <button onclick="setSuperCategory('outer', this)" class="btn btn-secondary super-btn"><span class="emoji">🧥</span>OUTER</button>
                        </div>
                        <div id="sub-categories"></div>
                    </div>
                    
                    <div class="section-card">
                        <div class="section-label"><span id="check-tag" class="check-circle">○</span> Tag Info</div>
                        <button onclick="setTagStatus('has', this)" class="btn btn-secondary tag-btn" style="width:100%;margin-bottom:8px;">✓ TAG READABLE</button>
                        <div class="btn-grid btn-grid-2">
                            <button onclick="setTagStatus('worn', this)" class="btn btn-secondary tag-btn">👀 Worn/Faded</button>
                            <button onclick="setTagStatus('none', this)" class="btn btn-secondary tag-btn">✂️ Missing/Cut</button>
                        </div>
                        
                        <!-- Tag Location Help -->
                        <button id="tag-help-btn" onclick="toggleTagLocationHelp()" class="help-btn" style="margin-top:8px;">🔍 Need help finding the tag?</button>
                        <div id="tag-location-panel" class="help-panel hidden" style="background:linear-gradient(135deg,#fef3c7,#fde68a);border-color:#f59e0b;">
                            <div id="tag-location-content"></div>
                        </div>
                        
                        <div id="tag-details" class="hidden nested-section">
                            <div class="sub-label">Tag Size (What Tag Reads)</div>
                            <div class="btn-grid" style="grid-template-columns: repeat(6, 1fr); margin-bottom:8px;">
                                <button onclick="setSize('XS', this)" class="btn btn-secondary size-btn">XS</button>
                                <button onclick="setSize('S', this)" class="btn btn-secondary size-btn">S</button>
                                <button onclick="setSize('M', this)" class="btn btn-secondary size-btn">M</button>
                                <button onclick="setSize('L', this)" class="btn btn-secondary size-btn">L</button>
                                <button onclick="setSize('XL', this)" class="btn btn-secondary size-btn">XL</button>
                                <button onclick="setSize('XXL', this)" class="btn btn-secondary size-btn">XXL</button>
                            </div>
                            <input type="text" id="tag-size-input" placeholder="Or Type (e.g. 42R, OS, 32x30)" onfocus="clearSizeBtns()" oninput="onSizeInput(this)" class="form-input text-sm text-center" style="margin-bottom:8px;">
                            <div class="sub-label">Origin</div>
                            <div class="btn-grid btn-grid-2" style="margin-bottom:8px;">
                                <button onclick="setOrigin('usa', this)" class="btn btn-secondary origin-btn"><img src="https://flagcdn.com/w20/us.png" width="20" height="15" alt="US" style="vertical-align:middle;margin-right:4px;">USA MADE</button>
                                <button onclick="setOrigin('import', this)" class="btn btn-secondary origin-btn">🌍 Import</button>
                            </div>
                            <div id="country-section" class="hidden">
                                <div class="btn-grid btn-grid-3" style="margin-bottom:6px;">
                                    <button onclick="setCountry('Mexico', this)" class="btn btn-secondary country-btn"><img src="https://flagcdn.com/w20/mx.png" width="20" height="15" alt="MX" style="vertical-align:middle;margin-right:4px;">Mexico</button>
                                    <button onclick="setCountry('Honduras', this)" class="btn btn-secondary country-btn"><img src="https://flagcdn.com/w20/hn.png" width="20" height="15" alt="HN" style="vertical-align:middle;margin-right:4px;">Honduras</button>
                                    <button onclick="setCountry('China', this)" class="btn btn-secondary country-btn"><img src="https://flagcdn.com/w20/cn.png" width="20" height="15" alt="CN" style="vertical-align:middle;margin-right:4px;">China</button>
                                </div>
                                <div class="btn-grid btn-grid-3" style="margin-bottom:6px;">
                                    <button onclick="setCountry('Korea', this)" class="btn btn-secondary country-btn"><img src="https://flagcdn.com/w20/kr.png" width="20" height="15" alt="KR" style="vertical-align:middle;margin-right:4px;">Korea</button>
                                    <button onclick="setCountry('Taiwan', this)" class="btn btn-secondary country-btn"><img src="https://flagcdn.com/w20/tw.png" width="20" height="15" alt="TW" style="vertical-align:middle;margin-right:4px;">Taiwan</button>
                                    <button onclick="setCountry('Philippines', this)" class="btn btn-secondary country-btn"><img src="https://flagcdn.com/w20/ph.png" width="20" height="15" alt="PH" style="vertical-align:middle;margin-right:4px;">Philippines</button>
                                </div>
                                <div class="btn-grid btn-grid-3" style="margin-bottom:6px;">
                                    <button onclick="setCountry('Vietnam', this)" class="btn btn-secondary country-btn"><img src="https://flagcdn.com/w20/vn.png" width="20" height="15" alt="VN" style="vertical-align:middle;margin-right:4px;">Vietnam</button>
                                    <button onclick="setCountry('Bangladesh', this)" class="btn btn-secondary country-btn"><img src="https://flagcdn.com/w20/bd.png" width="20" height="15" alt="BD" style="vertical-align:middle;margin-right:4px;">Bangladesh</button>
                                    <button onclick="setCountry('Other', this)" class="btn btn-secondary country-btn">Other...</button>
                                </div>
                                <input type="text" id="country-other-input" placeholder="Type country name..." class="form-input hidden" style="font-size:12px;" oninput="onCountryOtherInput()">
                            </div>
                            <div class="sub-label">Gender on Tag</div>
                            <div class="btn-grid btn-grid-4" style="margin-bottom:6px;">
                                <button onclick="setGender('Men', this)" class="btn btn-secondary gender-btn">Men's</button>
                                <button onclick="setGender('Women', this)" class="btn btn-secondary gender-btn">Women's</button>
                                <button onclick="setGender('Unisex', this)" class="btn btn-secondary gender-btn">Unisex</button>
                                <button onclick="setGender('None', this)" class="btn btn-secondary gender-btn">None</button>
                            </div>
                            <div class="btn-grid btn-grid-3">
                                <button onclick="setGender('Boys', this)" class="btn btn-secondary gender-btn">Boys</button>
                                <button onclick="setGender('Girls', this)" class="btn btn-secondary gender-btn">Girls</button>
                                <button onclick="setGender('Kids Unisex', this)" class="btn btn-secondary gender-btn">Kids Unisex</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="nav-buttons">
                        <button onclick="goToStep(2)" class="nav-btn nav-btn-next">Next: Check →</button>
                    </div>
                </div>
                
                <!-- STEP 2: CHECK -->
                <div id="step-2" class="step-container">
                    <div class="section-card">
                        <div class="section-label"><span id="check-color" class="check-circle">○</span> Color(s)</div>
                        <div class="sub-label" style="margin-bottom:8px;">Tap all that apply</div>
                        <div class="color-grid">
                            <div class="color-item" onclick="toggleColor('White', this)"><div class="color-swatch" style="background:#ffffff;border:1px solid #ddd;"></div><span>White</span></div>
                            <div class="color-item" onclick="toggleColor('Cream', this)"><div class="color-swatch" style="background:#fffdd0;border:1px solid #ddd;"></div><span>Cream</span></div>
                            <div class="color-item" onclick="toggleColor('Tan', this)"><div class="color-swatch" style="background:#d2b48c;"></div><span>Tan</span></div>
                            <div class="color-item" onclick="toggleColor('Gray', this)"><div class="color-swatch" style="background:#6b7280;"></div><span>Gray</span></div>
                            <div class="color-item" onclick="toggleColor('Black', this)"><div class="color-swatch" style="background:#1a1a1a;"></div><span>Black</span></div>
                            
                            <div class="color-item" onclick="toggleColor('Red', this)"><div class="color-swatch" style="background:#dc2626;"></div><span>Red</span></div>
                            <div class="color-item" onclick="toggleColor('Orange', this)"><div class="color-swatch" style="background:#ea580c;"></div><span>Orange</span></div>
                            <div class="color-item" onclick="toggleColor('Yellow', this)"><div class="color-swatch" style="background:#facc15;"></div><span>Yellow</span></div>
                            <div class="color-item" onclick="toggleColor('Green', this)"><div class="color-swatch" style="background:#16a34a;"></div><span>Green</span></div>
                            <div class="color-item" onclick="toggleColor('Blue', this)"><div class="color-swatch" style="background:#2563eb;"></div><span>Blue</span></div>
                            
                            <div class="color-item" onclick="toggleColor('Navy', this)"><div class="color-swatch" style="background:#1e3a5f;"></div><span>Navy</span></div>
                            <div class="color-item" onclick="toggleColor('Purple', this)"><div class="color-swatch" style="background:#7c3aed;"></div><span>Purple</span></div>
                            <div class="color-item" onclick="toggleColor('Pink', this)"><div class="color-swatch" style="background:#ec4899;"></div><span>Pink</span></div>
                            <div class="color-item" onclick="toggleColor('Brown', this)"><div class="color-swatch" style="background:#78350f;"></div><span>Brown</span></div>
                            <div class="color-item" onclick="toggleColor('Multi', this)"><div class="color-swatch" style="background:linear-gradient(135deg,#ef4444,#f97316,#facc15,#22c55e,#3b82f6,#8b5cf6);"></div><span>Multi</span></div>
                        </div>
                    </div>
                    
                    <!-- FADE -->
                    <div class="section-card">
                        <div class="section-label"><span id="check-fade" class="check-circle">○</span> Fade Level</div>
                        <div class="btn-grid btn-grid-3">
                            <button onclick="setFade('None', this)" class="btn btn-secondary fade-btn">None</button>
                            <button onclick="setFade('Light', this)" class="btn btn-secondary fade-btn">Light</button>
                            <button onclick="setFade('Heavy', this)" class="btn btn-secondary fade-btn">Heavy</button>
                        </div>
                    </div>
                    
                    <div class="section-card">
                        <div class="section-label"><span id="check-pattern" class="check-circle">○</span> Pattern</div>
                        <!-- Pattern cards grid (rendered dynamically) -->
                        <div id="pattern-cards-grid" class="cards-grid"></div>
                        
                        <!-- Other patterns toggle -->
                        <button onclick="toggleOtherPatterns()" id="other-patterns-toggle" class="sub-label" style="cursor:pointer; color:var(--color-primary);">+ More patterns</button>
                        <div id="pattern-others" class="hidden">
                            <div id="pattern-cards-others" class="cards-grid" style="margin-top:8px;"></div>
                        </div>
                        
                        <!-- Pattern Help Button -->
                        <button id="pattern-help-btn" onclick="togglePatternHelp()" class="help-btn" style="margin-top:8px;">🤔 Still not sure? Answer questions</button>
                        <div id="pattern-help-panel" class="help-panel hidden">
                            <div class="sub-label" style="color:#92400e;">Look at the lines:</div>
                            <div class="filter-row" style="margin-bottom:8px;">
                                <button onclick="togglePatternFilter('lines','none',this)" class="filter-btn pattern-filter">No lines</button>
                                <button onclick="togglePatternFilter('lines','stripes',this)" class="filter-btn pattern-filter">Stripes (parallel)</button>
                                <button onclick="togglePatternFilter('lines','grid',this)" class="filter-btn pattern-filter">Grid (crossing)</button>
                            </div>
                            <div class="sub-label" style="color:#92400e;">What shapes do you see?</div>
                            <div class="filter-row" style="margin-bottom:8px;">
                                <button onclick="togglePatternFilter('shapes','none',this)" class="filter-btn pattern-filter">None/Solid</button>
                                <button onclick="togglePatternFilter('shapes','dots',this)" class="filter-btn pattern-filter">Dots</button>
                                <button onclick="togglePatternFilter('shapes','curved',this)" class="filter-btn pattern-filter">Curved</button>
                                <button onclick="togglePatternFilter('shapes','geometric',this)" class="filter-btn pattern-filter">Geometric</button>
                                <button onclick="togglePatternFilter('shapes','blobs',this)" class="filter-btn pattern-filter">Irregular</button>
                            </div>
                            <div class="sub-label" style="color:#92400e;">How is it made?</div>
                            <div class="filter-row" style="margin-bottom:8px;">
                                <button onclick="togglePatternFilter('method','woven',this)" class="filter-btn pattern-filter">Part of fabric</button>
                                <button onclick="togglePatternFilter('method','printed',this)" class="filter-btn pattern-filter">Printed on top</button>
                                <button onclick="togglePatternFilter('method','stitched',this)" class="filter-btn pattern-filter">Stitched/Sewn on</button>
                            </div>
                            <div id="pattern-helper" class="help-text hidden"></div>
                        </div>
                        
                        <!-- Print Type (shows when Graphic selected) -->
                        <div id="print-type-section" class="hidden nested-section" style="margin-top:10px; background:rgba(99,102,241,0.1); border-color:rgba(99,102,241,0.3);">
                            <div class="sub-label" style="color:#4338ca; margin-top:0;">Print Type</div>
                            <div class="btn-grid" style="grid-template-columns: repeat(5, 1fr); gap:4px; margin-bottom:4px;">
                                <button onclick="setPrintType('Screen', this)" class="btn btn-secondary print-btn" style="padding:8px 4px; font-size:10px;">Screen</button>
                                <button onclick="setPrintType('Heat', this)" class="btn btn-secondary print-btn" style="padding:8px 4px; font-size:10px;">Heat</button>
                                <button onclick="setPrintType('Puff', this)" class="btn btn-secondary print-btn" style="padding:8px 4px; font-size:10px;">Puff</button>
                                <button onclick="setPrintType('DTG', this)" class="btn btn-secondary print-btn" style="padding:8px 4px; font-size:10px;">DTG</button>
                                <button onclick="setPrintType('AOP', this)" class="btn btn-secondary print-btn" style="padding:8px 4px; font-size:10px;">AOP</button>
                            </div>
                            <div class="btn-grid btn-grid-4" style="gap:4px;">
                                <button onclick="setPrintType('Patch', this)" class="btn btn-secondary print-btn" style="padding:8px 4px; font-size:10px;">Patch</button>
                                <button onclick="setPrintType('Painted', this)" class="btn btn-secondary print-btn" style="padding:8px 4px; font-size:10px;">Painted</button>
                                <button onclick="setPrintType('Emb', this)" class="btn btn-secondary print-btn" style="padding:8px 4px; font-size:10px;">Emb</button>
                                <button onclick="setPrintType('Other', this)" class="btn btn-secondary print-btn" style="padding:8px 4px; font-size:10px;">Other</button>
                            </div>
                        </div>
                        
                        <!-- Graphic Category (shows when Graphic selected) -->
                        <div id="graphic-category-section" class="hidden nested-section" style="margin-top:8px; background:rgba(99,102,241,0.05); border-color:rgba(99,102,241,0.2);">
                            <div class="sub-label" style="color:#4338ca; margin-top:0;">Graphic Category</div>
                            <div class="btn-grid btn-grid-4" style="gap:4px; margin-bottom:4px;">
                                <button onclick="setGraphicCategory('Band', this)" class="btn btn-secondary graphic-cat-btn" style="padding:8px 4px; font-size:10px;">🎸 Band</button>
                                <button onclick="setGraphicCategory('Movie/TV', this)" class="btn btn-secondary graphic-cat-btn" style="padding:8px 4px; font-size:10px;">🎬 Movie/TV</button>
                                <button onclick="setGraphicCategory('Sports', this)" class="btn btn-secondary graphic-cat-btn" style="padding:8px 4px; font-size:10px;">🏈 Sports</button>
                                <button onclick="setGraphicCategory('Brand', this)" class="btn btn-secondary graphic-cat-btn" style="padding:8px 4px; font-size:10px;">™️ Brand</button>
                            </div>
                            <div class="btn-grid btn-grid-4" style="gap:4px;">
                                <button onclick="setGraphicCategory('Art', this)" class="btn btn-secondary graphic-cat-btn" style="padding:8px 4px; font-size:10px;">🎨 Art</button>
                                <button onclick="setGraphicCategory('Tourist', this)" class="btn btn-secondary graphic-cat-btn" style="padding:8px 4px; font-size:10px;">🗺️ Tourist</button>
                                <button onclick="setGraphicCategory('Humor', this)" class="btn btn-secondary graphic-cat-btn" style="padding:8px 4px; font-size:10px;">😂 Humor</button>
                                <button onclick="setGraphicCategory('Other', this)" class="btn btn-secondary graphic-cat-btn" style="padding:8px 4px; font-size:10px;">Other</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="section-card">
                        <div class="section-label"><span id="check-fabric-type" class="check-circle">○</span> Fabric Type</div>
                        <div id="fabric-cards-grid" class="cards-grid"></div>
                        <!-- Other Fabric Types dropdown (eBay fabric types from PDF) -->
                        <select id="fabric-other-select" onchange="onFabricOtherChange()" class="form-select" style="margin-top:10px; font-size:13px; padding:10px 12px;">
                            <option value="" selected>Other fabric types...</option>
                            <option value="Wool">Wool (warm, textured)</option>
                            <option value="Canvas">Canvas (heavy cotton)</option>
                            <option value="Quilted">Quilted (puffy sections)</option>
                            <option value="Velvet">Velvet (plush, soft)</option>
                            <option value="Shearling">Shearling (wool/fur lined)</option>
                            <option value="Felt">Felt (pressed wool)</option>
                            <option value="Taffeta">Taffeta (crisp, shiny)</option>
                            <option value="Moleskin">Moleskin (soft brushed)</option>
                            <option value="Ponte">Ponte (stretchy dress)</option>
                            <option value="Lace">Lace (openwork)</option>
                            <option value="Georgette">Georgette (sheer crepe)</option>
                            <option value="Crepe">Crepe (textured, crinkly)</option>
                            <option value="Chiffon">Chiffon (sheer, flowy)</option>
                            <option value="Satin">Satin (shiny, smooth)</option>
                            <option value="Gauze">Gauze (lightweight, airy)</option>
                            <option value="Corduroy">Corduroy (vertical ridges)</option>
                            <option value="Softshell">Softshell (tech outdoor)</option>
                            <option value="Cannot Determine">Cannot Determine</option>
                            <option value="Custom">Custom (type below)...</option>
                        </select>
                        <input type="text" id="fabric-custom-input" placeholder="Type custom fabric type..." class="form-input hidden" style="margin-top:6px; font-size:12px;" oninput="onFabricCustomInput()">
                        <!-- Denim Wash (shows when denim selected) -->
                        <div id="wash-section" class="hidden nested-section" style="margin-top:10px;">
                            <div class="sub-label" style="color:#0369a1;">Denim Wash</div>
                            <div class="btn-grid btn-grid-4">
                                <button onclick="setWash('Light', this)" class="btn btn-secondary wash-btn">Light</button>
                                <button onclick="setWash('Medium', this)" class="btn btn-secondary wash-btn">Medium</button>
                                <button onclick="setWash('Dark', this)" class="btn btn-secondary wash-btn">Dark</button>
                                <button onclick="setWash('Raw', this)" class="btn btn-secondary wash-btn">Raw</button>
                                <button onclick="setWash('Acid', this)" class="btn btn-secondary wash-btn">Acid</button>
                                <button onclick="setWash('Stone', this)" class="btn btn-secondary wash-btn">Stone</button>
                                <button onclick="setWash('Rinse', this)" class="btn btn-secondary wash-btn">Rinse</button>
                                <button onclick="setWash('Black', this)" class="btn btn-secondary wash-btn">Black</button>
                            </div>
                        </div>
                        <button id="fabric-help-btn" onclick="toggleFabricHelp()" class="help-btn" style="margin-top:8px;">🤔 Not Sure?</button>
                        <div id="fabric-help-panel" class="help-panel hidden">
                            <div class="sub-label" style="color:#92400e;">How does it feel?</div>
                            <div class="filter-row">
                                <button onclick="toggleFabricFilter('stretch','none',this)" class="filter-btn fabric-filter">Rigid</button>
                                <button onclick="toggleFabricFilter('stretch','high',this)" class="filter-btn fabric-filter">Stretchy</button>
                            </div>
                            <div class="sub-label" style="color:#92400e;">Surface look/feel?</div>
                            <div class="filter-row">
                                <button onclick="toggleFabricFilter('surface','smooth',this)" class="filter-btn fabric-filter">Smooth</button>
                                <button onclick="toggleFabricFilter('surface','diagonal',this)" class="filter-btn fabric-filter">Diagonal lines</button>
                                <button onclick="toggleFabricFilter('surface','ridged',this)" class="filter-btn fabric-filter">Ridges</button>
                                <button onclick="toggleFabricFilter('surface','rough',this)" class="filter-btn fabric-filter">Rough/Textured</button>
                            </div>
                            <div class="sub-label" style="color:#92400e;">Inside texture?</div>
                            <div class="filter-row">
                                <button onclick="toggleFabricFilter('interior','smooth',this)" class="filter-btn fabric-filter">Smooth</button>
                                <button onclick="toggleFabricFilter('interior','fuzzy',this)" class="filter-btn fabric-filter">Fuzzy/Soft</button>
                                <button onclick="toggleFabricFilter('interior','loops',this)" class="filter-btn fabric-filter">Tiny Loops</button>
                            </div>
                            <div id="fabric-helper" class="help-text hidden"></div>
                        </div>
                        <!-- TAG CUT MODE: Expanded trait section (shows when tag missing/cut) -->
                        <div id="fabric-tag-cut-section" class="hidden" style="background:#fef2f2; border:2px solid #fca5a5; border-radius:10px; padding:12px; margin-top:10px;">
                            <div style="font-size:12px; font-weight:700; color:#b91c1c; margin-bottom:8px;">⚠️ NO TAG - Answer these questions (mandatory)</div>
                            <div class="sub-label" style="color:#991b1b;">How does it feel?</div>
                            <div class="filter-row" style="margin-bottom:8px;">
                                <button onclick="toggleFabricFilter('stretch','none',this)" class="filter-btn fabric-filter tagcut-btn">Rigid</button>
                                <button onclick="toggleFabricFilter('stretch','high',this)" class="filter-btn fabric-filter tagcut-btn">Stretchy</button>
                            </div>
                            <div class="sub-label" style="color:#991b1b;">Surface look/feel?</div>
                            <div class="filter-row" style="margin-bottom:8px;">
                                <button onclick="toggleFabricFilter('surface','smooth',this)" class="filter-btn fabric-filter tagcut-btn">Smooth</button>
                                <button onclick="toggleFabricFilter('surface','diagonal',this)" class="filter-btn fabric-filter tagcut-btn">Diagonal</button>
                                <button onclick="toggleFabricFilter('surface','ridged',this)" class="filter-btn fabric-filter tagcut-btn">Ridges</button>
                                <button onclick="toggleFabricFilter('surface','rough',this)" class="filter-btn fabric-filter tagcut-btn">Rough</button>
                            </div>
                            <div class="sub-label" style="color:#991b1b;">Inside texture?</div>
                            <div class="filter-row" style="margin-bottom:8px;">
                                <button onclick="toggleFabricFilter('interior','smooth',this)" class="filter-btn fabric-filter tagcut-btn">Smooth</button>
                                <button onclick="toggleFabricFilter('interior','fuzzy',this)" class="filter-btn fabric-filter tagcut-btn">Fuzzy</button>
                                <button onclick="toggleFabricFilter('interior','loops',this)" class="filter-btn fabric-filter tagcut-btn">Loops</button>
                            </div>
                            <div id="fabric-helper-tagcut" class="help-text"></div>
                        </div>
                    </div>
                    
                    <div class="section-card">
                        <div class="section-label"><span id="check-material" class="check-circle">○</span> Material <span style="font-weight:400;color:var(--color-text-muted);font-size:11px;">(select all that apply)</span></div>
                        <div id="material-tag-warning" class="tag-warning hidden">⚠️ No readable tag — use touch tests</div>
                        <div id="material-cards-grid" class="cards-grid"></div>
                        <!-- Other Materials dropdown -->
                        <select id="material-other-select" onchange="onMaterialOtherChange()" class="form-select" style="margin-top:10px; font-size:13px; padding:10px 12px;">
                            <option value="" selected>Other materials...</option>
                            <option value="Wool">Wool (warm, natural)</option>
                            <option value="Mohair">Mohair (fuzzy, luxe)</option>
                            <option value="Alpaca">Alpaca (soft, warm)</option>
                            <option value="Cashmere">Cashmere (luxury)</option>
                            <option value="Linen">Linen (breathable)</option>
                            <option value="Silk">Silk (shiny, luxe)</option>
                            <option value="Fur">Fur (real or faux)</option>
                            <option value="Canvas">Canvas (heavy cotton)</option>
                            <option value="Leather">Leather (real)</option>
                            <option value="Cannot Determine">Cannot Determine</option>
                            <option value="Custom">Custom (type below)...</option>
                        </select>
                        <input type="text" id="material-custom-input" placeholder="Type custom material..." class="form-input hidden" style="margin-top:6px; font-size:12px;" oninput="onMaterialCustomInput()">
                        <button id="material-help-btn" onclick="toggleMaterialHelp()" class="help-btn">🤔 Not Sure?</button>
                        <div id="material-help-panel" class="help-panel hidden">
                            <div class="sub-label" style="color:#92400e;">Temperature?</div>
                            <div class="filter-row">
                                <button onclick="toggleMaterialFilter('temp','cool',this)" class="filter-btn material-filter">Cool</button>
                                <button onclick="toggleMaterialFilter('temp','warm',this)" class="filter-btn material-filter">Warm</button>
                            </div>
                            <div class="sub-label" style="color:#92400e;">Shine?</div>
                            <div class="filter-row">
                                <button onclick="toggleMaterialFilter('shine','matte',this)" class="filter-btn material-filter">Matte</button>
                                <button onclick="toggleMaterialFilter('shine','sheen',this)" class="filter-btn material-filter">Sheen</button>
                            </div>
                            <div id="material-helper" class="help-text hidden"></div>
                        </div>
                        <!-- TAG CUT MODE: Expanded material trait section (shows when tag missing/cut) -->
                        <div id="material-tag-cut-section" class="hidden" style="background:#fef2f2; border:2px solid #fca5a5; border-radius:10px; padding:12px; margin-top:10px;">
                            <div style="font-size:12px; font-weight:700; color:#b91c1c; margin-bottom:8px;">⚠️ NO TAG - Answer these questions (mandatory)</div>
                            <div class="sub-label" style="color:#991b1b;">Touch it - Temperature?</div>
                            <div class="filter-row" style="margin-bottom:8px;">
                                <button onclick="toggleMaterialFilter('temp','cool',this)" class="filter-btn material-filter tagcut-btn">Cool (natural fibers)</button>
                                <button onclick="toggleMaterialFilter('temp','warm',this)" class="filter-btn material-filter tagcut-btn">Warm (synthetics)</button>
                            </div>
                            <div class="sub-label" style="color:#991b1b;">Look at it - Shine?</div>
                            <div class="filter-row" style="margin-bottom:8px;">
                                <button onclick="toggleMaterialFilter('shine','matte',this)" class="filter-btn material-filter tagcut-btn">Matte (no shine)</button>
                                <button onclick="toggleMaterialFilter('shine','sheen',this)" class="filter-btn material-filter tagcut-btn">Sheen (some shine)</button>
                            </div>
                            <div id="material-helper-tagcut" class="help-text"></div>
                        </div>
                    </div>
                    
                    <div class="section-card" id="construction-section">
                        <div class="section-label"><span id="check-construction" class="check-circle">○</span> Construction</div>
                        
                        <!-- TOPS/OUTER Construction: Sleeves -->
                        <div id="tops-construction">
                            <div class="sub-label">Sleeve Length</div>
                            <div class="btn-grid btn-grid-4" style="margin-bottom:10px;">
                                <button onclick="setSleeve('Short', this)" class="btn btn-secondary sleeve-btn">Short</button>
                                <button onclick="setSleeve('Long', this)" class="btn btn-secondary sleeve-btn">Long</button>
                                <button onclick="setSleeve('3/4', this)" class="btn btn-secondary sleeve-btn">3/4</button>
                                <button onclick="setSleeve('None', this)" class="btn btn-secondary sleeve-btn">None</button>
                            </div>
                            <div id="sleeve-style-section">
                                <div class="sub-label">Sleeve Style</div>
                                <div class="btn-grid btn-grid-3" style="margin-bottom:10px;">
                                    <button onclick="setSleeveStyle('Standard', this)" class="btn btn-secondary style-btn">Standard</button>
                                    <button onclick="setSleeveStyle('Raglan', this)" class="btn btn-secondary style-btn">Raglan</button>
                                    <button onclick="setSleeveStyle('Dolman', this)" class="btn btn-secondary style-btn">Dolman</button>
                                </div>
                                <!-- Raglan/Dolman Measurement Notice -->
                                <div id="sleeve-measurement-notice" class="hidden" style="background:#fef3c7; border:1px solid #f59e0b; border-radius:10px; padding:10px; margin-bottom:10px;">
                                    <div style="display:flex; align-items:flex-start; gap:8px;">
                                        <span style="font-size:18px;">📏</span>
                                        <div>
                                            <div style="font-size:11px; font-weight:700; color:#92400e;">Special Sleeve Measurement</div>
                                            <div style="font-size:10px; color:#b45309; margin-top:4px;">
                                                <strong>No shoulder seam exists!</strong><br>
                                                Measure: <strong>Center of neck → Cuff</strong><br>
                                                (Not shoulder to cuff)
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <!-- Cutoff Section (shows when Sleeve = None on T-Shirts) -->
                            <div id="cutoff-section" class="hidden nested-section nested-amber" style="margin-bottom:10px;">
                                <div class="sub-label" style="color:#92400e; margin-top:0;">🔪 Cut-off / Muscle Tee?</div>
                                <div class="btn-grid btn-grid-2" style="margin-bottom:8px;">
                                    <button onclick="setCutoff('diy', this)" class="btn btn-secondary cutoff-btn" style="display:flex; flex-direction:column; align-items:center; padding:12px 8px;">
                                        <span style="font-size:20px;">✂️</span>
                                        <span style="font-size:11px; font-weight:700;">DIY Cut-off</span>
                                        <span style="font-size:9px; color:#666;">Sleeves removed</span>
                                    </button>
                                    <button onclick="setCutoff('manufactured', this)" class="btn btn-secondary cutoff-btn" style="display:flex; flex-direction:column; align-items:center; padding:12px 8px;">
                                        <span style="font-size:20px;">🏭</span>
                                        <span style="font-size:11px; font-weight:700;">Manufactured</span>
                                        <span style="font-size:9px; color:#666;">Made sleeveless</span>
                                    </button>
                                </div>
                                <div style="font-size:10px; color:#92400e;">💡 This stays categorized as T-Shirt for searchability</div>
                            </div>
                            <div id="stitch-section">
                                <div class="sub-label">Stitch Type</div>
                                <div class="btn-grid btn-grid-2">
                                    <button onclick="setStitch('Single', this)" class="btn btn-secondary stitch-btn">Single Stitch</button>
                                    <button onclick="setStitch('Double', this)" class="btn btn-secondary stitch-btn">Double Stitch</button>
                                </div>
                            </div>
                            <div id="body-construction-section">
                                <div class="sub-label">Body Construction</div>
                                <div class="btn-grid btn-grid-2">
                                    <button onclick="setBodyConstruction('Tubular', this)" class="btn btn-secondary body-btn">🔵 Tubular</button>
                                    <button onclick="setBodyConstruction('Side Seam', this)" class="btn btn-secondary body-btn">Side Seam</button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- BOTTOMS Construction: Leg Style -->
                        <div id="bottoms-construction" class="hidden">
                            <div class="sub-label">Leg Style / Cut</div>
                            <div class="btn-grid btn-grid-4" style="margin-bottom:8px;">
                                <button onclick="setLegStyle('Straight', this)" class="btn btn-secondary leg-btn">Straight</button>
                                <button onclick="setLegStyle('Bootcut', this)" class="btn btn-secondary leg-btn">Bootcut</button>
                                <button onclick="setLegStyle('Relaxed', this)" class="btn btn-secondary leg-btn">Relaxed</button>
                                <button onclick="setLegStyle('Tapered', this)" class="btn btn-secondary leg-btn">Tapered</button>
                            </div>
                            <div class="btn-grid btn-grid-4" style="margin-bottom:8px;">
                                <button onclick="setLegStyle('Skinny', this)" class="btn btn-secondary leg-btn">Skinny</button>
                                <button onclick="setLegStyle('Wide Leg', this)" class="btn btn-secondary leg-btn">Wide Leg</button>
                                <button onclick="setLegStyle('Flare', this)" class="btn btn-secondary leg-btn">Flare</button>
                                <button onclick="setLegStyle('Baggy', this)" class="btn btn-secondary leg-btn">Baggy</button>
                            </div>
                            <div class="btn-grid btn-grid-3" style="margin-bottom:10px;">
                                <button onclick="setLegStyle('Capri', this)" class="btn btn-secondary leg-btn">Capri</button>
                                <button onclick="setLegStyle('Jogger', this)" class="btn btn-secondary leg-btn">Jogger</button>
                                <button onclick="setLegStyle('Cargo', this)" class="btn btn-secondary leg-btn">Cargo</button>
                            </div>
                            
                            <!-- Leg Style Help -->
                            <button id="leg-help-btn" onclick="toggleLegStyleHelp()" class="help-btn">🤔 Not sure? See examples</button>
                            <div id="leg-style-help" class="help-panel hidden" style="background:linear-gradient(135deg,#dbeafe,#bfdbfe);border-color:#3b82f6;">
                                <div style="font-weight:700;color:#1e40af;margin-bottom:8px;font-size:12px;">👖 Leg Style Guide</div>
                                <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;font-size:10px;">
                                    <div style="background:white;padding:6px;border-radius:6px;">
                                        <strong>Straight</strong><br>Same width hip to ankle
                                    </div>
                                    <div style="background:white;padding:6px;border-radius:6px;">
                                        <strong>Bootcut</strong><br>Slight flare below knee for boots
                                    </div>
                                    <div style="background:white;padding:6px;border-radius:6px;">
                                        <strong>Relaxed</strong><br>Loose through thigh, straight leg
                                    </div>
                                    <div style="background:white;padding:6px;border-radius:6px;">
                                        <strong>Tapered</strong><br>Wider at thigh, narrow at ankle
                                    </div>
                                    <div style="background:white;padding:6px;border-radius:6px;">
                                        <strong>Skinny</strong><br>Tight from hip to ankle
                                    </div>
                                    <div style="background:white;padding:6px;border-radius:6px;">
                                        <strong>Wide Leg</strong><br>Wide from hip to ankle
                                    </div>
                                    <div style="background:white;padding:6px;border-radius:6px;">
                                        <strong>Flare</strong><br>Dramatic flare from knee down (70s)
                                    </div>
                                    <div style="background:white;padding:6px;border-radius:6px;">
                                        <strong>Baggy</strong><br>Very loose/oversized throughout
                                    </div>
                                </div>
                                <div style="margin-top:8px;font-size:10px;color:#1e40af;">
                                    💡 <strong>Quick test:</strong> Lay flat, measure thigh width vs ankle opening. If ankle is smaller = tapered, same = straight, wider = bootcut/flare
                                </div>
                            </div>
                            
                            <!-- Rise (for jeans/pants) -->
                            <div class="sub-label" style="margin-top:10px;">Rise</div>
                            <div class="btn-grid btn-grid-3">
                                <button onclick="setRise('Low', this)" class="btn btn-secondary rise-btn">Low Rise</button>
                                <button onclick="setRise('Mid', this)" class="btn btn-secondary rise-btn">Mid Rise</button>
                                <button onclick="setRise('High', this)" class="btn btn-secondary rise-btn">High Rise</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="section-card">
                        <div class="section-label"><span id="check-feel" class="check-circle">○</span> Feel</div>
                        <div class="sub-label">Thickness</div>
                        <div class="btn-grid btn-grid-4" style="margin-bottom:10px;">
                            <button onclick="setThickness('Paper', this)" class="btn btn-secondary thickness-btn">Paper</button>
                            <button onclick="setThickness('Light', this)" class="btn btn-secondary thickness-btn">Light</button>
                            <button onclick="setThickness('Standard', this)" class="btn btn-secondary thickness-btn">Standard</button>
                            <button onclick="setThickness('Heavy', this)" class="btn btn-secondary thickness-btn">Heavy</button>
                        </div>
                        <div class="sub-label">Layers</div>
                        <div class="btn-grid btn-grid-3">
                            <button onclick="setLayers('Single', this)" class="btn btn-secondary layers-btn">Single</button>
                            <button onclick="setLayers('Reversible', this)" class="btn btn-secondary layers-btn">Reversible</button>
                            <button onclick="setLayers('Lined', this)" class="btn btn-secondary layers-btn">Lined</button>
                        </div>
                    </div>
                    
                    <div class="nav-buttons">
                        <button onclick="goToStep(1)" class="nav-btn nav-btn-back">← Back</button>
                        <button onclick="goToStep(3)" class="nav-btn nav-btn-next">Next: Snap →</button>
                    </div>
                </div>
                
                <!-- STEP 3: SNAP & SEND -->
                <div id="step-3" class="step-container">
                    <div class="section-card">
                        <div class="section-label"><span id="check-condition" class="check-circle">○</span> Any Issues?</div>
                        <button onclick="setClean(this)" id="btn-clean" class="btn btn-secondary" style="width:100%;margin-bottom:10px;padding:14px;">✓ No Defects</button>
                        <div class="sub-label">Or tap defect type:</div>
                        <div class="btn-grid btn-grid-3">
                            <button onclick="toggleDefect('Stain', this)" class="btn btn-secondary defect-type-btn defect-card"><span class="emoji">💧</span><span class="label">Stain</span></button>
                            <button onclick="toggleDefect('Hole', this)" class="btn btn-secondary defect-type-btn defect-card"><span class="emoji">🕳️</span><span class="label">Hole</span></button>
                            <button onclick="toggleDefect('Repair', this)" class="btn btn-secondary defect-type-btn defect-card"><span class="emoji">🧵</span><span class="label">Repair</span></button>
                        </div>
                    </div>
                    
                    <!-- ELASTIC CHECK (shows for Sweatpants) -->
                    <div id="elastic-section" class="section-card hidden">
                        <div class="section-label">🩲 Elastic Check</div>
                        <div class="btn-grid btn-grid-3">
                            <button onclick="setElastic('Solid', this)" class="btn btn-secondary elastic-btn" style="display:flex;flex-direction:column;align-items:center;padding:12px;">
                                <span style="font-size:18px;">🟢</span>
                                <span style="font-size:11px;font-weight:700;">SOLID</span>
                                <span style="font-size:9px;color:#666;">(springy)</span>
                            </button>
                            <button onclick="setElastic('Crunchy', this)" class="btn btn-secondary elastic-btn" style="display:flex;flex-direction:column;align-items:center;padding:12px;">
                                <span style="font-size:18px;">🟡</span>
                                <span style="font-size:11px;font-weight:700;">CRUNCHY</span>
                                <span style="font-size:9px;color:#666;">(worn)</span>
                            </button>
                            <button onclick="setElastic('None', this)" class="btn btn-secondary elastic-btn" style="display:flex;flex-direction:column;align-items:center;padding:12px;">
                                <span style="font-size:18px;">⬜</span>
                                <span style="font-size:11px;font-weight:700;">NO ELASTIC</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="section-card">
                        <div class="section-label"><span id="check-weight" class="check-circle">○</span> ⚖️ Weight</div>
                        <div class="btn-grid btn-grid-2">
                            <select id="weight-lb" onchange="updateWeight()" class="form-select" style="font-size:16px;font-weight:700;">
                                <option value="0" selected>0 lb</option>
                                <option value="1">1 lb</option>
                                <option value="2">2 lb</option>
                                <option value="3">3 lb</option>
                                <option value="4">4 lb</option>
                                <option value="5">5 lb</option>
                            </select>
                            <select id="weight-oz" onchange="updateWeight()" class="form-select" style="font-size:16px;font-weight:700;">
                                <option value="0" selected>0 oz</option>
                                <option value="1">1 oz</option>
                                <option value="2">2 oz</option>
                                <option value="3">3 oz</option>
                                <option value="4">4 oz</option>
                                <option value="5">5 oz</option>
                                <option value="6">6 oz</option>
                                <option value="7">7 oz</option>
                                <option value="8">8 oz</option>
                                <option value="9">9 oz</option>
                                <option value="10">10 oz</option>
                                <option value="11">11 oz</option>
                                <option value="12">12 oz</option>
                                <option value="13">13 oz</option>
                                <option value="14">14 oz</option>
                                <option value="15">15 oz</option>
                            </select>
                        </div>
                        <div style="margin-top:8px;font-size:11px;color:var(--color-text-muted);">⬆️ <strong>Always round up</strong></div>
                    </div>
                    
                    <!-- AUDIO MEASUREMENTS -->
                    <div class="section-card">
                        <div class="section-label"><span id="check-audio" class="check-circle">○</span> 🎤 Measurements</div>
                        <!-- Category-specific measurement hints -->
                        <div id="measure-hint-tops" class="nested-section" style="margin-bottom:10px;background:#eff6ff;border-color:#bfdbfe;">
                            <div style="font-size:11px;font-weight:700;color:#1e40af;margin-bottom:6px;">Say each + "inches":</div>
                            <div id="measure-tops-standard" style="font-size:10px;color:#3b82f6;line-height:1.6;">1. Neck to shoulder (center neck to seam)<br>2. Top sleeve (shoulder to cuff)<br>3. Sleeve opening (cuff width)<br>4. Bottom sleeve (pit to cuff)<br>5. Shoulder to shoulder<br>6. Pit to pit<br>7. Waist<br>8. Bottom hem<br>9. Length (collar to hem)</div>
                            <div id="measure-tops-raglan" class="hidden" style="font-size:10px;color:#3b82f6;line-height:1.6;">1. <strong style="color:#7c3aed;">Neck to cuff</strong> ⭐<br>2. Sleeve opening (cuff width)<br>3. Bottom sleeve (pit to cuff)<br>4. Pit to pit<br>5. Waist<br>6. Bottom hem<br>7. Length (collar to hem)</div>
                            <div id="measure-tops-sleeveless" class="hidden" style="font-size:10px;color:#3b82f6;line-height:1.6;">1. Neck to shoulder (center neck to seam)<br>2. Shoulder to shoulder<br>3. Pit to pit<br>4. Waist<br>5. Bottom hem<br>6. Length (collar to hem)</div>
                        </div>
                        <div id="measure-hint-button-shirt" class="nested-section hidden" style="margin-bottom:10px;background:#eff6ff;border-color:#bfdbfe;">
                            <div style="font-size:11px;font-weight:700;color:#1e40af;margin-bottom:6px;">Say each + "inches":</div>
                            <div id="measure-button-standard" style="font-size:10px;color:#3b82f6;line-height:1.6;">1. <strong>Neck circumference</strong> (button to button)<br>2. Neck to shoulder (center neck to seam)<br>3. Top sleeve (shoulder to cuff)<br>4. Sleeve opening (cuff width)<br>5. Bottom sleeve (pit to cuff)<br>6. Shoulder to shoulder<br>7. Pit to pit<br>8. Waist<br>9. Bottom hem<br>10. Length (collar to hem)</div>
                            <div id="measure-button-raglan" class="hidden" style="font-size:10px;color:#3b82f6;line-height:1.6;">1. <strong>Neck circumference</strong> (button to button)<br>2. <strong style="color:#7c3aed;">Neck to cuff</strong> ⭐<br>3. Sleeve opening (cuff width)<br>4. Bottom sleeve (pit to cuff)<br>5. Pit to pit<br>6. Waist<br>7. Bottom hem<br>8. Length (collar to hem)</div>
                            <div id="measure-button-sleeveless" class="hidden" style="font-size:10px;color:#3b82f6;line-height:1.6;">1. <strong>Neck circumference</strong> (button to button)<br>2. Neck to shoulder (center neck to seam)<br>3. Shoulder to shoulder<br>4. Pit to pit<br>5. Waist<br>6. Bottom hem<br>7. Length (collar to hem)</div>
                        </div>
                        <div id="measure-hint-bottoms" class="nested-section hidden" style="margin-bottom:10px;background:#eff6ff;border-color:#bfdbfe;">
                            <div style="font-size:11px;font-weight:700;color:#1e40af;margin-bottom:6px;">Say each + "inches":</div>
                            <div style="font-size:10px;color:#3b82f6;line-height:1.6;">1. Waist (flat across)<br>2. Rise (crotch to top)<br>3. Inseam (crotch to hem)<br>4. Thigh (at crotch)<br>5. Leg opening<br>6. Total length (waist to hem)</div>
                        </div>
                        <div id="measure-hint-outer" class="nested-section hidden" style="margin-bottom:10px;background:#eff6ff;border-color:#bfdbfe;">
                            <div style="font-size:11px;font-weight:700;color:#1e40af;margin-bottom:6px;">Say each + "inches":</div>
                            <div id="measure-outer-standard" style="font-size:10px;color:#3b82f6;line-height:1.6;">1. Neck to shoulder (center neck to seam)<br>2. Top sleeve (shoulder to cuff)<br>3. Sleeve opening (cuff width)<br>4. Bottom sleeve (pit to cuff)<br>5. Shoulder to shoulder<br>6. Pit to pit<br>7. Waist<br>8. Bottom hem<br>9. Length (collar to hem)</div>
                            <div id="measure-outer-raglan" class="hidden" style="font-size:10px;color:#3b82f6;line-height:1.6;">1. <strong style="color:#7c3aed;">Neck to cuff</strong> ⭐<br>2. Sleeve opening (cuff width)<br>3. Bottom sleeve (pit to cuff)<br>4. Pit to pit<br>5. Waist<br>6. Bottom hem<br>7. Length (collar to hem)</div>
                            <div id="measure-outer-sleeveless" class="hidden" style="font-size:10px;color:#3b82f6;line-height:1.6;">1. Neck to shoulder (center neck to seam)<br>2. Shoulder to shoulder<br>3. Pit to pit<br>4. Waist<br>5. Bottom hem<br>6. Length (collar to hem)</div>
                        </div>
                        <div id="record-section">
                            <button id="record-btn" onclick="toggleRecording()" class="btn btn-hero" style="width:100%;background:#ef4444;padding:16px;display:flex;flex-direction:column;align-items:center;gap:4px;">
                                <span style="font-size:24px;">🎤</span>
                                <span>TAP TO RECORD</span>
                            </button>
                            <!-- Live Voice Transcription Display -->
                            <div id="voice-transcript-section" class="hidden" style="margin-top:12px;">
                                <div style="background:#1e293b;border-radius:10px;padding:12px;margin-bottom:8px;">
                                    <div style="font-size:10px;color:#94a3b8;margin-bottom:6px;display:flex;justify-content:space-between;">
                                        <span>🎙️ LIVE TRANSCRIPT</span>
                                        <span id="voice-status" style="color:#22c55e;">●</span>
                                    </div>
                                    <div id="voice-transcript" style="font-size:13px;color:#e2e8f0;min-height:20px;font-style:italic;">Speak now...</div>
                                </div>
                                <div id="parsed-measurements" style="background:#eff6ff;border:1px solid #bfdbfe;border-radius:10px;padding:10px;">
                                    <div style="font-size:10px;color:#3b82f6;font-weight:700;margin-bottom:6px;">📏 PARSED MEASUREMENTS</div>
                                    <div id="parsed-list" style="font-size:12px;color:#1e40af;font-family:monospace;"></div>
                                </div>
                            </div>
                        </div>
                        <div id="post-record-section" class="hidden">
                            <div class="nested-section" style="background:#f0fdf4;border-color:#86efac;text-align:center;margin-bottom:8px;">
                                <div style="color:#16a34a;font-weight:700;font-size:14px;">✓ RECORDED</div>
                                <div style="color:#22c55e;font-family:monospace;font-size:18px;" id="recording-duration">0:00</div>
                            </div>
                            <button onclick="reRecord()" style="width:100%;padding:8px;background:none;border:none;color:var(--color-text-muted);font-size:12px;text-decoration:underline;cursor:pointer;">Re-record</button>
                        </div>
                    </div>
                    
                    <div class="section-card" style="padding:12px 16px;">
                        <div style="display:flex;align-items:center;justify-content:space-between;">
                            <span style="font-size:12px;font-weight:600;color:var(--color-text-muted);">SKU:</span>
                            <span id="sku-display-step3" style="font-family:monospace;font-size:16px;font-weight:700;color:var(--color-primary);">—</span>
                        </div>
                    </div>
                    
                    <!-- FLAG AS UNUSUAL -->
                    <button id="flag-btn" onclick="toggleFlagUnusual()" class="flag-unusual-btn">
                        <div style="display:flex;align-items:center;justify-content:center;gap:8px;font-size:16px;">
                            <span>🤔</span>
                            <span>FLAG AS UNUSUAL</span>
                        </div>
                        <div style="font-size:10px;font-weight:normal;margin-top:4px;opacity:0.8;">
                            Brand you don't recognize • Special construction • Gut feeling
                        </div>
                    </button>
                    
                    <div class="nav-buttons">
                        <button onclick="goToStep(2)" class="nav-btn nav-btn-back">← Back</button>
                        <button onclick="goToStep(4)" class="nav-btn nav-btn-next" style="flex:2;">Next: Review →</button>
                    </div>
                </div>
                
                <!-- STEP 4: REVIEW -->
                <div id="step-4" class="step-container">
                    <div class="review-banner">✨ Almost done! Quick review</div>
                    
                    <div class="review-grid">
                        <div id="card-tag" onclick="goToStep(1)" class="review-card card-yellow">
                            <div class="review-card-header">
                                <span class="icon" id="icon-tag">⚠️</span>
                                <span class="title">TAG</span>
                            </div>
                            <div class="review-card-summary" id="summary-tag">--</div>
                        </div>
                        <div id="card-check" onclick="goToStep(2)" class="review-card card-yellow">
                            <div class="review-card-header">
                                <span class="icon" id="icon-check">⚠️</span>
                                <span class="title">CHECK</span>
                            </div>
                            <div class="review-card-summary" id="summary-check">--</div>
                        </div>
                        <div id="card-snap" onclick="goToStep(3)" class="review-card card-yellow">
                            <div class="review-card-header">
                                <span class="icon" id="icon-snap">⚠️</span>
                                <span class="title">SNAP</span>
                            </div>
                            <div class="review-card-summary" id="summary-snap">--</div>
                        </div>
                        <div id="card-weight" onclick="goToStep(3)" class="review-card card-yellow">
                            <div class="review-card-header">
                                <span class="icon" id="icon-weight">⚠️</span>
                                <span class="title">WEIGHT</span>
                            </div>
                            <div class="review-card-summary" id="summary-weight">--</div>
                        </div>
                    </div>
                    
                    <div id="flag-status" class="flag-banner hidden">🚩 FLAGGED FOR REVIEW</div>
                    
                    <button id="submit-btn" class="submit-btn" onclick="submitItem()" disabled>SUBMIT ✓</button>
                    
                    <div class="nav-buttons" style="border-top:none;padding-top:8px;">
                        <button onclick="goToStep(3)" class="nav-btn nav-btn-back" style="flex:1;">← Back</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- CENTER: Camera -->
        <div class="camera-panel">
            <div class="camera-header">
                <select id="camera-select" class="camera-select" onchange="switchCamera(this.value)"><option value="">Select Camera...</option></select>
                <span id="camera-indicator" style="background:#3b82f6;color:white;padding:6px 12px;border-radius:6px;font-size:11px;font-weight:700;">📦 ARDUCAM 48MP</span>
                <span id="camera-resolution" style="color:#6b7280;font-size:10px;font-family:monospace;">--</span>
                <button class="fullres-btn" onclick="forceMaxResolution()" title="Click to force maximum resolution">FULL RES</button>
                <button class="fullres-btn" id="rotate-btn" onclick="toggleRotation()" style="background:#8b5cf6;" title="Rotate between landscape and portrait">🔄 LANDSCAPE</button>
                <div id="camera-status" class="camera-status">No camera</div>
            </div>
            <div class="camera-view">
                <!-- Normal single camera view -->
                <div class="camera-view-container" id="single-camera-view">
                    <div class="camera-placeholder" id="camera-placeholder">
                        <div class="camera-placeholder-icon">📷</div>
                        <div>Select a camera to begin</div>
                        <div style="font-size:11px;margin-top:6px;color:#555;">Arducam 48MP (8000×6000)</div>
                    </div>
                    
                    <!-- Single Camera View (default) -->
                    <video id="camera-video" autoplay playsinline style="display:none;"></video>
                    
                    <!-- Grid Overlay -->
                    <div class="grid-overlay" id="grid-overlay">
                        <div class="grid-line-v" style="left:33.33%"></div>
                        <div class="grid-line-v" style="left:66.66%"></div>
                        <div class="grid-line-h" style="top:33.33%"></div>
                        <div class="grid-line-h" style="top:66.66%"></div>
                    </div>
                    
                    <div class="camera-overlay" id="camera-overlay">
                        <!-- Stabilizer Indicator -->
                        <div class="stabilizer-indicator" id="stabilizer-indicator">
                            <div class="stabilizer-dot" id="stabilizer-dot"></div>
                            <span class="stabilizer-text" id="stabilizer-text">HOLD STEADY</span>
                        </div>
                    </div>
                    <!-- Defect Markers Layer (single camera mode) -->
                    <div class="defect-markers-layer" id="defect-markers-layer" onclick="handleDefectClick(event)"></div>
                    <!-- Defect Mode Banner -->
                    <div class="defect-mode-banner" id="defect-mode-banner">
                        <span>🎯 Click to mark defects</span>
                        <span class="marker-count" id="marker-count">0</span>
                    </div>
                    
                    <!-- Defect Side Selector (shows when defects are marked) -->
                    <div class="defect-side-panel" id="defect-side-panel">
                        <span style="font-size:11px;opacity:0.8;">Capture as:</span>
                        <button class="defect-side-btn" id="side-btn-front" onclick="captureDefectSide('front')">
                            👕 FRONT <kbd>F</kbd>
                        </button>
                        <button class="defect-side-btn" id="side-btn-back" onclick="captureDefectSide('back')">
                            👔 BACK <kbd>B</kbd>
                        </button>
                    </div>
                </div>
                
                <!-- Split-screen view for Defect Closeup mode -->
                <div class="split-defect-view" id="split-defect-view" style="display:none;">
                    <!-- Left: Main photo with clickable defect dots -->
                    <div class="split-left">
                        <div class="split-header">
                            <button class="split-tab active" id="split-tab-front" onclick="switchDefectSide('front')">
                                👕 FRONT <span class="split-tab-count" id="front-defect-count">0</span>
                            </button>
                            <button class="split-tab" id="split-tab-back" onclick="switchDefectSide('back')">
                                👔 BACK <span class="split-tab-count" id="back-defect-count">0</span>
                            </button>
                        </div>
                        <div class="split-photo-area">
                            <div class="split-photo-container" id="split-photo-container">
                                <!-- Photo with dots rendered here -->
                            </div>
                        </div>
                        <div class="split-selection" id="split-selection">Click a defect dot to link</div>
                    </div>
                    <!-- Right: C922X camera feed -->
                    <div class="split-right">
                        <div class="split-label">📹 C922X — Press SPACE to capture</div>
                        <video id="split-camera-video" autoplay playsinline></video>
                        <div class="split-stabilizer" id="split-stabilizer">
                            <div class="stabilizer-dot" id="split-stabilizer-dot"></div>
                            <span class="stabilizer-text" id="split-stabilizer-text">HOLD STEADY</span>
                        </div>
                    </div>
                </div>
            </div>
            <!-- Shot Sequence Hint -->
            <div id="shot-hint" style="background:linear-gradient(135deg,#1e40af,#3b82f6);color:white;padding:10px 16px;text-align:center;display:none;">
                <div style="font-weight:700;font-size:14px;">📸 Front Flat</div>
                <div style="font-size:11px;opacity:0.8;">Lay flat, arms folded down</div>
                <div style="font-size:10px;opacity:0.6;margin-top:4px;">Shot 1 of 4</div>
            </div>
            <div class="camera-footer">
                <button class="mode-btn active" id="mode-main" onclick="setPhotoMode('main')">📦 Main<br><small style="font-size:9px;opacity:0.7;">48MP</small></button>
                <div style="text-align:center;">
                    <button class="shutter-btn" id="shutter-btn" onclick="capturePhoto('shutterClick')"></button>
                    <div class="shutter-hint">Press <kbd>SPACE</kbd> or foot pedal</div>
                </div>
                <button class="mode-btn" id="mode-tag" onclick="setPhotoMode('tag')">🏷️ Tag<br><small style="font-size:9px;opacity:0.7;">C922X</small></button>
                <button class="mode-btn" id="mode-defect-closeup" onclick="setPhotoMode('defect-closeup')" style="background:#dc2626;border-color:#dc2626;">🔴 Defect<br><small style="font-size:9px;opacity:0.7;">C922X</small></button>
                <button class="mode-btn" id="mode-features" onclick="setPhotoMode('features'); setTimeout(()=>{const p=document.getElementById('feature-type-panel'); if(p){p.style.display='flex';console.log('✨ Panel forced visible')}}, 200);" style="background:#7c3aed;border-color:#7c3aed;">✨ Features<br><small style="font-size:9px;opacity:0.7;">C922X</small></button>
            </div>
        </div>
        
        <!-- RIGHT: Photos -->
        <div class="photos-panel">
            <div class="photos-header"><span>Photos</span><span class="photo-count" id="photo-count">0</span></div>
            <div style="font-size:9px;color:var(--color-text-muted);margin-bottom:12px;">Double-click to preview</div>
            <div class="photo-section">
                <div class="photo-section-title"><span>Main Photos</span><span id="main-count">0</span></div>
                <div class="photo-grid" id="main-photos-grid"><div class="photo-thumb photo-thumb-empty" onclick="setPhotoMode('main')">+</div></div>
            </div>
            <div class="photo-section">
                <div class="photo-section-title"><span>Tag Photos</span><span id="tag-count">0</span></div>
                <div class="photo-grid" id="tag-photos-grid"><div class="photo-thumb square photo-thumb-empty" onclick="setPhotoMode('tag')">+</div></div>
            </div>
            <div class="photo-section">
                <div class="photo-section-title"><span>Defects (Main)</span><span id="defect-count">0</span></div>
                <div class="photo-grid" id="defect-photos-grid"><div class="photo-thumb square photo-thumb-empty" onclick="setPhotoMode('main')" title="Defects marked on main photos">+</div></div>
            </div>
            <div class="photo-section">
                <div class="photo-section-title" style="color:#dc2626;"><span>🔴 Defect Close-ups</span><span id="defect-closeup-count" style="background:#dc2626;color:white;">0</span></div>
                <div class="photo-grid" id="defect-closeup-photos-grid"><div class="photo-thumb square photo-thumb-empty" onclick="setPhotoMode('defect-closeup')" title="Close-up photos of defects with C922X" style="border-color:#dc2626;">+</div></div>
            </div>
            <div class="photo-section">
                <div class="photo-section-title" style="color:#7c3aed;"><span>✨ Feature Close-ups</span><span id="features-count" style="background:#7c3aed;color:white;">0</span></div>
                <div class="photo-grid" id="features-photos-grid"><div class="photo-thumb square photo-thumb-empty" onclick="setPhotoMode('features')" title="Special features: zippers, buttons, codes, copyright" style="border-color:#7c3aed;">+</div></div>
            </div>
            <div class="stats-section">
                <div style="font-size:10px;color:var(--color-text-muted);font-weight:700;margin-bottom:8px;">Today's Stats</div>
                <div class="stats-grid" style="grid-template-columns: 1fr 1fr;">
                    <div><div class="stat-value" style="color:var(--color-primary)" id="stat-today">0</div><div class="stat-label">Today</div></div>
                    <div><div class="stat-value" id="stat-total">0</div><div class="stat-label">Total</div></div>
                </div>
            </div>
        </div>
    </div>
    <!-- Barcode Scanning Library -->
    <script src="https://unpkg.com/@zxing/library@latest"></script>
    <script>
        // ============ VERSION - UPDATE THIS ONE PLACE ONLY ============
        const VERSION = "v100.67";
        // ===============================================================
        
        // ============ DEBUG LOGGING SYSTEM ============
        const DEBUG_MAX_LOGS = 100;
        let debugLogs = [];
        
        function debugLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = { time: timestamp, msg: message, type };
            debugLogs.push(logEntry);
            if(debugLogs.length > DEBUG_MAX_LOGS) debugLogs.shift();
            
            // Update panel if visible
            const content = document.getElementById('debug-content');
            if(content) {
                const div = document.createElement('div');
                div.className = `debug-log ${type}`;
                div.textContent = `[${timestamp}] ${message}`;
                content.appendChild(div);
                content.scrollTop = content.scrollHeight;
                
                // Keep only last N entries in DOM
                while(content.children.length > DEBUG_MAX_LOGS) {
                    content.removeChild(content.firstChild);
                }
            }
            
            // Also log to console
            const consoleFn = type === 'error' ? console.error : type === 'warn' ? console.warn : console.log;
            consoleFn(`[VL ${type.toUpperCase()}] ${message}`);
        }
        
        function toggleDebugPanel() {
            const panel = document.getElementById('debug-panel');
            if(panel) panel.classList.toggle('visible');
        }
        
        // ============ DRAFT SAVING SYSTEM ============
        const DRAFT_KEY = 'vl_draft_v2';
        let draftSaveTimeout = null;
        
        function saveDraft() {
            // Debounce - only save after 500ms of no changes
            if(draftSaveTimeout) clearTimeout(draftSaveTimeout);
            draftSaveTimeout = setTimeout(() => {
                try {
                    // Save essential data (not photos - too large)
                    const draft = {
                        version: VERSION,
                        timestamp: Date.now(),
                        sku: data.sku,
                        superCategory: data.superCategory,
                        category: data.category,
                        tagStatus: data.tagStatus,
                        tagSize: data.tagSize,
                        origin: data.origin,
                        country: data.country,
                        gender: data.gender,
                        fabric: data.fabric,
                        material: data.material,
                        color: data.color,
                        pattern: data.pattern,
                        era: data.era,
                        condition: data.condition,
                        conditionIssues: data.conditionIssues,
                        defectTypes: data.defectTypes,
                        weightLb: data.weightLb,
                        weightOz: data.weightOz,
                        flagged: data.flagged,
                        elasticCheck: data.elasticCheck,
                        // Track photo counts (not the actual photos)
                        photoCount: {
                            main: data.mainPhotos?.length || 0,
                            tag: data.tagPhotos?.length || 0,
                            defect: data.defectPhotos?.length || 0,
                            features: data.featuresPhotos?.length || 0
                        }
                    };
                    localStorage.setItem(DRAFT_KEY, JSON.stringify(draft));
                    debugLog('Draft saved', 'success');
                } catch(e) {
                    debugLog(`Draft save failed: ${e.message}`, 'error');
                }
            }, 500);
        }
        
        function loadDraft() {
            try {
                const saved = localStorage.getItem(DRAFT_KEY);
                if(!saved) return false;
                
                const draft = JSON.parse(saved);
                
                // Only restore if less than 2 hours old
                const age = Date.now() - draft.timestamp;
                if(age > 2 * 60 * 60 * 1000) {
                    debugLog('Draft too old, discarding', 'warn');
                    localStorage.removeItem(DRAFT_KEY);
                    return false;
                }
                
                // Restore data
                if(draft.sku) {
                    data.sku = draft.sku;
                    const skuInput = document.getElementById('sku-input');
                    if(skuInput) skuInput.value = draft.sku;
                    onSkuInput();
                }
                if(draft.superCategory) data.superCategory = draft.superCategory;
                if(draft.category) data.category = draft.category;
                if(draft.tagStatus) data.tagStatus = draft.tagStatus;
                if(draft.tagSize) data.tagSize = draft.tagSize;
                if(draft.origin) data.origin = draft.origin;
                if(draft.country) data.country = draft.country;
                if(draft.gender) data.gender = draft.gender;
                if(draft.fabric) data.fabric = draft.fabric;
                if(draft.material) data.material = draft.material;
                if(draft.color) data.color = draft.color;
                if(draft.pattern) data.pattern = draft.pattern;
                if(draft.era) data.era = draft.era;
                if(draft.condition) data.condition = draft.condition;
                if(draft.conditionIssues) data.conditionIssues = draft.conditionIssues;
                if(draft.weightLb) data.weightLb = draft.weightLb;
                if(draft.weightOz) data.weightOz = draft.weightOz;
                if(draft.flagged) data.flagged = draft.flagged;
                
                debugLog(`Draft restored (${Math.round(age/60000)}min old)`, 'success');
                
                // Show indicator
                const indicator = document.getElementById('draft-indicator');
                if(indicator) {
                    indicator.classList.add('visible');
                    setTimeout(() => indicator.classList.remove('visible'), 5000);
                }
                
                return true;
            } catch(e) {
                debugLog(`Draft load failed: ${e.message}`, 'error');
                return false;
            }
        }
        
        function clearDraft() {
            try {
                localStorage.removeItem(DRAFT_KEY);
                debugLog('Draft cleared', 'info');
            } catch(e) {}
        }
        // ===============================================
        
        const APP_PIN = "1234"; // Local UI lock only - not a security feature
        const LAMBDA_URL = "https://qy9whwr6af.execute-api.us-east-2.amazonaws.com/default/vintagelister-presign";
        // All secrets (n8n URL, OpenAI key, S3 bucket) are now in Lambda environment variables
        
        // Shot sequence configuration per category
        // Categories that need inside-out shots (for insulation, lining, red lines, etc.)
        const CATEGORIES_WITH_INSIDE_SHOTS = ['Sweatshirt', 'Hoodie', 'Sweater', 'Cardigan', 'Jacket', 'Coat', 'Vest', 'Jeans', 'Pants'];
        
        // Shot sequence: SHORT SLEEVE tops (T-Shirt, Polo, Tank Top, Jersey)
        // No T-shape needed - sleeves are short, ghost mannequin doesn't need sleeve extension
        const SHOT_SEQUENCE_SHORT_SLEEVE = [
            { id: 'front_flat', label: 'Front Flat', hint: 'Lay flat, front facing up' },
            { id: 'back_flat', label: 'Back Flat', hint: 'Flip to back' }
        ];
        
        // Shot sequence: LONG SLEEVE tops (Long Sleeve T, Henley, Button Shirt without lining)
        // Need T-shape to show sleeve length for AI ghost mannequin
        const SHOT_SEQUENCE_LONG_SLEEVE = [
            { id: 'front_flat', label: 'Front Flat', hint: 'Lay flat, arms folded down' },
            { id: 'back_flat', label: 'Back Flat', hint: 'Flip to back, arms folded' },
            { id: 'front_tshape', label: 'T-Shape', hint: 'Open arms to T-shape (for AI ghost mannequin)' }
        ];
        
        // Shot sequence: OUTERWEAR (Jackets, Coats, Hoodies, Sweaters, etc.)
        // T-shape + inside shots (for insulation/lining)
        const SHOT_SEQUENCE_OUTERWEAR = [
            { id: 'front_flat', label: 'Front Flat', hint: 'Lay flat, arms folded down' },
            { id: 'back_flat', label: 'Back Flat', hint: 'Flip to back, arms folded' },
            { id: 'front_tshape', label: 'T-Shape', hint: 'Open arms to T-shape (for AI ghost mannequin)' },
            { id: 'inside_front', label: 'Inside Front', hint: 'Turn inside-out, front view (check lining/insulation)' },
            { id: 'inside_back', label: 'Inside Back', hint: 'Inside-out, back view' }
        ];
        
        // Shot sequence: BOTTOMS (Jeans, Pants, Shorts, Sweatpants) and VESTS
        // No T-shape (no sleeves), but need inside shots (for red lines, hems, pockets, lining)
        const SHOT_SEQUENCE_BOTTOMS = [
            { id: 'front_flat', label: 'Front Flat', hint: 'Lay flat, front facing up' },
            { id: 'back_flat', label: 'Back Flat', hint: 'Flip to back' },
            { id: 'inside_front', label: 'Inside Front', hint: 'Turn inside-out (check for red line, hems, lining)' },
            { id: 'inside_back', label: 'Inside Back', hint: 'Inside-out, back view' }
        ];
        
        // Legacy aliases for backward compatibility
        const SHOT_SEQUENCE_STANDARD = SHOT_SEQUENCE_SHORT_SLEEVE;
        const SHOT_SEQUENCE_WITH_INSIDE = SHOT_SEQUENCE_OUTERWEAR;
        
        // Current shot tracking
        let currentShotIndex = 0;
        let currentShotSequence = SHOT_SEQUENCE_STANDARD;
        let data = { superCategory:'tops', category:'', tagStatus:'', tagSize:'', origin:'', country:'', gender:'', colors:[], fade:'', pattern:'', patternTraits:{lines:'',shapes:'',method:''}, printType:'', graphicCategory:'', fabricType:'', fabricTraits:{stretch:'',surface:'',interior:''}, wash:'', materials:[], materialTraits:{temp:'',shine:''}, sleeveLength:'', sleeveStyle:'', cutoffType:'', stitch:'', bodyConstruction:'', legStyle:'', rise:'', thickness:'', layers:'', hasDefects:null, defectTypes:[], weightLb:0, weightOz:0, sku:'', photographer:'P02', audioMeasure:null, audioDuration:0, audioMimeType:'audio/webm', audioTranscript:'', parsedMeasurements:{}, mainPhotos:[], detailPhotos:[], tagPhotos:[], defectPhotos:[], defectCloseupPhotos:[], featuresPhotos:[], flagged:false, elasticCheck:'' };
        let stats = { today:0, total:0 }, currentStep = 1, photoMode = 'main', currentStream = null;
        let selectedDefectLink = null; // Index of defect marker to link close-up to
        let selectedFeatureType = null; // Type of feature being photographed
        let selectedDetailType = null; // Type of detail being photographed (graphic, collar, pocket, etc.)
        let fabricFilters = { stretch:null, surface:null, interior:null }, materialFilters = { temp:null, shine:null }, patternFilters = { lines:null, shapes:null, method:null };
        let tagCutMode = false; // When true, fabric selection disabled, traits mandatory
        
        // ============ METRICS TRACKING SYSTEM ============
        let metrics = null;
        let itemSequenceToday = 0; // Track items completed today
        
        function initMetrics() {
            const now = new Date();
            metrics = {
                // Timing
                itemStartTime: now.toISOString(),
                itemStartTimestamp: Date.now(),
                stepStartTime: Date.now(),
                modeStartTime: Date.now(),
                currentStep: 1,
                currentMode: 'main',
                
                timing: {
                    stepSeconds: { step1_tag: 0, step2_garment: 0, step3_weight: 0, step4_review: 0 },
                    modeSeconds: { main: 0, tag: 0, defect: 0, 'defect-closeup': 0, features: 0 }
                },
                
                // Audio tracking
                audio: {
                    attempts: [],
                    currentAttemptStart: null
                },
                
                // Photo tracking
                photos: {
                    captured: [],  // All photos taken (kept and deleted)
                    deleted: [],   // Deleted photo records
                    captureMethod: { footPedal: 0, spacebar: 0, shutterClick: 0 },
                    deletedByMethod: { footPedal: 0, spacebar: 0, shutterClick: 0 }
                },
                
                // Hardware tracking
                hardware: {
                    primaryCamera: mainCameraId ? {
                        id: mainCameraId,
                        name: mainCameraName || 'Primary Camera',
                        resolution: '4096x2160'
                    } : null,
                    secondaryCamera: secondaryCameraId ? {
                        id: secondaryCameraId,
                        name: secondaryCameraName || 'Secondary Camera',
                        resolution: '1920x1080'
                    } : null,
                    switches: [],
                    lastSwitchStart: null,
                    pendingSwitchFrom: null,
                    pendingSwitchTo: null
                },
                
                // Stabilizer tracking
                stabilizer: {
                    waitStartTime: null,
                    perPhoto: []  // Will store stability data per photo
                },
                
                // Default tracking
                defaults: {
                    tracked: {}  // Will store { field: { default: x, selected: y, matched: bool } }
                },
                
                // Workflow tracking
                workflow: {
                    softResets: 0,
                    reviewVisits: 0,
                    backtrackFromReview: [],
                    incompleteOnFirstReview: null,
                    stepTransitions: 0,
                    validationBlocks: 0,
                    blockedBy: []
                },
                
                // Interaction tracking
                interaction: {
                    totalClicks: 0,
                    clicksByArea: {
                        category: 0, tagSection: 0, colorPicker: 0, fabricType: 0,
                        material: 0, construction: 0, defects: 0, weight: 0,
                        photos: 0, navigation: 0, audio: 0, other: 0
                    },
                    corrections: { total: 0, bySection: {} },
                    helpButtonClicks: { materialHelp: 0, fabricHelp: 0 },
                    scrollEvents: { step1: 0, step2: 0, step3: 0, step4: 0 }
                },
                
                // Session info
                session: {
                    photographer: data.photographer,
                    date: now.toISOString().split('T')[0],
                    itemSequence: itemSequenceToday + 1,
                    hour: now.getHours(),
                    timeOfDay: now.getHours() < 12 ? 'morning' : (now.getHours() < 18 ? 'afternoon' : 'evening')
                }
            };
            
            console.log('📊 Metrics initialized for new item');
        }
        
        // Track step changes
        function trackStepChange(newStep) {
            if (!metrics) return;
            
            // Don't track if staying on same step (e.g., after reset)
            if (newStep === metrics.currentStep) {
                // Just update the start time for fresh tracking
                metrics.stepStartTime = Date.now();
                return;
            }
            
            const now = Date.now();
            const elapsed = Math.floor((now - metrics.stepStartTime) / 1000);
            const stepKey = `step${metrics.currentStep}_${['', 'tag', 'garment', 'weight', 'review'][metrics.currentStep]}`;
            
            if (metrics.timing.stepSeconds[stepKey] !== undefined) {
                metrics.timing.stepSeconds[stepKey] += elapsed;
            }
            
            metrics.stepStartTime = now;
            metrics.workflow.stepTransitions++;
            
            // Track review visits and bouncebacks
            if (newStep === 4) {
                metrics.workflow.reviewVisits++;
                if (metrics.workflow.reviewVisits === 1) {
                    // First time reaching review - capture what's incomplete
                    metrics.workflow.incompleteOnFirstReview = getIncompleteFields();
                }
            }
            
            // Track backtrack from review
            if (metrics.currentStep === 4 && newStep < 4) {
                metrics.workflow.backtrackFromReview.push({
                    toStep: newStep,
                    timestamp: new Date().toISOString()
                });
            }
            
            metrics.currentStep = newStep;
        }
        
        // Track mode changes
        function trackModeChange(newMode) {
            if (!metrics) return;
            
            // Don't track if staying on same mode (e.g., after reset)
            if (newMode === metrics.currentMode) {
                // Just update the start time for fresh tracking
                metrics.modeStartTime = Date.now();
                return;
            }
            
            const now = Date.now();
            const elapsed = Math.floor((now - metrics.modeStartTime) / 1000);
            
            if (metrics.timing.modeSeconds[metrics.currentMode] !== undefined) {
                metrics.timing.modeSeconds[metrics.currentMode] += elapsed;
            }
            
            metrics.modeStartTime = now;
            metrics.currentMode = newMode;
        }
        
        // Track camera switch
        function trackCameraSwitch(fromCamera, toCamera) {
            if (!metrics) return;
            
            // Cancel any existing switch tracking (shouldn't happen but be safe)
            if (metrics.hardware.lastSwitchStart) {
                console.log('📊 Warning: Previous camera switch not completed, discarding');
            }
            
            metrics.hardware.lastSwitchStart = Date.now();
            metrics.hardware.pendingSwitchFrom = fromCamera;
            metrics.hardware.pendingSwitchTo = toCamera;
        }
        
        function trackCameraSwitchComplete(fromCamera, toCamera) {
            if (!metrics || !metrics.hardware.lastSwitchStart) return;
            
            const switchTime = (Date.now() - metrics.hardware.lastSwitchStart) / 1000;
            
            // Only record if switch time is reasonable (< 30 seconds)
            if (switchTime < 30) {
                metrics.hardware.switches.push({
                    from: metrics.hardware.pendingSwitchFrom || fromCamera,
                    to: metrics.hardware.pendingSwitchTo || toCamera,
                    timeSeconds: Math.round(switchTime * 100) / 100
                });
            } else {
                console.log(`📊 Camera switch took too long (${switchTime}s), not recording`);
            }
            
            metrics.hardware.lastSwitchStart = null;
            metrics.hardware.pendingSwitchFrom = null;
            metrics.hardware.pendingSwitchTo = null;
        }
        
        // Track photo capture
        function trackPhotoCapture(mode, camera, method, stabilityScore, wasStable, waitSeconds) {
            if (!metrics) return;
            
            const photoRecord = {
                index: metrics.photos.captured.length + 1,
                mode: mode,
                camera: camera,
                method: method,
                stabilityScore: stabilityScore,
                wasStable: wasStable,
                waitSeconds: waitSeconds,
                timestamp: new Date().toISOString(),
                kept: true  // Will be updated if deleted
            };
            
            metrics.photos.captured.push(photoRecord);
            
            if (metrics.photos.captureMethod[method] !== undefined) {
                metrics.photos.captureMethod[method]++;
            }
            
            // Track stabilizer per photo
            metrics.stabilizer.perPhoto.push({
                index: photoRecord.index,
                mode: mode,
                camera: camera,
                score: stabilityScore,
                stable: wasStable,
                waitSeconds: waitSeconds
            });
        }
        
        // Track photo deletion
        function trackPhotoDeletion(mode, photoIndex) {
            if (!metrics) return;
            
            // Find all captured photos of this mode that are still kept
            const keptPhotosOfMode = metrics.photos.captured.filter(p => 
                p.mode === mode && p.kept === true
            );
            
            // Get the photo at the specified index (if it exists)
            // photoIndex corresponds to the position in the kept photos of that mode
            const capturedPhoto = keptPhotosOfMode[photoIndex];
            
            if (capturedPhoto) {
                capturedPhoto.kept = false;
                
                // Determine deletion reason based on timing
                const timeSinceCapture = (Date.now() - new Date(capturedPhoto.timestamp).getTime()) / 1000;
                let reason = 'cleanup';
                if (timeSinceCapture < 5) reason = 'immediate';
                else if (timeSinceCapture < 60) reason = 'delayed';
                if (currentStep === 4) reason = 'duringReview';
                
                metrics.photos.deleted.push({
                    originalIndex: capturedPhoto.index,
                    mode: mode,
                    method: capturedPhoto.method,
                    reason: reason,
                    timeSinceCapture: Math.round(timeSinceCapture)
                });
                
                if (metrics.photos.deletedByMethod[capturedPhoto.method] !== undefined) {
                    metrics.photos.deletedByMethod[capturedPhoto.method]++;
                }
            }
        }
        
        // Track audio recording attempt
        function trackAudioAttemptStart() {
            if (!metrics) return;
            metrics.audio.currentAttemptStart = Date.now();
        }
        
        function trackAudioAttemptEnd(outcome) {
            if (!metrics || !metrics.audio.currentAttemptStart) return;
            
            const duration = Math.floor((Date.now() - metrics.audio.currentAttemptStart) / 1000);
            let abandonedAt = null;
            
            if (outcome === 'abandoned') {
                if (duration < 15) abandonedAt = 'early';
                else if (duration < 45) abandonedAt = 'mid';
                else abandonedAt = 'late';
            }
            
            metrics.audio.attempts.push({
                attempt: metrics.audio.attempts.length + 1,
                durationSeconds: duration,
                outcome: outcome,
                abandonedAt: abandonedAt
            });
            
            metrics.audio.currentAttemptStart = null;
        }
        
        // Track clicks by area
        function trackClick(area) {
            if (!metrics) return;
            
            metrics.interaction.totalClicks++;
            
            if (metrics.interaction.clicksByArea[area] !== undefined) {
                metrics.interaction.clicksByArea[area]++;
            } else {
                metrics.interaction.clicksByArea.other++;
            }
        }
        
        // Track corrections (changed selection)
        function trackCorrection(section) {
            if (!metrics) return;
            
            metrics.interaction.corrections.total++;
            if (!metrics.interaction.corrections.bySection[section]) {
                metrics.interaction.corrections.bySection[section] = 0;
            }
            metrics.interaction.corrections.bySection[section]++;
        }
        
        // Track default usage
        function trackDefault(field, defaultValue, selectedValue) {
            if (!metrics) return;
            
            metrics.defaults.tracked[field] = {
                default: defaultValue,
                selected: selectedValue,
                matched: defaultValue === selectedValue
            };
        }
        
        // Track validation block
        function trackValidationBlock(missingFields) {
            if (!metrics) return;
            
            metrics.workflow.validationBlocks++;
            metrics.workflow.blockedBy = missingFields;
        }
        
        // Track soft reset
        function trackSoftReset() {
            if (!metrics) return;
            metrics.workflow.softResets++;
        }
        
        // Reset metrics tracking arrays for soft reset (keep workflow metadata)
        function resetMetricsForSoftReset() {
            if (!metrics) return;
            
            console.log('📊 Soft reset: resetting metrics tracking arrays');
            
            const now = Date.now();
            const softResetCount = metrics.workflow.softResets; // Preserve this
            
            // Reset timing
            metrics.itemStartTimestamp = now;
            metrics.itemStartTime = new Date().toISOString();
            metrics.stepStartTime = now;
            metrics.modeStartTime = now;
            metrics.currentStep = 1;
            metrics.currentMode = 'main';
            metrics.timing.stepSeconds = { step1_tag: 0, step2_garment: 0, step3_weight: 0, step4_review: 0 };
            metrics.timing.modeSeconds = { main: 0, tag: 0, defect: 0, 'defect-closeup': 0, features: 0 };
            
            // Reset audio
            metrics.audio.attempts = [];
            metrics.audio.currentAttemptStart = null;
            
            // Reset photos
            metrics.photos.captured = [];
            metrics.photos.deleted = [];
            metrics.photos.captureMethod = { footPedal: 0, spacebar: 0, shutterClick: 0 };
            metrics.photos.deletedByMethod = { footPedal: 0, spacebar: 0, shutterClick: 0 };
            
            // Reset stabilizer
            metrics.stabilizer.waitStartTime = now;
            metrics.stabilizer.perPhoto = [];
            
            // Reset workflow (except softResets)
            metrics.workflow.reviewVisits = 0;
            metrics.workflow.backtrackFromReview = [];
            metrics.workflow.incompleteOnFirstReview = null;
            metrics.workflow.stepTransitions = 0;
            metrics.workflow.validationBlocks = 0;
            metrics.workflow.blockedBy = [];
            metrics.workflow.softResets = softResetCount; // Restore preserved count
            
            // Reset interaction
            metrics.interaction.totalClicks = 0;
            metrics.interaction.clicksByArea = {
                category: 0, tagSection: 0, colorPicker: 0, fabricType: 0,
                material: 0, construction: 0, defects: 0, weight: 0,
                photos: 0, navigation: 0, audio: 0, other: 0
            };
            metrics.interaction.corrections = { total: 0, bySection: {} };
            metrics.interaction.helpButtonClicks = { materialHelp: 0, fabricHelp: 0 };
            metrics.interaction.scrollEvents = { step1: 0, step2: 0, step3: 0, step4: 0 };
            
            // Reset defaults tracking
            metrics.defaults.tracked = {};
            
            // Hardware stays the same (cameras don't change)
            // But reset switch tracking for new item
            metrics.hardware.switches = [];
            metrics.hardware.lastSwitchStart = null;
            metrics.hardware.pendingSwitchFrom = null;
            metrics.hardware.pendingSwitchTo = null;
        }
        
        // Track stabilizer wait start
        function trackStabilizerWaitStart() {
            if (!metrics) return;
            metrics.stabilizer.waitStartTime = Date.now();
        }
        
        // Get stabilizer wait time
        function getStabilizerWaitTime() {
            if (!metrics || !metrics.stabilizer.waitStartTime) return 0;
            return (Date.now() - metrics.stabilizer.waitStartTime) / 1000;
        }
        
        // Get incomplete fields for review tracking
        function getIncompleteFields() {
            const incomplete = [];
            if (!data.category) incomplete.push('category');
            if (!data.tagStatus) incomplete.push('tag');
            if (data.colors.length === 0) incomplete.push('color');
            if (!data.fade) incomplete.push('fade');
            if (!data.pattern) incomplete.push('pattern');
            if (!data.fabricType) incomplete.push('fabricType');
            if (data.materials.length === 0) incomplete.push('material');
            if (!data.thickness || !data.layers) incomplete.push('feel');
            if (data.hasDefects === null) incomplete.push('condition');
            if (data.weightLb === 0 && data.weightOz === 0) incomplete.push('weight');
            if (!data.audioMeasure) incomplete.push('audio');
            if (!data.sku) incomplete.push('sku');
            return incomplete;
        }
        
        // Build final metrics object for submission
        function buildMetricsPayload() {
            if (!metrics) return null;
            
            const now = Date.now();
            const totalSeconds = Math.floor((now - metrics.itemStartTimestamp) / 1000);
            
            // Finalize current step/mode timing
            trackStepChange(metrics.currentStep);
            trackModeChange(metrics.currentMode);
            
            // Calculate photo stats
            const totalCaptured = metrics.photos.captured.length;
            const totalKept = metrics.photos.captured.filter(p => p.kept).length;
            const totalDeleted = totalCaptured - totalKept;
            
            // Calculate deletion reasons
            const deletionsByReason = { accidental: 0, retake: 0, cleanup: 0, immediate: 0, delayed: 0, duringReview: 0 };
            metrics.photos.deleted.forEach(d => {
                if (d.reason === 'immediate' && d.timeSinceCapture < 2) {
                    deletionsByReason.accidental++;
                } else if (d.reason === 'immediate') {
                    deletionsByReason.retake++;
                } else {
                    deletionsByReason[d.reason] = (deletionsByReason[d.reason] || 0) + 1;
                }
            });
            
            // Calculate deletions by mode
            const deletionsByMode = { main: 0, tag: 0, defect: 0, 'defect-closeup': 0, features: 0 };
            metrics.photos.deleted.forEach(d => {
                if (deletionsByMode[d.mode] !== undefined) deletionsByMode[d.mode]++;
            });
            
            // Calculate stabilizer stats
            const stabilizerByMode = {};
            const stabilizerByCamera = {};
            let totalWaitSeconds = 0;
            let totalScore = 0;
            let stableCount = 0;
            let unstableCount = 0;
            
            metrics.stabilizer.perPhoto.forEach(p => {
                totalWaitSeconds += p.waitSeconds || 0;
                totalScore += p.score || 0;
                if (p.stable) stableCount++; else unstableCount++;
                
                // By mode
                if (!stabilizerByMode[p.mode]) {
                    stabilizerByMode[p.mode] = { waitSeconds: 0, photos: 0, totalScore: 0 };
                }
                stabilizerByMode[p.mode].waitSeconds += p.waitSeconds || 0;
                stabilizerByMode[p.mode].photos++;
                stabilizerByMode[p.mode].totalScore += p.score || 0;
                
                // By camera
                if (p.camera) {
                    if (!stabilizerByCamera[p.camera]) {
                        stabilizerByCamera[p.camera] = { waitSeconds: 0, photos: 0, totalScore: 0 };
                    }
                    stabilizerByCamera[p.camera].waitSeconds += p.waitSeconds || 0;
                    stabilizerByCamera[p.camera].photos++;
                    stabilizerByCamera[p.camera].totalScore += p.score || 0;
                }
            });
            
            // Format stabilizer by mode
            const formattedByMode = {};
            for (const mode in stabilizerByMode) {
                const m = stabilizerByMode[mode];
                formattedByMode[mode] = {
                    waitSeconds: Math.round(m.waitSeconds * 10) / 10,
                    photos: m.photos,
                    avgWait: m.photos > 0 ? Math.round((m.waitSeconds / m.photos) * 10) / 10 : 0,
                    avgScore: m.photos > 0 ? Math.round((m.totalScore / m.photos) * 10) / 10 : 0
                };
            }
            
            // Format stabilizer by camera
            const formattedByCamera = {};
            for (const cam in stabilizerByCamera) {
                const c = stabilizerByCamera[cam];
                formattedByCamera[cam] = {
                    waitSeconds: Math.round(c.waitSeconds * 10) / 10,
                    photos: c.photos,
                    avgWait: c.photos > 0 ? Math.round((c.waitSeconds / c.photos) * 10) / 10 : 0,
                    avgScore: c.photos > 0 ? Math.round((c.totalScore / c.photos) * 10) / 10 : 0
                };
            }
            
            // Calculate audio stats
            const audioAttempts = metrics.audio.attempts;
            const completedAttempt = audioAttempts.find(a => a.outcome === 'completed');
            const abandonedAttempts = audioAttempts.filter(a => a.outcome === 'abandoned');
            const discardedAttempts = audioAttempts.filter(a => a.outcome === 'discarded');
            const totalAudioTime = audioAttempts.reduce((sum, a) => sum + a.durationSeconds, 0);
            const wastedAudioTime = [...abandonedAttempts, ...discardedAttempts].reduce((sum, a) => sum + a.durationSeconds, 0);
            
            // Calculate default match rate
            const defaultsTracked = Object.keys(metrics.defaults.tracked);
            const defaultsMatched = defaultsTracked.filter(k => metrics.defaults.tracked[k].matched).length;
            const defaultMatchRate = defaultsTracked.length > 0 ? Math.round((defaultsMatched / defaultsTracked.length) * 100) / 100 : 1;
            const changedFromDefault = defaultsTracked.filter(k => !metrics.defaults.tracked[k].matched);
            
            // Calculate capture method stats
            const captureMethodStats = {};
            for (const method in metrics.photos.captureMethod) {
                const captures = metrics.photos.captureMethod[method];
                const deleted = metrics.photos.deletedByMethod[method] || 0;
                captureMethodStats[method] = {
                    captures: captures,
                    deleted: deleted,
                    wasteRate: captures > 0 ? Math.round((deleted / captures) * 100) / 100 : 0
                };
            }
            
            // Detect rapid fire (accidental captures)
            let rapidFireEvents = 0;
            let rapidFireDeleted = 0;
            for (let i = 1; i < metrics.photos.captured.length; i++) {
                const prev = new Date(metrics.photos.captured[i-1].timestamp).getTime();
                const curr = new Date(metrics.photos.captured[i].timestamp).getTime();
                if ((curr - prev) < 1000) {
                    rapidFireEvents++;
                    if (!metrics.photos.captured[i].kept) rapidFireDeleted++;
                }
            }
            
            // Get measurement count based on category
            let measurementCount = 9; // default standard
            let measurementType = 'standard';
            if (data.sleeveStyle === 'Raglan') {
                measurementCount = 7;
                measurementType = 'raglan';
            } else if (data.sleeveLength === 'Sleeveless' || data.sleeveLength === 'Tank') {
                measurementCount = 6;
                measurementType = 'sleeveless';
            } else if (data.superCategory === 'bottoms') {
                measurementCount = 6;
                measurementType = 'bottoms';
            }
            
            // Camera switch stats
            const switchCount = metrics.hardware.switches.length;
            const totalSwitchTime = metrics.hardware.switches.reduce((sum, s) => sum + s.timeSeconds, 0);
            
            // Build the final payload
            const payload = {
                timing: {
                    totalSeconds: totalSeconds,
                    targetSeconds: 300,
                    withinTarget: totalSeconds <= 300,
                    stepSeconds: metrics.timing.stepSeconds,
                    modeSeconds: metrics.timing.modeSeconds
                },
                
                audio: {
                    recorded: !!data.audioMeasure,
                    finalDurationSeconds: data.audioDuration || 0,
                    measurementCount: measurementCount,
                    measurementType: measurementType,
                    attempts: audioAttempts,
                    summary: {
                        totalAttempts: audioAttempts.length,
                        abandonedAttempts: abandonedAttempts.length,
                        discardedAttempts: discardedAttempts.length,
                        totalAudioTimeSeconds: totalAudioTime,
                        wastedTimeSeconds: wastedAudioTime,
                        firstAttemptSuccess: audioAttempts.length > 0 && (audioAttempts[0].outcome === 'completed' || audioAttempts[0].outcome === 'discarded')
                    },
                    efficiency: {
                        expectedDurationSeconds: measurementCount * 6,
                        actualDurationSeconds: data.audioDuration || 0,
                        secondsPerMeasurement: measurementCount > 0 && data.audioDuration ? Math.round((data.audioDuration / measurementCount) * 10) / 10 : 0
                    }
                },
                
                photos: {
                    counts: {
                        main: data.mainPhotos.length,
                        tag: data.tagPhotos.length,
                        defect: data.defectPhotos.length,
                        defectCloseup: data.defectCloseupPhotos.length,
                        features: data.featuresPhotos.length,
                        total: data.mainPhotos.length + data.tagPhotos.length + data.defectPhotos.length + data.defectCloseupPhotos.length + data.featuresPhotos.length
                    },
                    captures: {
                        totalCaptured: totalCaptured,
                        totalKept: totalKept,
                        deleted: totalDeleted,
                        wasteRate: totalCaptured > 0 ? Math.round((totalDeleted / totalCaptured) * 100) / 100 : 0
                    },
                    deletionsByMode: deletionsByMode,
                    deletionsByReason: deletionsByReason,
                    captureMethod: captureMethodStats,
                    issues: {
                        rapidFireEvents: rapidFireEvents,
                        rapidFireDeleted: rapidFireDeleted
                    },
                    retakes: {
                        total: deletionsByReason.retake,
                        byMode: deletionsByMode
                    }
                },
                
                hardware: {
                    cameras: {
                        primary: metrics.hardware.primaryCamera,
                        secondary: metrics.hardware.secondaryCamera
                    },
                    usage: formattedByCamera,
                    switches: {
                        count: switchCount,
                        totalTimeSeconds: Math.round(totalSwitchTime * 10) / 10,
                        avgSwitchTimeSeconds: switchCount > 0 ? Math.round((totalSwitchTime / switchCount) * 10) / 10 : 0
                    }
                },
                
                stabilizer: {
                    summary: {
                        totalWaitSeconds: Math.round(totalWaitSeconds * 10) / 10,
                        avgScoreAtCapture: metrics.stabilizer.perPhoto.length > 0 ? Math.round((totalScore / metrics.stabilizer.perPhoto.length) * 10) / 10 : 0,
                        capturedStable: stableCount,
                        capturedUnstable: unstableCount,
                        stabilityRate: (stableCount + unstableCount) > 0 ? Math.round((stableCount / (stableCount + unstableCount)) * 100) / 100 : 1
                    },
                    byMode: formattedByMode,
                    byCamera: formattedByCamera,
                    perPhoto: metrics.stabilizer.perPhoto,
                    issues: {
                        highScorePhotos: metrics.stabilizer.perPhoto.filter(p => p.score > 20).length,
                        longestWaitSeconds: metrics.stabilizer.perPhoto.length > 0 ? Math.max(...metrics.stabilizer.perPhoto.map(p => p.waitSeconds || 0)) : 0
                    }
                },
                
                defects: {
                    hasDefects: data.hasDefects,
                    types: data.defectTypes,
                    markerCount: data.mainPhotos.reduce((sum, p) => sum + (p.defects ? p.defects.length : 0), 0),
                    closeupCount: data.defectCloseupPhotos.length,
                    sides: [...new Set(data.mainPhotos.filter(p => p.defectSide).map(p => p.defectSide))]
                },
                
                complexity: {
                    materialCount: data.materials.length,
                    colorCount: data.colors.length,
                    hasPattern: !!data.pattern && data.pattern !== 'Solid',
                    constructionType: data.sleeveStyle === 'Raglan' ? 'raglan' : (data.sleeveLength === 'Sleeveless' ? 'sleeveless' : 'standard')
                },
                
                defaults: {
                    matchRate: defaultMatchRate,
                    changedFromDefault: changedFromDefault,
                    details: metrics.defaults.tracked
                },
                
                workflow: {
                    softResets: metrics.workflow.softResets,
                    reviewVisits: metrics.workflow.reviewVisits,
                    backtrackFromReview: metrics.workflow.backtrackFromReview.length,
                    incompleteOnFirstReview: metrics.workflow.incompleteOnFirstReview,
                    stepTransitions: metrics.workflow.stepTransitions,
                    firstPassYield: metrics.workflow.reviewVisits <= 1 && metrics.workflow.backtrackFromReview.length === 0,
                    validationBlocks: metrics.workflow.validationBlocks,
                    blockedBy: metrics.workflow.blockedBy
                },
                
                interaction: {
                    totalClicks: metrics.interaction.totalClicks,
                    clicksPerMinute: totalSeconds > 0 ? Math.round((metrics.interaction.totalClicks / (totalSeconds / 60)) * 10) / 10 : 0,
                    clicksByArea: metrics.interaction.clicksByArea,
                    corrections: metrics.interaction.corrections,
                    helpButtonClicks: metrics.interaction.helpButtonClicks,
                    scrollEvents: metrics.interaction.scrollEvents
                },
                
                session: {
                    photographer: data.photographer,
                    date: metrics.session.date,
                    itemSequence: metrics.session.itemSequence,
                    submittedAt: new Date().toISOString(),
                    hour: new Date().getHours(),
                    timeOfDay: new Date().getHours() < 12 ? 'morning' : (new Date().getHours() < 18 ? 'afternoon' : 'evening')
                },
                
                completeness: {
                    tagPhotosTaken: data.tagPhotos.length > 0,
                    featurePhotosTaken: data.featuresPhotos.length > 0,
                    defectsFullyDocumented: !data.hasDefects || (data.defectPhotos.length > 0 || data.defectCloseupPhotos.length > 0),
                    flaggedAsUnusual: data.flagged
                },
                
                meta: {
                    appVersion: VERSION
                }
            };
            
            return payload;
        }
        
        // Send abandoned item event
        async function sendAbandonedItemEvent(reason) {
            if (!metrics) return;
            
            const event = {
                event: 'item_abandoned',
                photographer: data.photographer,
                timestamp: new Date().toISOString(),
                sku: data.sku || 'unknown',
                secondsSpent: Math.floor((Date.now() - metrics.itemStartTimestamp) / 1000),
                lastStep: `step${currentStep}`,
                photosCount: data.mainPhotos.length + data.tagPhotos.length + data.defectPhotos.length,
                reason: reason,
                incompleteFields: getIncompleteFields()
            };
            
            console.log('📊 Abandoned item event:', event);
            
            // Send to n8n via Lambda proxy (fire and forget)
            try {
                fetch(LAMBDA_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'n8n',
                        formData: {
                            event: 'item_abandoned',
                            abandonedData: event
                        }
                    })
                }).catch(e => console.warn('Abandoned event send failed:', e));
            } catch(e) {
                console.warn('Could not send abandoned event:', e);
            }
        }
        
        // ============ LOCAL FOLDER SAVE (File System Access API) ============
        let saveDirectoryHandle = null;
        
        async function selectSaveFolder() {
            try {
                // Check if File System Access API is supported
                if(!('showDirectoryPicker' in window)) {
                    showToast('error', 'Not Supported', 'Use Chrome or Edge for folder saving');
                    return;
                }
                
                saveDirectoryHandle = await window.showDirectoryPicker({
                    mode: 'readwrite',
                    startIn: 'desktop'
                });
                
                // Update header button to show selected folder
                const btn = document.getElementById('folder-btn');
                btn.textContent = `📁 ${saveDirectoryHandle.name}`;
                btn.style.background = '#166534';
                btn.style.borderColor = '#22c55e';
                
                showToast('success', 'Folder Selected', `Photos will auto-save to "${saveDirectoryHandle.name}"`);
                console.log('📁 Save folder selected:', saveDirectoryHandle.name);
                
            } catch(err) {
                if(err.name !== 'AbortError') {
                    console.error('Folder selection error:', err);
                    showToast('error', 'Folder Error', err.message);
                }
            }
        }
        
        async function savePhotoToFolder(blob, filename) {
            if(!saveDirectoryHandle) return false;
            
            // Use requestIdleCallback to avoid blocking timer/UI
            return new Promise((resolve) => {
                const doSave = async () => {
                    try {
                        // Create SKU subfolder if SKU exists
                        let targetDir = saveDirectoryHandle;
                        if(data.sku) {
                            try {
                                targetDir = await saveDirectoryHandle.getDirectoryHandle(data.sku, { create: true });
                            } catch(e) {
                                console.warn('Could not create SKU folder, saving to root');
                            }
                        }
                        
                        // Create file
                        const fileHandle = await targetDir.getFileHandle(filename, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(blob);
                        await writable.close();
                        
                        console.log(`💾 Saved: ${data.sku ? data.sku + '/' : ''}${filename}`);
                        resolve(true);
                        
                    } catch(err) {
                        console.error('Save error:', err);
                        resolve(false);
                    }
                };
                
                // Schedule save during idle time to not block timer
                if('requestIdleCallback' in window) {
                    requestIdleCallback(() => doSave(), { timeout: 1000 });
                } else {
                    setTimeout(doSave, 0);
                }
            });
        }
        
        // ============ S3 UPLOAD FUNCTIONS ============
        
        // Get presigned URLs from Lambda
        async function getPresignedUrls(sku, files) {
            console.log('🔐 Getting presigned URLs for', files.length, 'files');
            console.log('🔐 Files:', JSON.stringify(files, null, 2));
            try {
                const response = await fetch(LAMBDA_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sku, files })
                });
                
                console.log('🔐 Lambda response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('🔐 Lambda error response:', errorText);
                    throw new Error(`Lambda error: ${response.status} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log('✅ Got presigned URLs:', Object.keys(result.urls || {}).length);
                console.log('✅ URL keys:', Object.keys(result.urls || {}));
                return result;
            } catch (err) {
                console.error('❌ Failed to get presigned URLs:', err);
                throw err;
            }
        }
        
        // Upload single file to S3 using presigned URL
        async function uploadToS3(presignedUrl, blob, filename) {
            console.log(`⬆️ Uploading ${filename} (${(blob.size/1024/1024).toFixed(2)}MB, type: ${blob.type})`);
            
            // Validate blob
            if (!blob || blob.size === 0) {
                console.error(`❌ Invalid blob for ${filename}: size=${blob?.size}, type=${blob?.type}`);
                throw new Error(`Invalid blob for ${filename}`);
            }
            
            try {
                const response = await fetch(presignedUrl, {
                    method: 'PUT',
                    body: blob,
                    headers: { 'Content-Type': blob.type || 'image/jpeg' }
                });
                
                console.log(`⬆️ S3 response for ${filename}: ${response.status}`);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`❌ S3 error for ${filename}:`, errorText);
                    throw new Error(`S3 upload error: ${response.status} - ${errorText}`);
                }
                
                console.log(`✅ Uploaded ${filename}`);
                return true;
            } catch (err) {
                console.error(`❌ Failed to upload ${filename}:`, err);
                throw err;
            }
        }
        
        // Build S3 file list from current data
        function buildS3FileList() {
            const sku = data.sku;
            const files = [];
            
            // Count already uploaded main photos
            const alreadyUploaded = data.mainPhotos.filter(p => p.s3Uploaded).length;
            const needsUpload = data.mainPhotos.filter(p => !p.s3Uploaded).length;
            
            console.log('📦 Building S3 file list for SKU:', sku);
            console.log('📦 Data state:', {
                mainPhotos: data.mainPhotos.length,
                mainPhotosAlreadyUploaded: alreadyUploaded,
                mainPhotosNeedUpload: needsUpload,
                tagPhotos: data.tagPhotos.length,
                defectPhotos: data.defectPhotos.length,
                defectCloseupPhotos: data.defectCloseupPhotos.length,
                featuresPhotos: data.featuresPhotos.length,
                hasAudio: !!data.audioMeasure
            });
            
            // Main photos - skip already uploaded, use fullResBlob if available
            data.mainPhotos.forEach((photo, i) => {
                // Skip if already uploaded to S3
                if (photo.s3Uploaded) {
                    console.log(`📦 Skipping main photo ${i+1} - already uploaded to S3`);
                    return;
                }
                
                const shotName = photo.shotId || `main_${String(i+1).padStart(2,'0')}`;
                // Use fullResBlob if available (not yet uploaded), otherwise compressed blob
                const blobToUpload = photo.fullResBlob || photo.blob;
                files.push({
                    name: `${sku}_${shotName}.jpg`,
                    folder: 'main',
                    blob: blobToUpload
                });
            });
            
            // Tag photos
            data.tagPhotos.forEach((photo, i) => {
                files.push({
                    name: `${sku}_tag_${String(i+1).padStart(2,'0')}.jpg`,
                    folder: 'tag',
                    blob: photo.blob
                });
            });
            
            // Defect closeup photos - include defect type
            data.defectCloseupPhotos.forEach((photo, i) => {
                const defectType = photo.linkedDefect?.type || 'unknown';
                files.push({
                    name: `${sku}_defect_closeup_${defectType}_${String(i+1).padStart(2,'0')}.jpg`,
                    folder: 'defects',
                    blob: photo.blob
                });
            });
            
            // Auto-cropped defect photos from main
            data.defectPhotos.forEach((photo, i) => {
                const defectType = photo.defectType || 'crop';
                files.push({
                    name: `${sku}_defect_${defectType}_crop_${String(i+1).padStart(2,'0')}.jpg`,
                    folder: 'defects',
                    blob: photo.blob
                });
            });
            
            // Feature photos - include feature type
            data.featuresPhotos.forEach((photo, i) => {
                const featureType = (photo.featureType || 'detail').toLowerCase().replace(/\s+/g, '-');
                files.push({
                    name: `${sku}_feature_${featureType}_${String(i+1).padStart(2,'0')}.jpg`,
                    folder: 'features',
                    blob: photo.blob
                });
            });
            
            // Audio file - use correct extension based on MIME type
            if (data.audioMeasure) {
                let audioExt = 'webm';
                if(data.audioMeasure.type) {
                    if(data.audioMeasure.type.includes('mp4') || data.audioMeasure.type.includes('m4a')) {
                        audioExt = 'mp4';
                    } else if(data.audioMeasure.type.includes('ogg')) {
                        audioExt = 'ogg';
                    } else if(data.audioMeasure.type.includes('wav')) {
                        audioExt = 'wav';
                    }
                }
                files.push({
                    name: `${sku}_measurements.${audioExt}`,
                    folder: 'audio',
                    blob: data.audioMeasure
                });
            }
            
            // JSON metadata file - COMPLETE data for n8n/backend
            const metadata = {
                // Version & Core identification
                version: VERSION,
                sku: sku,
                timestamp: new Date().toISOString(),
                photographer: data.photographer,
                flagged: data.flagged,
                
                // Category info
                superCategory: data.superCategory,
                category: data.category,
                gender: data.gender,
                
                // Tag info
                tagStatus: data.tagStatus,
                tagSize: data.tagSize,
                origin: data.origin,
                country: data.country,
                
                // Colors & pattern
                colors: data.colors,
                fade: data.fade,
                pattern: data.pattern,
                patternTraits: data.patternTraits,
                printType: data.printType,
                graphicCategory: data.graphicCategory,
                
                // Fabric & materials
                fabricType: data.fabricType,
                fabricTraits: data.fabricTraits,
                wash: data.wash,
                materials: data.materials,
                materialTraits: data.materialTraits,
                
                // Construction details
                sleeveLength: data.sleeveLength,
                sleeveStyle: data.sleeveStyle,
                cutoffType: data.cutoffType,
                stitch: data.stitch,
                bodyConstruction: data.bodyConstruction,
                legStyle: data.legStyle,
                rise: data.rise,
                thickness: data.thickness,
                layers: data.layers,
                elasticCheck: data.elasticCheck,
                
                // Condition & defects
                hasDefects: data.hasDefects,
                defectTypes: data.defectTypes,
                
                // Weight
                weightLb: data.weightLb,
                weightOz: data.weightOz,
                weightTotal: data.weightLb + (data.weightOz / 16), // Total in lbs
                
                // Measurements (audio)
                audioDuration: data.audioDuration,
                audioMimeType: data.audioMimeType,
                audioTranscript: data.audioTranscript || '',
                parsedMeasurements: data.parsedMeasurements || {},
                
                // Photo counts
                photoCount: {
                    main: data.mainPhotos.length,
                    tag: data.tagPhotos.length,
                    defect: data.defectPhotos.length,
                    defectCloseup: data.defectCloseupPhotos.length,
                    feature: data.featuresPhotos.length,
                    total: data.mainPhotos.length + data.tagPhotos.length + data.defectPhotos.length + 
                           data.defectCloseupPhotos.length + data.featuresPhotos.length
                },
                
                // Main photos with defect markers
                mainPhotos: data.mainPhotos.map((p, i) => ({
                    filename: `${sku}_${p.shotId || 'main_' + String(i+1).padStart(2,'0')}.jpg`,
                    shotId: p.shotId || `main_${String(i+1).padStart(2,'0')}`,
                    width: p.width,
                    height: p.height,
                    isPortrait: p.isPortrait || false,
                    defects: (p.defects || []).map(d => ({
                        type: d.type,
                        x: d.x,
                        y: d.y
                    })),
                    defectSide: p.defectSide || null
                })),
                
                // Tag photos
                tagPhotos: data.tagPhotos.map((p, i) => ({
                    filename: `${sku}_tag_${String(i+1).padStart(2,'0')}.jpg`,
                    width: p.width,
                    height: p.height
                })),
                
                // Auto-cropped defect photos
                defectPhotos: data.defectPhotos.map((p, i) => ({
                    filename: `${sku}_defect_${p.defectType || 'crop'}_crop_${String(i+1).padStart(2,'0')}.jpg`,
                    defectType: p.defectType || 'unknown',
                    sourcePhoto: p.sourcePhotoIndex,
                    cropRegion: p.cropRegion || null
                })),
                
                // Manual defect closeup photos
                defectCloseupPhotos: data.defectCloseupPhotos.map((p, i) => ({
                    filename: `${sku}_defect_closeup_${p.linkedDefect?.type || 'unknown'}_${String(i+1).padStart(2,'0')}.jpg`,
                    linkedDefect: p.linkedDefect ? {
                        type: p.linkedDefect.type,
                        photoIndex: p.linkedDefect.photoIndex,
                        defectIndex: p.linkedDefect.defectIndex
                    } : null,
                    width: p.width,
                    height: p.height
                })),
                
                // Feature photos
                featurePhotos: data.featuresPhotos.map((p, i) => ({
                    filename: `${sku}_feature_${(p.featureType || 'detail').toLowerCase().replace(/\s+/g, '-')}_${String(i+1).padStart(2,'0')}.jpg`,
                    featureType: p.featureType || 'detail',
                    width: p.width,
                    height: p.height
                }))
            };
            
            const jsonBlob = new Blob([JSON.stringify(metadata, null, 2)], { type: 'application/json' });
            files.push({
                name: `${sku}_metadata.json`,
                folder: 'metadata',
                blob: jsonBlob
            });
            
            return files;
        }
        
        // Upload all files to S3
        async function uploadAllToS3(progressCallback) {
            const sku = data.sku;
            
            console.log('📦 === STARTING S3 UPLOAD ===');
            
            let files;
            try {
                files = buildS3FileList();
            } catch(err) {
                console.error('❌ Error building file list:', err);
                return { success: false, error: 'Failed to build file list: ' + err.message };
            }
            
            console.log('📦 buildS3FileList returned', files.length, 'files');
            
            // Log each file with error handling
            for(let i = 0; i < files.length; i++) {
                const f = files[i];
                try {
                    console.log(`  ${i+1}. ${f.folder}/${f.name} - blob: ${f.blob ? f.blob.size + ' bytes' : 'MISSING!'}`);
                } catch(err) {
                    console.error(`  ${i+1}. ERROR logging file:`, err);
                }
            }
            
            if (files.length === 0) {
                console.log('⚠️ No files to upload');
                return { success: true, uploaded: 0 };
            }
            
            console.log(`📦 Uploading ${files.length} files to S3 for SKU ${sku}`);
            
            try {
                // Get presigned URLs for all files
                const fileList = files.map(f => ({ name: f.name, folder: f.folder }));
                console.log('📦 Requesting presigned URLs for', fileList.length, 'files...');
                
                let presignResult;
                try {
                    presignResult = await getPresignedUrls(sku, fileList);
                    console.log('📦 Presign result:', presignResult);
                } catch(presignErr) {
                    console.error('❌ Presign request failed:', presignErr);
                    throw presignErr;
                }
                
                const { urls } = presignResult;
                
                if (!urls || Object.keys(urls).length === 0) {
                    console.error('❌ No presigned URLs returned from Lambda');
                    throw new Error('No presigned URLs returned');
                }
                
                // Upload each file
                let uploaded = 0;
                let failed = 0;
                
                for (const file of files) {
                    // Try multiple key formats since Lambda might return different formats
                    const possibleKeys = [
                        file.name,                                    // Just filename: SKU_main_01.jpg
                        `${sku}/${file.folder}/${file.name}`,        // Full path: SKU/main/SKU_main_01.jpg
                        `${file.folder}/${file.name}`,               // Folder/name: main/SKU_main_01.jpg
                    ];
                    
                    let presignedUrl = null;
                    let matchedKey = null;
                    for (const key of possibleKeys) {
                        if (urls[key]) {
                            presignedUrl = urls[key];
                            matchedKey = key;
                            break;
                        }
                    }
                    
                    if (!presignedUrl) {
                        console.error(`❌ No presigned URL for ${file.name}`);
                        console.error('❌ Tried keys:', possibleKeys);
                        console.error('❌ Available URL keys:', Object.keys(urls));
                        failed++;
                        continue;
                    }
                    
                    console.log(`📦 Matched key "${matchedKey}" for ${file.name}`);
                    
                    if (!file.blob) {
                        console.error(`❌ No blob for ${file.name}`);
                        failed++;
                        continue;
                    }
                    
                    try {
                        await uploadToS3(presignedUrl, file.blob, file.name);
                        uploaded++;
                        if (progressCallback) {
                            progressCallback(uploaded, files.length, file.name);
                        }
                    } catch (err) {
                        console.error(`❌ Failed to upload ${file.name}:`, err);
                        failed++;
                    }
                }
                
                console.log(`✅ S3 upload complete: ${uploaded}/${files.length} files (${failed} failed)`);
                
                return {
                    success: failed === 0,
                    uploaded,
                    failed,
                    total: files.length,
                    s3Prefix: `${sku}/`
                };
                
            } catch (err) {
                console.error('❌ S3 upload failed:', err);
                return { success: false, error: err.message };
            }
        }
        
        // Build S3 file manifest for n8n (just paths, no blobs)
        function buildS3FileManifest() {
            const sku = data.sku;
            
            // Determine audio extension
            let audioExt = 'webm';
            if(data.audioMeasure && data.audioMeasure.type) {
                if(data.audioMeasure.type.includes('mp4') || data.audioMeasure.type.includes('m4a')) {
                    audioExt = 'mp4';
                } else if(data.audioMeasure.type.includes('ogg')) {
                    audioExt = 'ogg';
                } else if(data.audioMeasure.type.includes('wav')) {
                    audioExt = 'wav';
                }
            }
            
            return {
                // bucket is set server-side in Lambda
                prefix: `${sku}/`,
                main: data.mainPhotos.map((p, i) => {
                    const shotName = p.shotId || `main_${String(i+1).padStart(2,'0')}`;
                    return `${sku}/main/${sku}_${shotName}.jpg`;
                }),
                tag: data.tagPhotos.map((_, i) => `${sku}/tag/${sku}_tag_${String(i+1).padStart(2,'0')}.jpg`),
                defects: [
                    ...data.defectCloseupPhotos.map((p, i) => {
                        const type = p.linkedDefect?.type || 'unknown';
                        return `${sku}/defects/${sku}_defect_closeup_${type}_${String(i+1).padStart(2,'0')}.jpg`;
                    }),
                    ...data.defectPhotos.map((p, i) => {
                        const type = p.defectType || 'crop';
                        return `${sku}/defects/${sku}_defect_${type}_crop_${String(i+1).padStart(2,'0')}.jpg`;
                    })
                ],
                features: data.featuresPhotos.map((p, i) => {
                    const type = (p.featureType || 'detail').toLowerCase().replace(/\s+/g, '-');
                    return `${sku}/features/${sku}_feature_${type}_${String(i+1).padStart(2,'0')}.jpg`;
                }),
                audio: data.audioMeasure ? `${sku}/audio/${sku}_measurements.${audioExt}` : null,
                metadata: `${sku}/metadata/${sku}_metadata.json`
            };
        }
        
        // ============ SHOT SEQUENCE FUNCTIONS ============
        
        // Get shot sequence based on category
        function getShotSequenceForCategory(category) {
            if (!category) return SHOT_SEQUENCE_SHORT_SLEEVE;
            
            // Bottoms: front/back + inside (no T-shape)
            if (['Jeans', 'Pants', 'Shorts', 'Sweatpants'].includes(category)) {
                return SHOT_SEQUENCE_BOTTOMS;
            }
            
            // Vest: no sleeves so no T-shape, but needs inside shots for lining
            if (category === 'Vest') {
                return SHOT_SEQUENCE_BOTTOMS; // Same structure: front, back, inside front, inside back
            }
            
            // Outerwear with sleeves AND lining: T-shape + inside shots
            // These categories have insulation, lining, or interior details worth capturing
            if (['Jacket', 'Coat', 'Hoodie', 'Sweatshirt', 'Sweater', 'Cardigan'].includes(category)) {
                return SHOT_SEQUENCE_OUTERWEAR;
            }
            
            // Button Shirt - typically long sleeve, needs T-shape but no inside shots
            if (category === 'Button Shirt') {
                return SHOT_SEQUENCE_LONG_SLEEVE;
            }
            
            // For other tops (T-Shirt, Polo, Henley, Jersey, Tank), check sleeve length
            // Long sleeves need T-shape for AI ghost mannequin
            // Short sleeves don't need T-shape
            const needsTShape = data.sleeveLength === 'Long' || data.sleeveLength === '3/4';
            
            if (needsTShape) {
                return SHOT_SEQUENCE_LONG_SLEEVE;
            }
            
            // Default: short sleeve (just front/back)
            return SHOT_SEQUENCE_SHORT_SLEEVE;
        }
        
        // Update shot sequence when category OR sleeve length changes
        function updateShotSequence() {
            const oldSequence = currentShotSequence;
            currentShotSequence = getShotSequenceForCategory(data.category);
            
            // Only reset index if sequence actually changed
            if (oldSequence !== currentShotSequence) {
                currentShotIndex = 0;
                console.log(`📸 Shot sequence changed to ${currentShotSequence.length} shots`);
            }
            
            updateShotHint();
        }
        
        // Get current shot ID
        function getCurrentShotId() {
            if (currentShotIndex < currentShotSequence.length) {
                return currentShotSequence[currentShotIndex].id;
            }
            // Beyond sequence - use numbered
            return `extra_${String(data.mainPhotos.length + 1).padStart(2, '0')}`;
        }
        
        // Advance to next shot in sequence
        function advanceShotSequence() {
            if (currentShotIndex < currentShotSequence.length) {
                currentShotIndex++;
            }
            updateShotHint();
        }
        
        // Update the shot hint display
        function updateShotHint() {
            const hintEl = document.getElementById('shot-hint');
            if (!hintEl) return;
            
            if (currentShotIndex < currentShotSequence.length) {
                const shot = currentShotSequence[currentShotIndex];
                hintEl.innerHTML = `
                    <div style="font-weight:700;font-size:14px;">📸 ${shot.label}</div>
                    <div style="font-size:11px;opacity:0.8;">${shot.hint}</div>
                    <div style="font-size:10px;opacity:0.6;margin-top:4px;">Shot ${currentShotIndex + 1} of ${currentShotSequence.length}</div>
                `;
                hintEl.style.display = 'block';
            } else {
                hintEl.innerHTML = `
                    <div style="font-weight:700;font-size:14px;">✅ Sequence Complete</div>
                    <div style="font-size:11px;opacity:0.8;">Additional shots: extra_${data.mainPhotos.length + 1}</div>
                `;
                hintEl.style.display = 'block';
            }
        }
        
        // Reset shot sequence (called on new item)
        function resetShotSequence() {
            currentShotSequence = SHOT_SEQUENCE_SHORT_SLEEVE;
            currentShotIndex = 0;
            updateShotHint();
        }
        
        function generatePhotoFilename(type, index) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const sku = data.sku || 'NOSKU';
            return `${sku}_${type}_${index}_${timestamp}.jpg`;
        }
        let timerStart = null, timerInterval = null, itemTimes = [];
        let mediaRecorder = null, audioChunks = [], recordingStart = null, recordingInterval = null;
        let mainCameraId = null, secondaryCameraId = null, activeCameraId = null;
        let mainCameraName = null, secondaryCameraName = null; // Store camera names for metrics
        
        // Camera configuration for flip/rotation (can be extended later if needed)
        let cameraConfig = { flips: {}, rots: {} };
        
        // Portrait mode - rotates capture 90° for vertical garments
        let mainPhotoPortrait = false;
        
        let barcodeScanInterval = null;
        // Stabilizer variables
        let stabilizerInterval = null, stabilizerCanvas = null, stabilizerCtx = null;
        let previousFrame = null, stableFrameCount = 0, isStable = false;
        let currentMotionDelta = 0; // Track current motion delta for metrics
        const STABILITY_THRESHOLD = 8; // Lower = more sensitive
        const FRAMES_NEEDED = 3; // Frames needed to be "stable"
        let previewMode = null, previewIndex = 0;
        
        // ============ DEFECT MARKER SYSTEM ============
        let defectMarkers = []; // [{id, x, y, type}]
        let pendingMarker = null; // Temporary marker waiting for type selection
        let defectMarkingEnabled = false;
        const DEFECT_CROP_SIZE = 0.50; // 50% of max dimension (~1920px from 3840 rotated)
        const DEFECT_COLORS = { stain: '#eab308', hole: '#3b82f6', tear: '#ec4899', fade: '#a855f7', repair: '#f97316', other: '#64748b' };
        const DEFECT_ICONS = { stain: '💧', hole: '🕳️', repair: '🧵' };
        
        
        // ============ TOAST NOTIFICATION SYSTEM ============
        function showToast(type, title, message, duration = 4000) {
            const container = document.getElementById('toast-container');
            const icons = { success: '✅', error: '❌', warning: '⚠️', info: 'ℹ️' };
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || 'ℹ️'}</span>
                <div class="toast-content">
                    <div class="toast-title">${title}</div>
                    ${message ? `<div class="toast-message">${message}</div>` : ''}
                </div>
                <button class="toast-close" onclick="this.parentElement.remove()">×</button>
            `;
            
            container.appendChild(toast);
            
            // Auto-remove after duration
            setTimeout(() => {
                toast.classList.add('hiding');
                setTimeout(() => toast.remove(), 300);
            }, duration);
            
            return toast;
        }
        
        // ============ DEFECT MARKER FUNCTIONS ============
        function handleDefectClick(event) {
            console.log('🎯 handleDefectClick triggered');
            
            if(!defectMarkingEnabled) {
                console.log('🎯 Marking disabled - ignoring click');
                return;
            }
            
            // Check if clicked on existing marker (to delete)
            if(event.target.closest('.defect-marker')) {
                console.log('🎯 Clicked on existing marker - ignoring');
                return;
            }
            
            // Get video and container to calculate actual video display bounds
            const video = document.getElementById('camera-video');
            const container = document.querySelector('.camera-view-container');
            
            if(!video || !container) {
                console.log('🎯 No video/container - ignoring');
                return;
            }
            
            const containerRect = container.getBoundingClientRect();
            const containerW = containerRect.width;
            const containerH = containerRect.height;
            
            // Get actual video dimensions
            const videoW = video.videoWidth || 1920;
            const videoH = video.videoHeight || 1080;
            
            // Calculate displayed video area (object-fit: contain)
            const videoAspect = videoW / videoH;
            const containerAspect = containerW / containerH;
            
            let displayedW, displayedH, offsetX, offsetY;
            
            if(videoAspect > containerAspect) {
                displayedW = containerW;
                displayedH = containerW / videoAspect;
                offsetX = 0;
                offsetY = (containerH - displayedH) / 2;
            } else {
                displayedH = containerH;
                displayedW = containerH * videoAspect;
                offsetX = (containerW - displayedW) / 2;
                offsetY = 0;
            }
            
            // Get click position relative to container
            const clickX = event.clientX - containerRect.left;
            const clickY = event.clientY - containerRect.top;
            
            // Check if click is within the actual video display area (not the black letterbox)
            if(clickX < offsetX || clickX > offsetX + displayedW ||
               clickY < offsetY || clickY > offsetY + displayedH) {
                console.log('🎯 Click in letterbox area - ignoring');
                return;
            }
            
            // Calculate percentage position within the video content
            let x = ((clickX - offsetX) / displayedW) * 100;
            let y = ((clickY - offsetY) / displayedH) * 100;
            
            // If in portrait mode, transform coordinates back to landscape space for storage
            // Inverse of display transform (displayX = 100-y, displayY = x)
            // So: originalX = displayY, originalY = 100 - displayX
            if(mainPhotoPortrait) {
                const origX = y;
                const origY = 100 - x;
                x = origX;
                y = origY;
            }
            
            // Clamp to valid range (safety check)
            if(x < 0 || x > 100 || y < 0 || y > 100) {
                console.log('🎯 Click outside bounds - ignoring');
                return;
            }
            
            console.log(`🎯 Click at ${x.toFixed(1)}%, ${y.toFixed(1)}% within video content (portrait: ${mainPhotoPortrait})`);
            
            // Store pending marker position
            pendingMarker = { x, y };
            
            // Show defect type popup near click
            const popup = document.getElementById('defect-popup');
            popup.style.left = Math.min(event.clientX, window.innerWidth - 250) + 'px';
            popup.style.top = Math.min(event.clientY - 80, window.innerHeight - 200) + 'px';
            popup.classList.add('visible');
            console.log('🎯 Popup shown');
        }
        
        function confirmDefectMarker(type) {
            console.log('🎯 confirmDefectMarker called with type:', type);
            console.log('🎯 pendingMarker:', pendingMarker);
            
            if(!pendingMarker) {
                console.warn('🎯 No pending marker - aborting');
                return;
            }
            
            const marker = {
                id: Date.now(),
                x: pendingMarker.x,
                y: pendingMarker.y,
                type: type
            };
            
            defectMarkers.push(marker);
            console.log('🎯 Added marker:', marker);
            console.log('🎯 Total markers:', defectMarkers.length);
            
            pendingMarker = null;
            
            // Hide popup
            document.getElementById('defect-popup').classList.remove('visible');
            
            // Render markers
            renderDefectMarkers();
            updateMarkerCount();
            
            // Auto-set hasDefects if markers exist
            if(defectMarkers.length > 0 && data.hasDefects !== true) {
                data.hasDefects = true;
            }
        }
        
        function cancelDefectMarker() {
            pendingMarker = null;
            document.getElementById('defect-popup').classList.remove('visible');
        }
        
        function removeDefectMarker(id) {
            defectMarkers = defectMarkers.filter(m => m.id !== id);
            renderDefectMarkers();
            updateMarkerCount();
            
            // If no markers left, reset hasDefects
            if(defectMarkers.length === 0) {
                data.hasDefects = null;
            }
        }
        
        // Calculate the actual displayed image bounds within the layer
        // Uses CONTAIN logic to match updateDefectLayerPosition
        function getImageBounds() {
            const video = document.getElementById('camera-video');
            const layer = document.getElementById('defect-markers-layer');
            if(!video || !layer) return null;
            
            const layerRect = layer.getBoundingClientRect();
            
            // Calculate based on video aspect ratio (object-fit: contain)
            const videoAspect = video.videoWidth / video.videoHeight;
            const containerAspect = layerRect.width / layerRect.height;
            
            let imageLeft, imageTop, imageWidth, imageHeight;
            
            if(videoAspect > containerAspect) {
                imageWidth = layerRect.width;
                imageHeight = imageWidth / videoAspect;
                imageLeft = 0;
                imageTop = (layerRect.height - imageHeight) / 2;
            } else {
                imageHeight = layerRect.height;
                imageWidth = imageHeight * videoAspect;
                imageLeft = (layerRect.width - imageWidth) / 2;
                imageTop = 0;
            }
            
            return {
                left: imageLeft,
                top: imageTop,
                width: imageWidth,
                height: imageHeight,
                layerWidth: layerRect.width,
                layerHeight: layerRect.height
            };
        }
        
        function renderDefectMarkers() {
            console.log('🎯 renderDefectMarkers called, count:', defectMarkers.length, 'mode:', photoMode, 'portrait:', mainPhotoPortrait);
            
            const layer = document.getElementById('defect-markers-layer');
            if(!layer) return;
            
            // Remove existing markers
            layer.querySelectorAll('.defect-marker').forEach(m => m.remove());
            
            // Only render if we have markers
            if(defectMarkers.length === 0) return;
            
            // Direct percentage positioning (layer matches image)
            defectMarkers.forEach((marker, idx) => {
                const el = document.createElement('div');
                el.className = `defect-marker ${marker.type}`;
                
                // Transform coordinates if in portrait mode
                // Must match captureMainWithDefects transformation for consistency
                // 90° CW rotation: newX = 100 - y, newY = x
                let displayX = marker.x;
                let displayY = marker.y;
                
                if(mainPhotoPortrait) {
                    displayX = 100 - marker.y;
                    displayY = marker.x;
                }
                
                el.style.left = displayX + '%';
                el.style.top = displayY + '%';
                
                el.innerHTML = `
                    ${idx + 1}
                    <div class="defect-marker-delete" onclick="event.stopPropagation(); removeDefectMarker(${marker.id})">✕</div>
                `;
                el.onclick = (e) => e.stopPropagation();
                el.style.pointerEvents = 'auto';
                layer.appendChild(el);
            });
            
            console.log(`🎯 Rendered ${defectMarkers.length} markers (portrait: ${mainPhotoPortrait})`);
        }
        
        function updateMarkerCount() {
            document.getElementById('marker-count').textContent = defectMarkers.length;
            
            // Show/hide the side panel based on whether there are markers
            const sidePanel = document.getElementById('defect-side-panel');
            if(sidePanel) {
                if(defectMarkers.length > 0 && photoMode === 'main') {
                    sidePanel.classList.add('visible');
                } else {
                    sidePanel.classList.remove('visible');
                }
            }
        }
        
        function enableDefectMarking() {
            console.log('🎯 enableDefectMarking called');
            defectMarkingEnabled = true;
            
            const layer = document.getElementById('defect-markers-layer');
            if(layer) {
                layer.classList.add('active');
            }
            
            const banner = document.getElementById('defect-mode-banner');
            if(banner) {
                banner.classList.add('visible');
            }
            
            // Also render any existing markers
            renderDefectMarkers();
        }
        
        function disableDefectMarking() {
            console.log('🎯 disableDefectMarking called');
            defectMarkingEnabled = false;
            document.getElementById('defect-markers-layer')?.classList.remove('active');
            document.getElementById('defect-mode-banner')?.classList.remove('visible');
            document.getElementById('defect-side-panel')?.classList.remove('visible');
        }
        
        // Visual Defect Link System
        let selectedDefectForCloseup = null; // {photoIndex, defectIndex, type, x, y}
        
        function updateDefectLinkPreview() {
            const preview = document.getElementById('defect-link-preview');
            const thumb = document.getElementById('defect-link-thumb');
            const text = document.getElementById('defect-link-text');
            
            // Guard against null elements
            if (!preview) return;
            
            if(photoMode !== 'defect-closeup') {
                preview.classList.remove('visible');
                return;
            }
            
            // Check if we have any main photos with defects
            const photosWithDefects = data.mainPhotos.filter(p => p.defects && p.defects.length > 0);
            
            if(photosWithDefects.length === 0) {
                preview.classList.remove('visible');
                return;
            }
            
            preview.classList.add('visible');
            
            // Show first photo with defects as thumbnail
            if (thumb && photosWithDefects[0]?.url) {
                thumb.src = photosWithDefects[0].url;
            }
            
            // Show selection status
            if(selectedDefectForCloseup) {
                if (text) {
                    text.textContent = `#${selectedDefectForCloseup.defectIndex + 1} ${selectedDefectForCloseup.type.toUpperCase()}`;
                    text.style.color = '#22c55e';
                }
            } else {
                if (text) {
                    text.textContent = 'Click to select';
                    text.style.color = 'white';
                }
            }
        }
        
        function openDefectPicker() {
            const modal = document.getElementById('defect-picker-modal');
            const photosContainer = document.getElementById('defect-picker-photos');
            
            // Get all main photos with defects
            const photosWithDefects = data.mainPhotos.filter(p => p.defects && p.defects.length > 0);
            
            if(photosWithDefects.length === 0) {
                photosContainer.innerHTML = '<div class="defect-picker-empty">No defects marked yet.<br>Mark defects in Main mode first.</div>';
            } else {
                photosContainer.innerHTML = photosWithDefects.map((photo, photoIdx) => {
                    const actualPhotoIndex = data.mainPhotos.indexOf(photo);
                    const dotsHtml = photo.defects.map((defect, defIdx) => {
                        const color = DEFECT_COLORS[defect.type] || '#ef4444';
                        const isSelected = selectedDefectForCloseup && 
                                         selectedDefectForCloseup.photoIndex === actualPhotoIndex && 
                                         selectedDefectForCloseup.defectIndex === defIdx;
                        return `<div class="defect-picker-dot ${isSelected ? 'selected' : ''}" 
                                    style="left:${defect.x}%; top:${defect.y}%; background:${color};"
                                    onclick="selectDefectFromPicker(${actualPhotoIndex}, ${defIdx}, '${defect.type}', ${defect.x}, ${defect.y})">
                                    ${defIdx + 1}
                                    <span class="defect-picker-dot-label">${defect.type.toUpperCase()}</span>
                                </div>`;
                    }).join('');
                    
                    return `<div class="defect-picker-photo-container">
                                <div class="defect-picker-photo-label">Photo ${actualPhotoIndex + 1}</div>
                                <img src="${photo.url}" alt="Main photo ${actualPhotoIndex + 1}">
                                ${dotsHtml}
                            </div>`;
                }).join('');
            }
            
            updateDefectPickerSelection();
            modal.classList.add('active');
        }
        
        function closeDefectPicker() {
            document.getElementById('defect-picker-modal').classList.remove('active');
            updateDefectLinkPreview();
        }
        
        function selectDefectFromPicker(photoIndex, defectIndex, type, x, y) {
            selectedDefectForCloseup = { photoIndex, defectIndex, type, x, y };
            
            // Update dot selection visuals
            document.querySelectorAll('.defect-picker-dot').forEach(dot => dot.classList.remove('selected'));
            event.target.closest('.defect-picker-dot').classList.add('selected');
            
            updateDefectPickerSelection();
            showToast('success', `Selected Defect #${defectIndex + 1}`, type.toUpperCase(), 1500);
        }
        
        function updateDefectPickerSelection() {
            const selectedDiv = document.getElementById('defect-picker-selected');
            if(selectedDefectForCloseup) {
                selectedDiv.textContent = `✓ Defect #${selectedDefectForCloseup.defectIndex + 1} - ${selectedDefectForCloseup.type.toUpperCase()}`;
                selectedDiv.classList.add('has-selection');
            } else {
                selectedDiv.textContent = 'No defect selected';
                selectedDiv.classList.remove('has-selection');
            }
        }
        
        function clearDefectSelection() {
            selectedDefectForCloseup = null;
            document.querySelectorAll('.defect-picker-dot').forEach(dot => dot.classList.remove('selected'));
            updateDefectPickerSelection();
            updateDefectLinkPreview();
        }
        
        // Legacy function name for compatibility
        function updateDefectLinkPanel() {
            updateDefectLinkPreview();
        }
        
        function selectDefectLink(index) {
            // Legacy - now handled by visual picker
        }
        
        // Feature Type Panel
        function updateFeatureTypePanel() {
            // Small delay to ensure DOM is ready
            setTimeout(() => {
                const panel = document.getElementById('feature-type-panel');
                if(!panel) {
                    console.error('❌ Feature type panel element not found!');
                    return;
                }
                
                console.log('✨ updateFeatureTypePanel - mode:', photoMode);
                
                if(photoMode === 'features') {
                    panel.style.display = 'flex';
                    panel.classList.add('visible');
                    console.log('✨ Feature panel SHOWN at', panel.getBoundingClientRect());
                } else {
                    panel.style.display = 'none';
                    panel.classList.remove('visible');
                }
                
                // Update active state on buttons
                document.querySelectorAll('.feature-type-btn').forEach(btn => {
                    if(btn.textContent === selectedFeatureType) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
            }, 100);
        }
        
        function selectFeatureType(type) {
            selectedFeatureType = type;
            // Keep panel visible and update buttons
            const panel = document.getElementById('feature-type-panel');
            if(panel) {
                panel.style.display = 'flex';
                document.querySelectorAll('.feature-type-btn').forEach(btn => {
                    if(btn.textContent === type) {
                        btn.classList.add('active');
                        btn.style.background = 'white';
                        btn.style.color = '#7c3aed';
                    } else {
                        btn.classList.remove('active');
                        btn.style.background = 'rgba(255,255,255,0.2)';
                        btn.style.color = 'white';
                    }
                });
            }
            showToast('info', `Feature: ${type}`, 'Next photo will be tagged', 1500);
        }
        
        function selectDetailType(type) {
            selectedDetailType = type;
            // Keep panel visible and update buttons
            const panel = document.getElementById('detail-type-panel');
            if(panel) {
                panel.style.display = 'flex';
                document.querySelectorAll('.detail-type-btn').forEach(btn => {
                    // Check if button text contains the type (accounting for emoji)
                    if(btn.textContent.includes(type)) {
                        btn.classList.add('active');
                        btn.style.background = 'white';
                        btn.style.color = '#0891b2';
                    } else {
                        btn.classList.remove('active');
                        btn.style.background = 'rgba(255,255,255,0.2)';
                        btn.style.color = 'white';
                    }
                });
            }
            showToast('info', `Detail: ${type}`, 'Slide item under detail camera', 1500);
        }
        
        function updateDetailTypePanel() {
            const panel = document.getElementById('detail-type-panel');
            if(!panel) return;
            
            if(photoMode === 'detail') {
                panel.style.display = 'flex';
            } else {
                panel.style.display = 'none';
            }
        }
        
        // ============ SPLIT SCREEN DEFECT CLOSEUP ============
        let splitCameraStream = null;
        let currentDefectSide = 'front'; // 'front' or 'back'
        
        // Get defect photos for a specific side
        function getDefectPhotoForSide(side) {
            // Find main photo tagged with this side that has defects
            return data.mainPhotos.find(p => p.defectSide === side && p.defects && p.defects.length > 0);
        }
        
        // Count defects for each side
        function countDefectsForSide(side) {
            const photo = getDefectPhotoForSide(side);
            return photo ? photo.defects.length : 0;
        }
        
        // Switch between front/back tabs
        function switchDefectSide(side) {
            currentDefectSide = side;
            
            // Update tab visuals
            document.getElementById('split-tab-front').classList.toggle('active', side === 'front');
            document.getElementById('split-tab-back').classList.toggle('active', side === 'back');
            
            // Clear selection when switching sides
            selectedDefectForCloseup = null;
            
            // Re-render the photo
            renderSplitDefectView();
        }
        
        function renderSplitDefectView() {
            const container = document.getElementById('split-photo-container');
            const selectionDiv = document.getElementById('split-selection');
            
            // Update tab counts
            document.getElementById('front-defect-count').textContent = countDefectsForSide('front');
            document.getElementById('back-defect-count').textContent = countDefectsForSide('back');
            
            // Get photo for current side
            const photo = getDefectPhotoForSide(currentDefectSide);
            
            if(!photo) {
                const sideLabel = currentDefectSide.toUpperCase();
                container.innerHTML = `
                    <div class="split-no-photo">
                        <div class="split-no-photo-icon">📷</div>
                        <div>No ${sideLabel} photo with defects</div>
                        <div style="margin-top:8px;font-size:12px;color:#888;">
                            In Main mode:<br>
                            1. Lay item ${currentDefectSide}-side up (T-shape)<br>
                            2. Mark defects by clicking<br>
                            3. Press F for Front or B for Back<br>
                            4. Capture the photo
                        </div>
                    </div>`;
                selectionDiv.textContent = `No ${currentDefectSide} defects to link`;
                selectionDiv.classList.remove('has-selection');
                return;
            }
            
            const photoIndex = data.mainPhotos.indexOf(photo);
            
            // Create defect dots HTML
            let dotsHtml = photo.defects.map((defect, defIdx) => {
                const color = DEFECT_COLORS[defect.type] || '#ef4444';
                const isSelected = selectedDefectForCloseup && 
                                 selectedDefectForCloseup.photoIndex === photoIndex && 
                                 selectedDefectForCloseup.defectIndex === defIdx;
                return `<div class="split-defect-dot ${isSelected ? 'selected' : ''}" 
                            style="left:${defect.x}%; top:${defect.y}%; background:${color};"
                            onclick="selectSplitDefect(${photoIndex}, ${defIdx}, '${defect.type}', ${defect.x}, ${defect.y}, '${currentDefectSide}')">
                            ${defIdx + 1}
                            <span class="split-defect-dot-label">${defect.type.toUpperCase()}</span>
                        </div>`;
            }).join('');
            
            // Use wrapper div for proper dot positioning relative to image
            container.innerHTML = `
                <div class="split-photo-wrapper">
                    <img src="${photo.url}" alt="${currentDefectSide} photo with defects">
                    ${dotsHtml}
                </div>`;
            
            // Update selection display
            updateSplitSelection();
        }
        
        function selectSplitDefect(photoIndex, defectIndex, type, x, y, side) {
            selectedDefectForCloseup = { photoIndex, defectIndex, type, x, y, side };
            
            // Update dot visuals
            document.querySelectorAll('.split-defect-dot').forEach(dot => dot.classList.remove('selected'));
            event.target.closest('.split-defect-dot').classList.add('selected');
            
            updateSplitSelection();
            const sideLabel = side.charAt(0).toUpperCase() + side.slice(1);
            showToast('success', `${sideLabel} #${defectIndex + 1} Selected`, `${type.toUpperCase()} - Press SPACE`, 1500);
        }
        
        function updateSplitSelection() {
            const selectionDiv = document.getElementById('split-selection');
            if(!selectionDiv) return;
            
            if(selectedDefectForCloseup) {
                const sideLabel = selectedDefectForCloseup.side ? selectedDefectForCloseup.side.toUpperCase() : '';
                selectionDiv.innerHTML = `✓ <strong>${sideLabel} #${selectedDefectForCloseup.defectIndex + 1} ${selectedDefectForCloseup.type.toUpperCase()}</strong> — Press SPACE to capture`;
                selectionDiv.classList.add('has-selection');
            } else {
                selectionDiv.textContent = 'Click a defect dot to link your closeup';
                selectionDiv.classList.remove('has-selection');
            }
        }
        
        async function startSplitCameraFeed(deviceId) {
            const video = document.getElementById('split-camera-video');
            if(!video) return;
            
            // Stop any existing split stream
            if(splitCameraStream) {
                splitCameraStream.getTracks().forEach(t => t.stop());
                splitCameraStream = null;
            }
            
            try {
                splitCameraStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        deviceId: { exact: deviceId },
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });
                video.srcObject = splitCameraStream;
                
                // Start stabilizer for split view
                startSplitStabilizer();
                
                console.log('📹 Split camera feed started');
            } catch(e) {
                console.error('📹 Failed to start split camera:', e);
                showToast('error', 'Camera Error', e.message, 3000);
            }
        }
        
        function stopSplitCameraFeed() {
            if(splitCameraStream) {
                splitCameraStream.getTracks().forEach(t => t.stop());
                splitCameraStream = null;
            }
            stopSplitStabilizer();
        }
        
        // Simple stabilizer for split view
        let splitStabilizerInterval = null;
        let splitPreviousFrame = null;
        let splitStableCount = 0;
        
        function startSplitStabilizer() {
            const video = document.getElementById('split-camera-video');
            const dot = document.getElementById('split-stabilizer-dot');
            const text = document.getElementById('split-stabilizer-text');
            
            if(!video || !dot || !text) return;
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 48;
            
            splitStabilizerInterval = setInterval(() => {
                if(video.readyState < 2) return;
                
                ctx.drawImage(video, 0, 0, 64, 48);
                const frame = ctx.getImageData(0, 0, 64, 48);
                
                if(splitPreviousFrame) {
                    let diff = 0;
                    for(let i = 0; i < frame.data.length; i += 16) {
                        diff += Math.abs(frame.data[i] - splitPreviousFrame.data[i]);
                    }
                    diff = diff / (frame.data.length / 16);
                    
                    if(diff < 8) {
                        splitStableCount++;
                        if(splitStableCount >= 3) {
                            dot.classList.add('stable');
                            text.textContent = 'STABLE ✓';
                        }
                    } else {
                        splitStableCount = 0;
                        dot.classList.remove('stable');
                        text.textContent = 'HOLD STEADY';
                    }
                }
                splitPreviousFrame = frame;
            }, 150);
        }
        
        function stopSplitStabilizer() {
            if(splitStabilizerInterval) {
                clearInterval(splitStabilizerInterval);
                splitStabilizerInterval = null;
            }
            splitPreviousFrame = null;
            splitStableCount = 0;
        }
        
        // Capture main photo with defects tagged as front or back
        function captureDefectSide(side) {
            if(defectMarkers.length === 0) {
                showToast('warning', 'No Defects Marked', 'Click on the preview to mark defects first', 2000);
                return;
            }
            
            if(photoMode !== 'main') {
                showToast('warning', 'Wrong Mode', 'Switch to Main mode first', 2000);
                return;
            }
            
            // Check if we already have a photo for this side
            const existingPhoto = data.mainPhotos.find(p => p.defectSide === side);
            if(existingPhoto) {
                if(!confirm(`You already have a ${side.toUpperCase()} defect photo. Replace it?`)) {
                    return;
                }
                // Remove the existing photo
                const idx = data.mainPhotos.indexOf(existingPhoto);
                if(idx > -1) {
                    URL.revokeObjectURL(existingPhoto.url);
                    data.mainPhotos.splice(idx, 1);
                }
            }
            
            // Store the side we're capturing for
            pendingDefectSide = side;
            
            // Capture the photo (this will use pendingDefectSide)
            capturePhoto();
            
            showToast('success', `${side.toUpperCase()} Defects Captured`, `${defectMarkers.length} defects marked`, 2000);
        }
        
        // Variable to track pending defect side
        let pendingDefectSide = null;
        
        function clearDefectMarkers() {
            defectMarkers = [];
            
            // Clear markers from layer
            document.getElementById('defect-markers-layer')?.querySelectorAll('.defect-marker').forEach(m => m.remove());
            
            // Reset layer styles
            resetDefectLayerStyles();
            
            updateMarkerCount();
            console.log('🎯 Defect markers cleared');
        }
        
        // Reset defect layer to CSS defaults (removes inline positioning)
        function resetDefectLayerStyles() {
            const layer = document.getElementById('defect-markers-layer');
            if(layer) {
                layer.style.width = '';
                layer.style.height = '';
                layer.style.left = '';
                layer.style.top = '';
                layer.style.position = '';
                layer.style.transform = '';
            }
            console.log('🎯 Defect layer styles reset to CSS defaults');
        }

        const categoryConfig = {
            tops: { heroes: ['T-Shirt', 'Sweatshirt', 'Hoodie'], others: ['Sweater', 'Button Shirt', 'Flannel', 'Polo', 'Jersey', 'Tank Top', 'Cardigan', 'Henley'] },
            bottoms: { heroes: ['Jeans', 'Pants'], others: ['Shorts', 'Sweatpants'] },
            outer: { heroes: ['Jacket', 'Coat'], others: ['Vest'] }
        };
        const catEmojis = { 'T-Shirt':'👕', 'Sweatshirt':'🏋️', 'Hoodie':'🧥', 'Sweater':'🧶', 'Button Shirt':'👔', 'Flannel':'🪵', 'Polo':'🏌️', 'Jersey':'🏀', 'Tank Top':'🩱', 'Cardigan':'🧥', 'Henley':'👕', 'Jeans':'👖', 'Pants':'👖', 'Shorts':'🩳', 'Sweatpants':'🏃', 'Jacket':'🧥', 'Coat':'🧥', 'Vest':'🦺', 'Blouse':'👚', 'Tunic':'👗' };
        
        // V99.45: fabricDB with full traits (stretch, surface, interior)
        // surface: smooth, ridged, diagonal, rough/textured
        const fabricDB = {
            // TOPS - Per eBay PDF fabric types
            "T-Shirt": [
                { name:"Knit", priority:1, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Standard tee fabric. Stretchy, smooth both sides." },
                { name:"Jersey", priority:2, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Athletic tee. Soccer, Nike Dri-Fit style." },
                { name:"Rayon", priority:2, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Silky, drapey. 80s/90s soft tees." },
                { name:"Woven", priority:3, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Rigid like dress shirt. Rare for tees." },
                { name:"Mesh", priority:3, traits:{stretch:"high",surface:"rough",interior:"smooth"}, desc:"See-through with tiny holes. Athletic." }
            ],
            "Sweatshirt": [
                { name:"Fleece", priority:1, traits:{stretch:"high",surface:"smooth",interior:"fuzzy"}, desc:"Fuzzy inside, smooth outside. 90% of sweats." },
                { name:"French Terry", priority:2, traits:{stretch:"high",surface:"smooth",interior:"loops"}, desc:"Tiny loops inside. Lighter, summer weight." },
                { name:"Knit", priority:3, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Sweater-like. Smooth both sides." },
                { name:"Jersey", priority:3, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Thin like a thick t-shirt." }
            ],
            "Hoodie": [
                { name:"Fleece", priority:1, traits:{stretch:"high",surface:"smooth",interior:"fuzzy"}, desc:"Fuzzy inside, smooth outside. Most common." },
                { name:"French Terry", priority:2, traits:{stretch:"high",surface:"smooth",interior:"loops"}, desc:"Tiny loops inside. Lighter weight." },
                { name:"Knit", priority:3, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Sweater-like hoodie." },
                { name:"Jersey", priority:3, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Thin, lightweight hoodie." }
            ],
            "Sweater": [
                { name:"Knit", priority:1, traits:{stretch:"high",surface:"rough",interior:"smooth"}, desc:"Standard sweater. Stretchy yarn loops visible." },
                { name:"Crochet", priority:2, traits:{stretch:"high",surface:"rough",interior:"smooth"}, desc:"Open holes, handmade look." },
                { name:"Jersey", priority:3, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Thin, lightweight sweater." }
            ],
            "Cardigan": [
                { name:"Knit", priority:1, traits:{stretch:"high",surface:"rough",interior:"smooth"}, desc:"Standard cardigan with buttons/open front." },
                { name:"Crochet", priority:2, traits:{stretch:"high",surface:"rough",interior:"smooth"}, desc:"Open holes, handmade look." },
                { name:"Jersey", priority:3, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Thin, lightweight." }
            ],
            "Button Shirt": [
                { name:"Woven", priority:1, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Dress shirt fabric. Rigid, no stretch." },
                { name:"Poplin", priority:2, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Crisp dress shirt. Fine weave." },
                { name:"Chambray", priority:2, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Looks like light denim but softer." },
                { name:"Denim", priority:2, traits:{stretch:"none",surface:"diagonal",interior:"smooth"}, desc:"Jean material. Western/work shirt." },
                { name:"Flannel", priority:2, traits:{stretch:"none",surface:"smooth",interior:"fuzzy"}, desc:"Soft, fuzzy inside. Often plaid." },
                { name:"Corduroy", priority:3, traits:{stretch:"none",surface:"ridged",interior:"smooth"}, desc:"Vertical ridges you can feel & see." }
            ],
            "Flannel": [
                { name:"Flannel", priority:1, traits:{stretch:"none",surface:"smooth",interior:"fuzzy"}, desc:"Soft, fuzzy inside. Classic plaid flannel." },
                { name:"Woven", priority:2, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Thinner flannel-style shirt." }
            ],
            "Henley": [
                { name:"Knit", priority:1, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Standard henley. Stretchy like a tee." },
                { name:"Jersey", priority:2, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Athletic henley. Soft & stretchy." },
                { name:"Waffle", priority:2, traits:{stretch:"high",surface:"rough",interior:"smooth"}, desc:"Thermal henley. Grid texture." }
            ],
            "Polo": [
                { name:"Knit", priority:1, traits:{stretch:"high",surface:"rough",interior:"smooth"}, desc:"Standard polo. Stretchy with textured surface." },
                { name:"Jersey", priority:2, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"T-shirt-like polo. Smoother." },
                { name:"Woven", priority:3, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Dress polo. Rigid like button shirt." }
            ],
            "Tank Top": [
                { name:"Jersey", priority:1, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Standard tank. Soft & stretchy." },
                { name:"Knit", priority:1, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Same as Jersey." },
                { name:"Rayon", priority:2, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Silky, drapey feel." },
                { name:"Mesh", priority:3, traits:{stretch:"high",surface:"rough",interior:"smooth"}, desc:"See-through athletic. Tiny holes." }
            ],
            "Blouse": [
                { name:"Woven", priority:1, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Standard blouse. Rigid fabric." },
                { name:"Chiffon", priority:2, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Sheer, flowy. You can see through it." },
                { name:"Satin", priority:2, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Shiny, silky smooth." },
                { name:"Crepe", priority:2, traits:{stretch:"none",surface:"rough",interior:"smooth"}, desc:"Slightly bumpy/crinkly texture." },
                { name:"Lace", priority:3, traits:{stretch:"high",surface:"rough",interior:"smooth"}, desc:"Decorative with pattern holes." },
                { name:"Georgette", priority:3, traits:{stretch:"none",surface:"rough",interior:"smooth"}, desc:"Sheer crepe. Slightly rough feel." }
            ],
            "Tunic": [
                { name:"Woven", priority:1, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Standard tunic fabric." },
                { name:"Rayon", priority:2, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Drapey, soft, silky feel." },
                { name:"Knit", priority:2, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Stretchy tunic." },
                { name:"Crepe", priority:3, traits:{stretch:"none",surface:"rough",interior:"smooth"}, desc:"Slightly bumpy texture." },
                { name:"Gauze", priority:3, traits:{stretch:"none",surface:"rough",interior:"smooth"}, desc:"Very lightweight, airy, breathable." }
            ],
            "Jersey": [
                { name:"Mesh", priority:1, traits:{stretch:"high",surface:"rough",interior:"smooth"}, desc:"Tiny holes. Most sports jerseys." },
                { name:"Jersey", priority:2, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Smooth. Baseball/hockey style." },
                { name:"Knit", priority:3, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Heavier, vintage style." }
            ],
            // BOTTOMS
            "Jeans": [
                { name:"Denim", priority:1, traits:{stretch:"none",surface:"diagonal",interior:"smooth"}, desc:"Standard jean material. Diagonal weave." },
                { name:"Selvage", priority:2, traits:{stretch:"none",surface:"diagonal",interior:"smooth"}, desc:"Premium. Red/white line on inside cuff edge." }
            ],
            "Pants": [
                { name:"Woven", priority:1, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Dress pants. Smooth, rigid." },
                { name:"Twill", priority:1, traits:{stretch:"none",surface:"diagonal",interior:"smooth"}, desc:"Chinos, khakis. Diagonal weave pattern." },
                { name:"Corduroy", priority:2, traits:{stretch:"none",surface:"ridged",interior:"smooth"}, desc:"Vertical ridges you can feel & see." },
                { name:"Canvas", priority:2, traits:{stretch:"none",surface:"rough",interior:"smooth"}, desc:"Heavy, thick. Carhartt/workwear." },
                { name:"Moleskin", priority:3, traits:{stretch:"none",surface:"smooth",interior:"fuzzy"}, desc:"Soft, brushed cotton. Fuzzy feel." },
                { name:"Ponte", priority:3, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Stretchy dress pant. Thick legging-like." }
            ],
            "Shorts": [
                { name:"Woven", priority:1, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Standard shorts. No stretch." },
                { name:"Twill", priority:1, traits:{stretch:"none",surface:"diagonal",interior:"smooth"}, desc:"Cotton shorts. Diagonal weave." },
                { name:"Canvas", priority:2, traits:{stretch:"none",surface:"rough",interior:"smooth"}, desc:"Heavy, thick cotton." },
                { name:"Denim", priority:2, traits:{stretch:"none",surface:"diagonal",interior:"smooth"}, desc:"Jean shorts, cutoffs." },
                { name:"Mesh", priority:3, traits:{stretch:"high",surface:"rough",interior:"smooth"}, desc:"Athletic shorts. See-through holes." }
            ],
            "Sweatpants": [
                { name:"Fleece", priority:1, traits:{stretch:"high",surface:"smooth",interior:"fuzzy"}, desc:"Fuzzy inside. Standard sweats." },
                { name:"French Terry", priority:2, traits:{stretch:"high",surface:"smooth",interior:"loops"}, desc:"Tiny loops inside. Lighter." },
                { name:"Knit", priority:3, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Smooth both sides. Jogger style." }
            ],
            // OUTER - Per eBay PDF fabric types (NO materials like Nylon)
            "Jacket": [
                { name:"Denim", priority:1, traits:{stretch:"none",surface:"diagonal",interior:"smooth"}, desc:"Jean jacket material. Trucker style." },
                { name:"Canvas", priority:1, traits:{stretch:"none",surface:"rough",interior:"smooth"}, desc:"Heavy cotton. Work jacket, Carhartt, chore coat." },
                { name:"Leather", priority:1, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Animal hide. Motorcycle, A-2/G-1 flight, cafe racer." },
                { name:"Satin", priority:2, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Shiny, silky. Starter jackets, varsity sleeves, bomber." },
                { name:"Twill", priority:2, traits:{stretch:"none",surface:"diagonal",interior:"smooth"}, desc:"Harrington, Dickies style. Diagonal weave." },
                { name:"Corduroy", priority:2, traits:{stretch:"none",surface:"ridged",interior:"smooth"}, desc:"Vertical ridges. 70s style." },
                { name:"Fleece", priority:3, traits:{stretch:"high",surface:"smooth",interior:"fuzzy"}, desc:"Soft, fuzzy. Patagonia, North Face style." },
                { name:"Softshell", priority:3, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Stretchy outdoor tech jacket." }
            ],
            "Coat": [
                { name:"Tweed", priority:1, traits:{stretch:"none",surface:"rough",interior:"smooth"}, desc:"Rough, speckled wool blend. Professor/country style." },
                { name:"Woven", priority:1, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Classic overcoat, peacoat. Dress coat." },
                { name:"Velvet", priority:2, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Soft, plush. Luxe vintage look." },
                { name:"Shearling", priority:2, traits:{stretch:"none",surface:"smooth",interior:"fuzzy"}, desc:"Wool/fur lined inside. Rancher style." },
                { name:"Felt", priority:3, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Pressed wool. Stiff, structured." },
                { name:"Taffeta", priority:3, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Crisp, shiny. Formal evening coat." }
            ],
            "Vest": [
                { name:"Quilted", priority:1, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Puffer vest. Puffy, insulated sections." },
                { name:"Fleece", priority:1, traits:{stretch:"high",surface:"smooth",interior:"fuzzy"}, desc:"Soft, fuzzy. Patagonia style." },
                { name:"Denim", priority:2, traits:{stretch:"none",surface:"diagonal",interior:"smooth"}, desc:"Jean vest, cut-off sleeves." },
                { name:"Leather", priority:2, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Motorcycle vest, biker style." },
                { name:"Knit", priority:3, traits:{stretch:"high",surface:"rough",interior:"smooth"}, desc:"Sweater vest." }
            ],
            "default": [
                { name:"Knit", priority:1, traits:{stretch:"high",surface:"smooth",interior:"smooth"}, desc:"Stretchy, like t-shirt material." },
                { name:"Woven", priority:2, traits:{stretch:"none",surface:"smooth",interior:"smooth"}, desc:"Rigid, no stretch. Like dress shirt." },
                { name:"Fleece", priority:2, traits:{stretch:"high",surface:"smooth",interior:"fuzzy"}, desc:"Fuzzy inside." },
                { name:"Denim", priority:3, traits:{stretch:"none",surface:"diagonal",interior:"smooth"}, desc:"Jean material." }
            ]
        };
        // V99.9: materialDB from eBay official materials (per PDF)
        const materialDB = {
            // TOPS
            "T-Shirt": [
                { name:"Cotton", priority:1, traits:{temp:"cool",shine:"matte"}, desc:"Natural. Cool, soft." },
                { name:"Polyester", priority:2, traits:{temp:"warm",shine:"sheen"}, desc:"Synthetic. Slight sheen." },
                { name:"Rayon", priority:2, traits:{temp:"cool",shine:"sheen"}, desc:"Silky, drapey." },
                { name:"Nylon", priority:3, traits:{temp:"warm",shine:"sheen"}, desc:"Synthetic, athletic." },
                { name:"Acrylic", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Synthetic wool-like." }
            ],
            "Sweatshirt": [
                { name:"Cotton", priority:1, traits:{temp:"cool",shine:"matte"}, desc:"Natural. Most common." },
                { name:"Polyester", priority:2, traits:{temp:"warm",shine:"sheen"}, desc:"Athletic." },
                { name:"Acrylic", priority:2, traits:{temp:"warm",shine:"matte"}, desc:"Synthetic." },
                { name:"Wool", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Rare, warm." }
            ],
            "Hoodie": [
                { name:"Cotton", priority:1, traits:{temp:"cool",shine:"matte"}, desc:"Natural. Most common." },
                { name:"Polyester", priority:2, traits:{temp:"warm",shine:"sheen"}, desc:"Tech fleece." },
                { name:"Acrylic", priority:2, traits:{temp:"warm",shine:"matte"}, desc:"Synthetic." },
                { name:"Nylon", priority:3, traits:{temp:"warm",shine:"sheen"}, desc:"Athletic." }
            ],
            "Sweater": [
                { name:"Wool", priority:1, traits:{temp:"warm",shine:"matte"}, desc:"Classic. Warm." },
                { name:"Acrylic", priority:1, traits:{temp:"warm",shine:"matte"}, desc:"Synthetic wool." },
                { name:"Cotton", priority:2, traits:{temp:"cool",shine:"matte"}, desc:"Lightweight." },
                { name:"Cashmere", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Luxury. Ultra soft." },
                { name:"Mohair", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Fuzzy, luxe." },
                { name:"Alpaca", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Soft, warm." }
            ],
            "Cardigan": [
                { name:"Wool", priority:1, traits:{temp:"warm",shine:"matte"}, desc:"Classic cardigan." },
                { name:"Acrylic", priority:1, traits:{temp:"warm",shine:"matte"}, desc:"Synthetic wool." },
                { name:"Cotton", priority:2, traits:{temp:"cool",shine:"matte"}, desc:"Lightweight." },
                { name:"Cashmere", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Luxury." },
                { name:"Mohair", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Fuzzy." },
                { name:"Alpaca", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Soft, warm." }
            ],
            "Button Shirt": [
                { name:"Cotton", priority:1, traits:{temp:"cool",shine:"matte"}, desc:"Natural. Crisp." },
                { name:"Polyester", priority:2, traits:{temp:"warm",shine:"sheen"}, desc:"Wrinkle-free." },
                { name:"Rayon", priority:2, traits:{temp:"cool",shine:"sheen"}, desc:"Silky, drapey." },
                { name:"Linen", priority:2, traits:{temp:"cool",shine:"matte"}, desc:"Cool, wrinkles." },
                { name:"Wool", priority:2, traits:{temp:"warm",shine:"matte"}, desc:"Warm. Flannel." },
                { name:"Silk", priority:3, traits:{temp:"cool",shine:"sheen"}, desc:"Luxury. Shiny." },
                { name:"Nylon", priority:3, traits:{temp:"warm",shine:"sheen"}, desc:"Disco era." }
            ],
            "Flannel": [
                { name:"Cotton", priority:1, traits:{temp:"cool",shine:"matte"}, desc:"Classic cotton flannel." },
                { name:"Wool", priority:2, traits:{temp:"warm",shine:"matte"}, desc:"Warm wool flannel." },
                { name:"Polyester", priority:3, traits:{temp:"warm",shine:"sheen"}, desc:"Synthetic blend." }
            ],
            "Henley": [
                { name:"Cotton", priority:1, traits:{temp:"cool",shine:"matte"}, desc:"Natural. Soft." },
                { name:"Polyester", priority:2, traits:{temp:"warm",shine:"sheen"}, desc:"Athletic henley." },
                { name:"Rayon", priority:2, traits:{temp:"cool",shine:"sheen"}, desc:"Silky feel." }
            ],
            "Polo": [
                { name:"Cotton", priority:1, traits:{temp:"cool",shine:"matte"}, desc:"Classic polo." },
                { name:"Polyester", priority:2, traits:{temp:"warm",shine:"sheen"}, desc:"Athletic." },
                { name:"Acrylic", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Synthetic." }
            ],
            "Tank Top": [
                { name:"Cotton", priority:1, traits:{temp:"cool",shine:"matte"}, desc:"Classic tank." },
                { name:"Polyester", priority:2, traits:{temp:"warm",shine:"sheen"}, desc:"Athletic." },
                { name:"Rayon", priority:2, traits:{temp:"cool",shine:"sheen"}, desc:"Silky." },
                { name:"Nylon", priority:3, traits:{temp:"warm",shine:"sheen"}, desc:"Athletic." }
            ],
            "Blouse": [
                { name:"Polyester", priority:1, traits:{temp:"warm",shine:"sheen"}, desc:"Most common vintage." },
                { name:"Rayon", priority:1, traits:{temp:"cool",shine:"sheen"}, desc:"Silky, drapey." },
                { name:"Silk", priority:2, traits:{temp:"cool",shine:"sheen"}, desc:"Luxury." },
                { name:"Cotton", priority:2, traits:{temp:"cool",shine:"matte"}, desc:"Natural." },
                { name:"Nylon", priority:3, traits:{temp:"warm",shine:"sheen"}, desc:"70s-80s." }
            ],
            "Tunic": [
                { name:"Cotton", priority:1, traits:{temp:"cool",shine:"matte"}, desc:"Natural." },
                { name:"Rayon", priority:2, traits:{temp:"cool",shine:"sheen"}, desc:"Drapey." },
                { name:"Linen", priority:2, traits:{temp:"cool",shine:"matte"}, desc:"Breathable." },
                { name:"Wool", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Warm." }
            ],
            "Jersey": [
                { name:"Polyester", priority:1, traits:{temp:"warm",shine:"sheen"}, desc:"Most athletic." },
                { name:"Nylon", priority:1, traits:{temp:"warm",shine:"sheen"}, desc:"Mesh jerseys." },
                { name:"Cotton", priority:2, traits:{temp:"cool",shine:"matte"}, desc:"Vintage baseball." },
                { name:"Rayon", priority:3, traits:{temp:"cool",shine:"sheen"}, desc:"Old school." }
            ],
            // BOTTOMS
            "Jeans": [
                { name:"Cotton", priority:1, traits:{temp:"cool",shine:"matte"}, desc:"100% denim." },
                { name:"Polyester", priority:3, traits:{temp:"warm",shine:"sheen"}, desc:"Rare blend." }
            ],
            "Pants": [
                { name:"Polyester", priority:1, traits:{temp:"warm",shine:"sheen"}, desc:"Dress pants." },
                { name:"Cotton", priority:1, traits:{temp:"cool",shine:"matte"}, desc:"Chinos." },
                { name:"Wool", priority:2, traits:{temp:"warm",shine:"matte"}, desc:"Dress wool." },
                { name:"Rayon", priority:2, traits:{temp:"cool",shine:"sheen"}, desc:"Drapey." },
                { name:"Nylon", priority:3, traits:{temp:"warm",shine:"sheen"}, desc:"Athletic." },
                { name:"Canvas", priority:3, traits:{temp:"cool",shine:"matte"}, desc:"Workwear." }
            ],
            "Shorts": [
                { name:"Cotton", priority:1, traits:{temp:"cool",shine:"matte"}, desc:"Cotton shorts." },
                { name:"Nylon", priority:1, traits:{temp:"warm",shine:"sheen"}, desc:"Athletic/swim." },
                { name:"Polyester", priority:2, traits:{temp:"warm",shine:"sheen"}, desc:"Athletic." },
                { name:"Canvas", priority:2, traits:{temp:"cool",shine:"matte"}, desc:"Heavy duty." },
                { name:"Rayon", priority:3, traits:{temp:"cool",shine:"sheen"}, desc:"Drapey." }
            ],
            "Sweatpants": [
                { name:"Cotton", priority:1, traits:{temp:"cool",shine:"matte"}, desc:"Classic sweats." },
                { name:"Polyester", priority:2, traits:{temp:"warm",shine:"sheen"}, desc:"Athletic." },
                { name:"Acrylic", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Synthetic." }
            ],
            // OUTER
            "Jacket": [
                { name:"Nylon", priority:1, traits:{temp:"warm",shine:"sheen"}, desc:"Windbreaker." },
                { name:"Polyester", priority:1, traits:{temp:"warm",shine:"sheen"}, desc:"Athletic." },
                { name:"Canvas", priority:2, traits:{temp:"cool",shine:"matte"}, desc:"Work jacket." },
                { name:"Cotton", priority:2, traits:{temp:"cool",shine:"matte"}, desc:"Denim/canvas." },
                { name:"Leather", priority:2, traits:{temp:"cool",shine:"sheen"}, desc:"Moto, bomber." },
                { name:"Wool", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Varsity." }
            ],
            "Coat": [
                { name:"Wool", priority:1, traits:{temp:"warm",shine:"matte"}, desc:"Dress coat." },
                { name:"Leather", priority:2, traits:{temp:"cool",shine:"sheen"}, desc:"Trench, long." },
                { name:"Nylon", priority:2, traits:{temp:"warm",shine:"sheen"}, desc:"Puffer." },
                { name:"Polyester", priority:2, traits:{temp:"warm",shine:"sheen"}, desc:"Down fill." },
                { name:"Cashmere", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Luxury." },
                { name:"Fur", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Real/faux fur." }
            ],
            "Vest": [
                { name:"Nylon", priority:1, traits:{temp:"warm",shine:"sheen"}, desc:"Puffer." },
                { name:"Polyester", priority:2, traits:{temp:"warm",shine:"sheen"}, desc:"Fleece." },
                { name:"Cotton", priority:2, traits:{temp:"cool",shine:"matte"}, desc:"Denim." },
                { name:"Wool", priority:3, traits:{temp:"warm",shine:"matte"}, desc:"Sweater vest." }
            ],
            "default": [
                { name:"Cotton", priority:1, traits:{temp:"cool",shine:"matte"}, desc:"Natural fiber." },
                { name:"Polyester", priority:2, traits:{temp:"warm",shine:"sheen"}, desc:"Synthetic." },
                { name:"Wool", priority:2, traits:{temp:"warm",shine:"matte"}, desc:"Warm, natural." },
                { name:"Nylon", priority:3, traits:{temp:"warm",shine:"sheen"}, desc:"Synthetic." }
            ]
        };

        // V99.45: patternDB with traits for dynamic pattern identification
        // lines: none, stripes, grid (crossing lines)
        // shapes: none, dots, curved (flowers/paisley), geometric, blobs (irregular)
        // method: woven (part of fabric), printed (on surface), stitched (embroidered)
        const patternDB = [
            { name:"Solid", priority:1, traits:{lines:"none",shapes:"none",method:"woven"}, desc:"One color only. No pattern.", examples:"Plain tee, blank shirt" },
            { name:"Graphic", priority:1, traits:{lines:"none",shapes:"any",method:"printed"}, desc:"Image/text printed on fabric.", examples:"Band tee, logo shirt, artwork" },
            { name:"Striped", priority:2, traits:{lines:"stripes",shapes:"none",method:"woven"}, desc:"Parallel lines in one direction.", examples:"Sailor stripe, pinstripe, rugby stripe" },
            { name:"Color Block", priority:2, traits:{lines:"none",shapes:"geometric",method:"woven"}, desc:"Large solid color sections sewn together.", examples:"90s windbreaker, panel tee" },
            { name:"Plaid", priority:2, traits:{lines:"grid",shapes:"none",method:"woven"}, desc:"Crossing horizontal + vertical lines.", examples:"Flannel, tartan, buffalo check, gingham" },
            { name:"Tie Dye", priority:2, traits:{lines:"none",shapes:"curved",method:"printed"}, desc:"Swirly, spiral, or burst patterns.", examples:"Spiral tie dye, crinkle, bull's eye" },
            { name:"Camo", priority:3, traits:{lines:"none",shapes:"blobs",method:"printed"}, desc:"Irregular organic blob shapes.", examples:"Military camo, woodland, digital camo" },
            { name:"Embroidered", priority:3, traits:{lines:"none",shapes:"any",method:"stitched"}, desc:"Design stitched onto fabric.", examples:"Logo embroidery, patches, monogram" },
            { name:"Polka Dot", priority:3, traits:{lines:"none",shapes:"dots",method:"printed"}, desc:"Repeated circles/dots pattern.", examples:"Small dots, large dots, scattered dots" },
            { name:"Paisley", priority:3, traits:{lines:"none",shapes:"curved",method:"printed"}, desc:"Curved teardrop/kidney shapes.", examples:"Bandana pattern, western shirts" },
            { name:"Floral", priority:3, traits:{lines:"none",shapes:"curved",method:"printed"}, desc:"Flower and plant designs.", examples:"Hawaiian shirt, rose pattern, vintage blouse" },
            { name:"Animal", priority:3, traits:{lines:"none",shapes:"blobs",method:"printed"}, desc:"Animal print or animal images.", examples:"Leopard, zebra, snake, tiger print" },
            { name:"Geometric", priority:3, traits:{lines:"none",shapes:"geometric",method:"printed"}, desc:"Triangles, squares, abstract shapes.", examples:"80s geometric, aztec, chevron, argyle" },
            { name:"Checkered", priority:3, traits:{lines:"grid",shapes:"none",method:"woven"}, desc:"Simple two-color grid pattern.", examples:"Checkerboard, racing flag pattern" },
            { name:"Houndstooth", priority:3, traits:{lines:"grid",shapes:"geometric",method:"woven"}, desc:"Broken checks with pointed corners.", examples:"Classic houndstooth, oversized tooth" },
            { name:"Herringbone", priority:3, traits:{lines:"stripes",shapes:"geometric",method:"woven"}, desc:"V-shaped zigzag weave pattern.", examples:"Suit fabric, tweed pattern" },
            { name:"Abstract", priority:3, traits:{lines:"none",shapes:"blobs",method:"printed"}, desc:"Random artistic shapes/splashes.", examples:"Paint splatter, 80s abstract, modern art" },
            { name:"Other", priority:4, traits:{lines:"any",shapes:"any",method:"any"}, desc:"Pattern doesn't fit above options.", examples:"Unique, custom, rare patterns" }
        ];

        // V99.45: Tag Location Database - Where to find tags by category
        const tagLocationDB = {
            // TOPS
            "T-Shirt": {
                primary: { location: "Back of neck", desc: "Inside the collar, center back", icon: "👔" },
                secondary: [
                    { location: "Bottom hem (inside)", desc: "70s/80s VINTAGE: Champion, Russell Athletic often have tags sewn inside the bottom hem!", icon: "⭐" },
                    { location: "Left side seam", desc: "Hip/waist area on the left side - common on Y2K and modern tees", icon: "📍" }
                ],
                tips: "70s/80s vintage (Champion, Russell): Check INSIDE the bottom hem! Modern/Y2K: Check side seams. Pre-90s vintage usually ONLY have neck tags."
            },
            "Polo": {
                primary: { location: "Back of neck", desc: "Inside the collar, center back", icon: "👔" },
                secondary: [
                    { location: "Left or right side seam", desc: "Hip/waist area - very common on polos!", icon: "⭐" },
                    { location: "Bottom hem placket", desc: "Inside where the side slit is", icon: "📍" }
                ],
                tips: "ALWAYS check both side seams on polos! Many brands put size/style tags there instead of the neck."
            },
            "Button Shirt": {
                primary: { location: "Back of neck", desc: "Inside the collar, center back", icon: "👔" },
                secondary: [
                    { location: "Inside yoke", desc: "Below the collar seam, inside the back", icon: "📍" },
                    { location: "Bottom front placket", desc: "Inside bottom of the button strip", icon: "📍" },
                    { location: "Side seam", desc: "Hip area, left or right side", icon: "📍" }
                ],
                tips: "Western shirts often have multiple small tags. Dress shirts may have tags at the bottom placket."
            },
            "Flannel": {
                primary: { location: "Back of neck", desc: "Inside the collar, center back", icon: "👔" },
                secondary: [
                    { location: "Inside yoke", desc: "Below the collar seam, inside the back", icon: "📍" },
                    { location: "Side seam", desc: "Hip area, left or right side", icon: "📍" }
                ],
                tips: "Flannel shirts often have tags in the same locations as button-up shirts."
            },
            "Henley": {
                primary: { location: "Back of neck", desc: "Inside the collar, center back", icon: "👔" },
                secondary: [
                    { location: "Left side seam", desc: "Hip/waist area on the left side", icon: "📍" },
                    { location: "Bottom hem (inside)", desc: "Inside the bottom hem", icon: "📍" }
                ],
                tips: "Similar to t-shirts. Check neck first, then side seams."
            },
            "Sweatshirt": {
                primary: { location: "Back of neck", desc: "Inside the collar, center back", icon: "👔" },
                secondary: [
                    { location: "Inside bottom hem/ribbing", desc: "70s/80s VINTAGE: Champion, Russell Athletic often have tags sewn inside the bottom ribbing!", icon: "⭐" },
                    { location: "Left side seam", desc: "Hip/waist area - Champion reverse weave often here", icon: "📍" }
                ],
                tips: "70s/80s vintage: Check INSIDE the bottom ribbing! Champion reverse weave: side seam. Modern Champion: usually neck tag."
            },
            "Hoodie": {
                primary: { location: "Back of neck", desc: "Inside below the hood attachment", icon: "👔" },
                secondary: [
                    { location: "Inside kangaroo pocket", desc: "Check inside the front pouch pocket!", icon: "⭐" },
                    { location: "Inside bottom hem/ribbing", desc: "70s/80s vintage Champion/Russell: inside the bottom ribbing", icon: "⭐" },
                    { location: "Left side seam", desc: "Hip/waist area", icon: "📍" }
                ],
                tips: "70s/80s vintage: Check bottom ribbing! Some brands hide tags inside the kangaroo pocket."
            },
            "Sweater": {
                primary: { location: "Back of neck", desc: "Inside the collar, center back", icon: "👔" },
                secondary: [
                    { location: "Left side seam", desc: "Near the bottom hem", icon: "📍" },
                    { location: "Inside bottom hem", desc: "Folded into the ribbing", icon: "📍" }
                ],
                tips: "High-end sweaters may have very small woven tags. Check carefully at the neck seam."
            },
            "Cardigan": {
                primary: { location: "Back of neck", desc: "Inside the collar, center back", icon: "👔" },
                secondary: [
                    { location: "Inside front facing", desc: "Behind the button placket", icon: "📍" },
                    { location: "Side seam", desc: "Near bottom hem", icon: "📍" }
                ],
                tips: "Button-front cardigans sometimes have tags inside the front facing."
            },
            "Tank Top": {
                primary: { location: "Back of neck", desc: "Inside center back, below the strap", icon: "👔" },
                secondary: [
                    { location: "Left side seam", desc: "Under the arm area", icon: "📍" }
                ],
                tips: "Tank tops often have smaller tags. May be printed directly on the fabric (tagless)."
            },
            "Long Sleeve": {
                primary: { location: "Back of neck", desc: "Inside the collar, center back", icon: "👔" },
                secondary: [
                    { location: "Left side seam", desc: "Hip/waist area", icon: "📍" },
                    { location: "Cuff area", desc: "Inside the sleeve cuff (rare)", icon: "📍" }
                ],
                tips: "Thermal/waffle knits may have tags at the side seam instead of neck."
            },
            // BOTTOMS
            "Jeans": {
                primary: { location: "Back waistband", desc: "Inside center back, below the leather patch", icon: "👖" },
                secondary: [
                    { location: "Inner thigh/inseam", desc: "LEVI'S style - check where legs meet!", icon: "⭐" },
                    { location: "Front waistband", desc: "WRANGLER style - opposite side of zipper fly", icon: "⭐" },
                    { location: "Inside front pocket", desc: "Hidden in the right front pocket", icon: "📍" },
                    { location: "Coin pocket", desc: "Inside the small watch pocket", icon: "📍" }
                ],
                tips: "LEVI'S: Check inner thigh! WRANGLER: Check front waistband! Lee/others: Usually back waistband."
            },
            "Pants": {
                primary: { location: "Back waistband", desc: "Inside center back", icon: "👖" },
                secondary: [
                    { location: "Inside back pocket", desc: "DISCO/POLYESTER pants often here!", icon: "⭐" },
                    { location: "Front waistband", desc: "Near the button/clasp", icon: "📍" },
                    { location: "Inside front pocket", desc: "Hidden in the pocket bag", icon: "📍" }
                ],
                tips: "Vintage polyester/disco pants often have tags in back pockets. Dress pants check all pockets!"
            },
            "Shorts": {
                primary: { location: "Back waistband", desc: "Inside center back", icon: "👖" },
                secondary: [
                    { location: "Inside pocket", desc: "Front or back pocket", icon: "📍" },
                    { location: "Inner thigh", desc: "Side seam near crotch", icon: "📍" }
                ],
                tips: "Athletic shorts may have tags on the inner liner. Swim trunks check the mesh liner."
            },
            "Sweatpants": {
                primary: { location: "Back waistband", desc: "Inside center back", icon: "👖" },
                secondary: [
                    { location: "Inside pocket", desc: "Hidden in the pocket", icon: "📍" },
                    { location: "Left side seam", desc: "Near the hip", icon: "📍" }
                ],
                tips: "Champion and Nike often have side seam tags. Check inside any pockets too."
            },
            // OUTER
            "Jacket": {
                primary: { location: "Inside left chest", desc: "Interior left breast area, sewn to lining", icon: "🧥" },
                secondary: [
                    { location: "Inside front pocket", desc: "Hidden inside a front pocket!", icon: "⭐" },
                    { location: "Inside chest pocket", desc: "Interior breast pocket", icon: "⭐" },
                    { location: "Back of neck", desc: "Inside collar area", icon: "📍" },
                    { location: "Inside hem", desc: "Bottom interior edge", icon: "📍" }
                ],
                tips: "Windbreakers/track jackets: check inside pockets! Denim jackets: usually inside left chest or neck."
            },
            "Coat": {
                primary: { location: "Inside left chest", desc: "Interior left breast area", icon: "🧥" },
                secondary: [
                    { location: "Inside pocket", desc: "Interior breast pocket or side pocket", icon: "⭐" },
                    { location: "Back of neck", desc: "Inside the collar", icon: "📍" },
                    { location: "Inside hem", desc: "Bottom interior, sometimes near vent", icon: "📍" }
                ],
                tips: "Luxury coats may have multiple tags in different locations. Check ALL interior pockets."
            },
            "Vest": {
                primary: { location: "Inside left chest", desc: "Interior left breast area", icon: "🧥" },
                secondary: [
                    { location: "Inside pocket", desc: "Interior pocket", icon: "📍" },
                    { location: "Back of neck", desc: "Inside at the back neckline", icon: "📍" }
                ],
                tips: "Puffer vests often have tags inside pockets. Suit vests check interior left chest."
            },
            "default": {
                primary: { location: "Back of neck OR back waistband", desc: "Standard tag locations", icon: "🏷️" },
                secondary: [
                    { location: "Side seam", desc: "Left or right side at hip level", icon: "📍" },
                    { location: "Inside pocket", desc: "Check all pockets!", icon: "📍" }
                ],
                tips: "When in doubt: neck area for tops, waistband for bottoms, interior chest for outerwear."
            }
        };

        // Debug: Check camera capabilities (call from browser console)
        window.checkCameraCapabilities = async function() {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const videoDevices = devices.filter(d => d.kind === 'videoinput');
            
            for(const device of videoDevices) {
                console.log(`\n📷 ${device.label}`);
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { deviceId: { exact: device.deviceId } }
                    });
                    const track = stream.getVideoTracks()[0];
                    const capabilities = track.getCapabilities();
                    console.log('  Width range:', capabilities.width?.min, '-', capabilities.width?.max);
                    console.log('  Height range:', capabilities.height?.min, '-', capabilities.height?.max);
                    if(capabilities.width?.max >= 3840) console.log('    ✅ 4K (3840x2160)');
                    if(capabilities.width?.max >= 1920) console.log('    ✅ 1080p (1920x1080)');
                    if(capabilities.width?.max >= 1280) console.log('    ✅ 720p (1280x720)');
                    stream.getTracks().forEach(t => t.stop());
                } catch(e) {
                    console.log('  Error:', e.message);
                }
            }
            console.log('\n💡 If 4K is not showing, try: Camera settings app → set to 4K');
        };
        
        // Set version displays everywhere
        function setVersionDisplays() {
            document.title = `VintageLister ${VERSION} - Desktop Station`;
            
            // Pin screen version
            const pinVersion = document.getElementById('pin-version');
            if(pinVersion) pinVersion.textContent = `${VERSION} Desktop Station`;
            
            // Header version badge
            const headerVersion = document.getElementById('header-version');
            if(headerVersion) headerVersion.textContent = VERSION;
        }
        
        document.addEventListener('DOMContentLoaded', () => { 
            debugLog(`VintageLister ${VERSION} starting...`, 'info');
            setVersionDisplays();
            
            // Try to load draft (but don't restore until after PIN)
            const hasDraft = localStorage.getItem(DRAFT_KEY);
            if(hasDraft) debugLog('Draft found in storage', 'info');
            
            checkAuth(); 
            loadStats(); 
            
            debugLog('Starting camera initialization...', 'info');
            enumerateCameras(); 
            
            renderSubCategories('tops'); 
            clearDefectMarkers(); 
            renderFabricCards(); 
            renderMaterialCards(); 
            renderPatternCards(); 
            updateValidation(); 
            
            document.addEventListener('keydown', (e) => { 
                // Spacebar capture
                if (e.code === 'Space' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'SELECT' && !document.getElementById('preview-modal').classList.contains('active')) { 
                    e.preventDefault(); 
                    capturePhoto('spacebar'); 
                }
                // Enter key (common foot pedal binding) - only when not in inputs
                if (e.code === 'Enter' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'SELECT' && e.target.tagName !== 'BUTTON' && !document.getElementById('preview-modal').classList.contains('active')) { 
                    // Only capture if PIN screen is hidden (we're in photo mode)
                    if(document.getElementById('pin-screen').classList.contains('hidden')) {
                        e.preventDefault(); 
                        capturePhoto('footPedal'); 
                    }
                }
            }); 
            document.getElementById('pin-input').addEventListener('keydown', (e) => { if(e.key==='Enter') checkPin(); });
            // Focus PIN input if PIN screen is visible
            if(!document.getElementById('pin-screen').classList.contains('hidden')) {
                document.getElementById('pin-input').focus();
            }
            // Verify feature panel exists
            const featurePanel = document.getElementById('feature-type-panel');
            debugLog(`Feature panel: ${featurePanel ? 'FOUND' : 'NOT FOUND'}`, featurePanel ? 'info' : 'error');
            
            debugLog('App initialized', 'success');
            
            // Add global click tracking for metrics
            document.addEventListener('click', (e) => {
                if(!metrics) return;
                
                const target = e.target;
                const parent = target.closest('[data-track-area]') || target.closest('.section-card');
                
                // Determine click area
                let area = 'other';
                
                if(target.closest('#step-1')) {
                    if(target.closest('.color-btn') || target.closest('.color-section')) area = 'colorPicker';
                    else if(target.closest('[data-track-area="category"]') || target.closest('.hero-btn') || target.closest('.sub-cat-btn')) area = 'category';
                    else area = 'tagSection';
                } else if(target.closest('#step-2')) {
                    if(target.closest('.fabric-card') || target.closest('#fabric-cards-grid') || target.closest('#fabric-other-select')) area = 'fabricType';
                    else if(target.closest('.material-card') || target.closest('#material-cards-grid') || target.closest('#material-other-select')) area = 'material';
                    else if(target.closest('.stitch-btn') || target.closest('.body-btn') || target.closest('.hem-btn')) area = 'construction';
                    else if(target.closest('.defect-btn') || target.closest('.condition-section')) area = 'defects';
                    else area = 'tagSection';
                } else if(target.closest('#step-3')) {
                    if(target.closest('#weight-lb') || target.closest('#weight-oz') || target.closest('.weight-section')) area = 'weight';
                    else if(target.closest('#record-btn') || target.closest('.measurement-section')) area = 'audio';
                    else area = 'other';
                } else if(target.closest('#step-4')) {
                    area = 'navigation';
                } else if(target.closest('.camera-view') || target.closest('.photos-panel')) {
                    if(target.closest('.mode-btn') || target.closest('.shutter-btn')) area = 'photos';
                    else if(target.closest('.nav-btn')) area = 'navigation';
                    else area = 'photos';
                } else if(target.closest('.nav-btn') || target.closest('.progress-dot')) {
                    area = 'navigation';
                }
                
                trackClick(area);
            });
        });
        
        function checkAuth() { 
            // PIN is always required on page load - no auto-login
            // Just restore photographer preference if saved
            try { 
                const savedPhotographer = localStorage.getItem('vl_photographer');
                if(savedPhotographer) {
                    document.getElementById('photographer-select').value = savedPhotographer;
                }
            } catch(e){} 
        }
        function checkPin() { 
            if(document.getElementById('pin-input').value===APP_PIN){ 
                debugLog('PIN correct, logging in...', 'success');
                try{ 
                    data.photographer=document.getElementById('photographer-select').value; 
                    localStorage.setItem('vl_photographer',data.photographer); 
                    document.getElementById('photographer-badge').textContent=data.photographer; 
                }catch(e){} 
                document.getElementById('pin-screen').classList.add('hidden'); 
                
                // Try to load draft after PIN success
                loadDraft();
                
                startTimer(); 
                debugLog('App ready for use', 'success');
            } else { 
                debugLog('Incorrect PIN', 'warn');
                document.getElementById('pin-input').value=''; 
                document.getElementById('pin-input').classList.add('shake'); 
                setTimeout(()=>document.getElementById('pin-input').classList.remove('shake'),300); 
            } 
        }
        function showPinScreen() { document.getElementById('pin-screen').classList.remove('hidden'); document.getElementById('pin-input').value=''; document.getElementById('pin-input').focus(); }
        
        // === SKU FUNCTIONS ===
        let skuLocked = false;
        
        // Reset SKU and focus input in Step 1
        function showSkuGate() {
            skuLocked = false;
            goToStep(1);
            setTimeout(() => {
                const skuInput = document.getElementById('sku-input');
                if(skuInput) {
                    skuInput.value = '';
                    skuInput.style.borderColor = 'var(--color-border)';
                    skuInput.style.background = '';
                    skuInput.focus();
                }
                const checkSku = document.getElementById('check-sku');
                if(checkSku) {
                    checkSku.innerHTML = '○';
                    checkSku.classList.remove('complete');
                }
                const skuStatus = document.getElementById('sku-status');
                if(skuStatus) skuStatus.textContent = '';
            }, 100);
        }
        
        // No-op - kept for compatibility
        function hideSkuGate() {}
        
        function lockSku(value) {
            data.sku = value;
            skuLocked = true;
            
            // Initialize metrics for this item
            initMetrics();
            trackStabilizerWaitStart(); // Start tracking stabilizer wait time
            
            // Update locked badge in progress bar
            document.getElementById('sku-locked-badge').classList.remove('hidden');
            document.getElementById('sku-locked-value').textContent = value;
            
            // Update SKU input in Step 1
            const skuInput = document.getElementById('sku-input');
            if(skuInput) {
                skuInput.value = value;
                skuInput.style.borderColor = 'var(--color-success)';
                skuInput.style.background = '#f0fdf4';
            }
            
            // Update Step 3 display
            const step3Display = document.getElementById('sku-display-step3');
            if(step3Display) step3Display.textContent = value;
            
            // Mark SKU as complete
            document.getElementById('check-sku').innerHTML = '✓';
            document.getElementById('check-sku').classList.add('complete');
            document.getElementById('sku-status').textContent = '✓ SKU set: ' + value;
            document.getElementById('sku-status').style.color = 'var(--color-success)';
            
            // Stop barcode scanning if active
            stopBarcodeScanning();
            
            // Start timer for new item
            startTimer();
            
            showToast('success', 'SKU Set', `Item: ${value}`, 2000);
            updateValidation();
        }
        
        function unlockSku() {
            // Allow editing the SKU - just focus the input
            const skuInput = document.getElementById('sku-input');
            if(skuInput) {
                skuInput.focus();
                skuInput.select();
            }
            skuLocked = false;
        }
        
        // Override onSkuInput to update locked state
        function onSkuInput() { 
            const input = document.getElementById('sku-input');
            const val = input ? input.value.trim() : '';
            data.sku = val;
            
            // Update check circle in Step 1
            const checkSku = document.getElementById('check-sku');
            if(checkSku) {
                if(val && val.length >= 3) {
                    checkSku.innerHTML = '✓';
                    checkSku.classList.add('complete');
                    if(input) {
                        input.style.borderColor = 'var(--color-success)';
                        input.style.background = '#f0fdf4';
                    }
                    document.getElementById('sku-status').textContent = '✓ SKU set: ' + val;
                    document.getElementById('sku-status').style.color = 'var(--color-success)';
                } else {
                    checkSku.innerHTML = '○';
                    checkSku.classList.remove('complete');
                    if(input) {
                        input.style.borderColor = 'var(--color-border)';
                        input.style.background = '';
                    }
                    document.getElementById('sku-status').textContent = val ? 'SKU too short (min 3 chars)' : '';
                    document.getElementById('sku-status').style.color = 'var(--color-text-muted)';
                }
            }
            
            // Update locked badge in header
            if(val) {
                document.getElementById('sku-locked-badge').classList.remove('hidden');
                document.getElementById('sku-locked-value').textContent = val;
            } else {
                document.getElementById('sku-locked-badge').classList.add('hidden');
            }
            
            // Update Step 3 display
            const step3Display = document.getElementById('sku-display-step3');
            if(step3Display) {
                step3Display.textContent = val || '—';
            }
            
            updateValidation();
        }
        
        function focusSkuInput() {
            const input = document.getElementById('sku-input');
            if(input) {
                input.focus();
                input.select();
            }
        }
        
        function goToStep(step) { 
            trackStepChange(step); // Track step change for metrics
            currentStep = step; 
            document.querySelectorAll('.step-container').forEach(s => s.classList.remove('active')); 
            document.getElementById(`step-${step}`).classList.add('active'); 
            document.querySelectorAll('.progress-dot').forEach((d,i) => { 
                d.classList.remove('active'); 
                if(i+1 < step) d.classList.add('complete'); 
                else d.classList.remove('complete'); 
                if(i+1 === step) d.classList.add('active'); 
            }); 
            const labels = {1:'Step 1: Tag', 2:'Step 2: Check', 3:'Step 3: Snap', 4:'Step 4: Review'}; 
            document.getElementById('step-label').textContent = labels[step] || ''; 
            if(step===4) updateReviewCards(); 
            window.scrollTo(0, 0); 
        }
        
        function updateReviewCards() {
            // Construction check depends on superCategory
            const constructionOk = data.superCategory === 'bottoms' ? !!data.legStyle : !!data.sleeveLength;
            const feelOk = !!data.thickness && !!data.layers;
            const conditionOk = data.hasDefects !== null;
            
            document.getElementById('summary-tag').innerHTML = `${data.category||'?'} • ${data.tagSize||'?'}<br>${data.origin==='usa'?'<img src="https://flagcdn.com/w16/us.png" style="vertical-align:middle;"> USA':data.country||''} • ${data.gender||'?'}`;
            
            // Show what's missing in the check summary
            const checkMissing = [];
            if(!data.fabricType) checkMissing.push('fabric');
            if(data.colors.length===0) checkMissing.push('color');
            if(!data.fade) checkMissing.push('FADE');
            if(!data.pattern) checkMissing.push('pattern');
            if(data.materials.length===0) checkMissing.push('material');
            if(!constructionOk) checkMissing.push('construction');
            if(!feelOk) checkMissing.push('feel');
            if(!conditionOk) checkMissing.push('condition');
            
            if(checkMissing.length > 0) {
                document.getElementById('summary-check').innerHTML = `<span style="color:#dc2626;">Missing: ${checkMissing.join(', ')}</span>`;
            } else {
                document.getElementById('summary-check').innerHTML = `${data.fabricType} / ${data.materials.join('+')}<br>${data.colors.slice(0,3).join(', ')} • ${data.fade} • ${data.pattern}`;
            }
            
            const pc = data.mainPhotos.length + data.tagPhotos.length + data.defectPhotos.length;
            document.getElementById('summary-snap').innerHTML = `${pc} photo(s)<br>${data.audioMeasure?'Audio: '+formatTime(data.audioDuration):'No audio'}`;
            document.getElementById('summary-weight').innerHTML = (data.weightLb>0||data.weightOz>0) ? `${data.weightLb} lb ${data.weightOz} oz<br>SKU: ${data.sku||'?'}` : 'No weight';
            
            setCardStatus('tag', !!data.category && !!data.tagStatus);
            setCardStatus('check', !!data.fabricType && data.colors.length>0 && !!data.fade && !!data.pattern && data.materials.length>0 && constructionOk && feelOk && conditionOk);
            setCardStatus('snap', data.mainPhotos.length>0 && !!data.audioMeasure);
            setCardStatus('weight', (data.weightLb>0 || data.weightOz>0) && !!data.sku);
        }
        function setCardStatus(name, ok) { const card = document.getElementById(`card-${name}`); const icon = document.getElementById(`icon-${name}`); card.classList.remove('card-green','card-yellow'); card.classList.add(ok?'card-green':'card-yellow'); icon.textContent = ok?'✅':'⚠️'; }
        
        function startTimer() { timerStart = Date.now(); if (timerInterval) clearInterval(timerInterval); timerInterval = setInterval(updateTimerDisplay, 1000); updateTimerDisplay(); }
        function updateTimerDisplay() { if (!timerStart) return; const elapsed = Math.floor((Date.now() - timerStart) / 1000); document.getElementById('timer-current').textContent = `${Math.floor(elapsed/60)}:${(elapsed%60).toString().padStart(2,'0')}`; }
        function recordItemTime() { if (!timerStart) return; const elapsed = Math.floor((Date.now() - timerStart) / 1000); itemTimes.push(elapsed); document.getElementById('timer-last').textContent = `${Math.floor(elapsed/60)}:${(elapsed%60).toString().padStart(2,'0')}`; const avg = Math.floor(itemTimes.reduce((a,b)=>a+b,0)/itemTimes.length); document.getElementById('timer-avg').textContent = `${Math.floor(avg/60)}:${(avg%60).toString().padStart(2,'0')}`; startTimer(); }
        
        async function enumerateCameras() { 
            debugLog('Starting camera enumeration...', 'info');
            try { 
                // IMPORTANT: Request permission with HIGH resolution to avoid Chrome caching low res
                debugLog('Requesting camera permission...', 'info');
                const permStream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 3840 }, 
                        height: { ideal: 2160 } 
                    }
                }); 
                debugLog('Camera permission granted', 'success');
                
                // Stop permission stream immediately
                permStream.getTracks().forEach(t => t.stop());
                await new Promise(r => setTimeout(r, 300));
                
                const devices = await navigator.mediaDevices.enumerateDevices(); 
                // Filter out virtual cameras (DroidCam, OBS, ManyCam, etc.)
                const videoDevices = devices.filter(d => {
                    if(d.kind !== 'videoinput') return false;
                    const label = (d.label || '').toLowerCase();
                    const virtualCameras = ['droidcam', 'obs', 'manycam', 'virtual', 'snap camera', 'xsplit', 'streamlabs', 'camo', 'usb video device'];
                    return !virtualCameras.some(v => label.includes(v));
                });
                const select = document.getElementById('camera-select'); 
                select.innerHTML = '<option value="">Select Camera...</option>'; 
                
                debugLog(`Found ${videoDevices.length} cameras`, 'info');
                
                videoDevices.forEach((device,i)=>{ 
                    const option = document.createElement('option'); 
                    option.value = device.deviceId; 
                    option.textContent = device.label || `Camera ${i+1}`; 
                    select.appendChild(option);
                    
                    debugLog(`  ${i+1}. ${device.label}`, 'info');
                    
                    // Categorize cameras
                    const label = device.label.toLowerCase();
                    if((label.includes('arducam') || label.includes('brio')) && !mainCameraId) {
                        mainCameraId = device.deviceId;
                        mainCameraName = device.label; // Store for metrics
                        debugLog('  → Set as MAIN camera', 'success');
                    } else if((label.includes('c922') || label.includes('922')) && !secondaryCameraId) {
                        secondaryCameraId = device.deviceId;
                        secondaryCameraName = device.label; // Store for metrics
                        debugLog('  → Set as SECONDARY camera', 'success');
                    }
                });
                
                // Always start camera immediately (no SKU gate blocking)
                if(mainCameraId) {
                    select.value = mainCameraId;
                    debugLog('Starting main camera...', 'info');
                    try {
                        // Use regular switchCamera first (more reliable), then force full res
                        await switchCamera(mainCameraId);
                        debugLog('Main camera started', 'success');
                        // Auto-trigger full resolution after camera is stable
                        setTimeout(() => {
                            debugLog('Auto-triggering FULL RES...', 'info');
                            forceMaxResolution();
                        }, 1500);
                    } catch(camErr) {
                        debugLog(`Failed to start main camera: ${camErr.message}`, 'error');
                        showToast('error', 'Camera Error', 'Could not start camera');
                    }
                } else if(videoDevices.length > 0) {
                    // Fallback to first camera
                    debugLog('No Arducam found, using first camera', 'warn');
                    mainCameraId = videoDevices[0].deviceId;
                    select.value = mainCameraId;
                    await switchCamera(mainCameraId);
                } else {
                    debugLog('NO CAMERAS FOUND!', 'error');
                    showToast('error', 'No Cameras', 'No cameras detected. Check connections.');
                }
                
                updateCameraIndicator();
                
                // Enable defect marking since we start in main mode
                if(photoMode === 'main') {
                    enableDefectMarking();
                    debugLog('Defect marking enabled', 'info');
                }
            } catch(err) { 
                debugLog(`Camera enumeration error: ${err.message}`, 'error');
                showToast('error', 'Camera Error', err.message);
            } 
        }
        function applyFlipTransform() {
            const video = document.getElementById('camera-video');
            if(!video) return;
            
            // Determine if current camera needs flipping or rotation
            let needsFlip = false;
            let needsRot = false;
            
            if(activeCameraId) {
                needsFlip = cameraConfig.flips && cameraConfig.flips[activeCameraId];
                needsRot = cameraConfig.rots && cameraConfig.rots[activeCameraId];
            }
            
            // Remove existing transform classes
            video.classList.remove('camera-flipped', 'camera-rotated-90');
            
            // Apply transforms
            if(needsFlip) {
                video.classList.add('camera-flipped');
                console.log('📷 Applied 180° flip to camera');
            }
            if(needsRot) {
                video.classList.add('camera-rotated-90');
                console.log('📷 Applied 90° rotation to camera');
            }
        }
        
        // Check if current camera is configured to be flipped
        function isCameraFlipped() {
            return activeCameraId && cameraConfig.flips && cameraConfig.flips[activeCameraId];
        }
        
        // Check if current camera is configured to be rotated 90°
        function isCameraRotated90() {
            return activeCameraId && cameraConfig.rots && cameraConfig.rots[activeCameraId];
        }
        
        // Draw video to canvas, applying flip if needed
        function drawVideoToCanvas(ctx, video, dx, dy, dw, dh, sx, sy, sw, sh) {
            if(isCameraFlipped()) {
                // Save state, rotate 180°, draw, restore
                ctx.save();
                ctx.translate(dx + dw, dy + dh);
                ctx.rotate(Math.PI);
                if(sw !== undefined) {
                    ctx.drawImage(video, sx, sy, sw, sh, 0, 0, dw, dh);
                } else {
                    ctx.drawImage(video, 0, 0, dw, dh);
                }
                ctx.restore();
            } else {
                // Normal draw
                if(sw !== undefined) {
                    ctx.drawImage(video, sx, sy, sw, sh, dx, dy, dw, dh);
                } else {
                    ctx.drawImage(video, dx, dy, dw, dh);
                }
            }
        }
        
        // V99.45: Aggressive max resolution switch for main camera
        async function switchCameraMaxRes(deviceId) {
            if(!deviceId) return;
            
            console.log('📷 switchCameraMaxRes: Forcing max resolution...');
            const video = document.getElementById('camera-video');
            video.classList.add('switching');
            
            // Stop everything first
            stopStabilizer();
            if(currentStream) {
                currentStream.getTracks().forEach(t => t.stop());
                currentStream = null;
            }
            
            // Longer delay for camera to fully release
            await new Promise(r => setTimeout(r, 500));
            
            // Try Arducam 48MP max resolution first, then fall back
            const resolutions = [
                { w: 8000, h: 6000, name: '48MP (Arducam Max)' },
                { w: 4096, h: 2160, name: '4K DCI' },
                { w: 3840, h: 2160, name: '4K UHD' },
                { w: 2560, h: 1440, name: '1440p' },
                { w: 1920, h: 1080, name: '1080p' },
                { w: 1280, h: 720, name: '720p' }
            ];
            
            for(const res of resolutions) {
                try {
                    console.log(`📷 Trying ${res.name} (${res.w}x${res.h})...`);
                    
                    // Use EXACT constraint - this forces the resolution or fails
                    currentStream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            deviceId: { exact: deviceId },
                            width: { exact: res.w },
                            height: { exact: res.h }
                        }
                    });
                    
                    const track = currentStream.getVideoTracks()[0];
                    const settings = track.getSettings();
                    console.log(`✅ Got ${settings.width}x${settings.height}`);
                    
                    video.srcObject = currentStream;
                    video.style.display = 'block';
                    document.getElementById('camera-placeholder').style.display = 'none';
                    document.getElementById('camera-overlay').style.display = 'block';
                    document.getElementById('camera-status').textContent = 'LIVE';
                    document.getElementById('camera-status').classList.add('live');
                    activeCameraId = deviceId;
                    document.getElementById('camera-select').value = deviceId;
                    
                    // Apply flip transform if configured
                    applyFlipTransform();
                    
                    video.onloadedmetadata = () => {
                        const w = video.videoWidth;
                        const h = video.videoHeight;
                        console.log(`📷 Video ready: ${w}x${h}`);
                        document.getElementById('camera-resolution').textContent = `${w}×${h}`;
                        
                        const resEl = document.getElementById('camera-resolution');
                        if(w >= 3800) {
                            resEl.style.color = '#22c55e';
                        } else if(w >= 1900) {
                            resEl.style.color = '#3b82f6';
                        } else if(w >= 1200) {
                            resEl.style.color = '#f59e0b';
                        } else {
                            resEl.style.color = '#ef4444';
                        }
                        
                        video.classList.remove('switching');
                        
                        // Update defect layer and markers for main mode
                        if(photoMode === 'main') {
                            setTimeout(() => {
                                updateDefectLayerPosition();
                                renderDefectMarkers();
                                enableDefectMarking();
                            }, 100);
                        }
                        
                        setTimeout(() => startStabilizer(), 200);
                    };
                    
                    updateCameraIndicator();
                    return; // Success!
                    
                } catch(err) {
                    console.log(`❌ ${res.name} failed: ${err.message}`);
                    if(currentStream) {
                        currentStream.getTracks().forEach(t => t.stop());
                        currentStream = null;
                    }
                    await new Promise(r => setTimeout(r, 200));
                }
            }
            
            // All exact resolutions failed - fall back to ideal constraints
            console.log('⚠️ Exact constraints failed, trying ideal...');
            await switchCamera(deviceId);
        }
        
        // Force maximum resolution by restarting camera with strict constraints
        async function forceMaxResolution() {
            if(!activeCameraId) {
                showToast('warning', 'No Camera', 'Select a camera first');
                return;
            }
            
            console.log('🔄 FULL RES: Forcing maximum resolution...');
            document.getElementById('camera-resolution').textContent = 'Switching...';
            document.getElementById('camera-resolution').style.color = '#f59e0b';
            
            const video = document.getElementById('camera-video');
            
            // Stop current stream completely
            if(currentStream) {
                currentStream.getTracks().forEach(t => t.stop());
                currentStream = null;
            }
            
            // Wait for camera to fully release
            await new Promise(r => setTimeout(r, 500));
            
            // Get max capabilities
            let maxWidth = 1920, maxHeight = 1080;
            try {
                const tempStream = await navigator.mediaDevices.getUserMedia({
                    video: { deviceId: { exact: activeCameraId } }
                });
                const track = tempStream.getVideoTracks()[0];
                const capabilities = track.getCapabilities();
                
                if(capabilities.width?.max) maxWidth = capabilities.width.max;
                if(capabilities.height?.max) maxHeight = capabilities.height.max;
                
                console.log(`📷 FULL RES: Max capability: ${maxWidth}x${maxHeight}`);
                tempStream.getTracks().forEach(t => t.stop());
                await new Promise(r => setTimeout(r, 300));
            } catch(e) {
                console.log('📷 FULL RES: Could not get capabilities, trying defaults');
            }
            
            // Now request EXACT max resolution
            try {
                const constraints = {
                    video: {
                        deviceId: { exact: activeCameraId },
                        width: { ideal: maxWidth, min: Math.min(maxWidth, 1920) },
                        height: { ideal: maxHeight, min: Math.min(maxHeight, 1080) }
                    }
                };
                
                console.log(`📷 FULL RES: Requesting ${maxWidth}x${maxHeight}...`);
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                video.srcObject = currentStream;
                video.style.display = 'block';
                document.getElementById('camera-placeholder').style.display = 'none';
                document.getElementById('camera-overlay').style.display = 'block';
                document.getElementById('camera-status').textContent = 'LIVE';
                document.getElementById('camera-status').classList.add('live');
                
                video.onloadedmetadata = () => {
                    const actualW = video.videoWidth;
                    const actualH = video.videoHeight;
                    console.log(`✅ FULL RES: Got ${actualW}x${actualH}`);
                    document.getElementById('camera-resolution').textContent = `${actualW}×${actualH}`;
                    
                    // Update defect layer for main mode
                    if(photoMode === 'main') {
                        setTimeout(() => {
                            updateDefectLayerPosition();
                            renderDefectMarkers();
                            enableDefectMarking();
                        }, 100);
                    }
                    
                    if(actualW >= 3800) {
                        document.getElementById('camera-resolution').style.color = '#22c55e';
                        showToast('success', '4K Resolution Active', `${actualW}×${actualH} - Full quality for AI processing`);
                    } else if(actualW >= 1900) {
                        document.getElementById('camera-resolution').style.color = '#3b82f6';
                        showToast('info', '1080p Resolution', `${actualW}×${actualH} - Good quality`, 3000);
                    } else {
                        document.getElementById('camera-resolution').style.color = '#ef4444';
                        showToast('warning', 'Low Resolution', `${actualW}×${actualH} - Check USB 3.0 port`, 5000);
                    }
                };
                
            } catch(err) {
                console.error('📷 FULL RES: Failed:', err);
                showToast('error', 'Resolution Error', err.message);
                // Fall back to normal switch
                switchCamera(activeCameraId);
            }
        }
        
        // ============ DEFECT LAYER POSITIONING ============
        
        // Position defect layer to match actual video display area
        function updateDefectLayerPosition() {
            const video = document.getElementById('camera-video');
            const container = document.querySelector('.camera-view-container');
            const layer = document.getElementById('defect-markers-layer');
            
            if(!container || !layer || !video) return;
            
            const containerW = container.clientWidth;
            const containerH = container.clientHeight;
            const videoW = video.videoWidth || 1920;
            const videoH = video.videoHeight || 1080;
            
            // Video uses object-fit: contain, calculate actual display area
            const videoAspect = videoW / videoH;
            const containerAspect = containerW / containerH;
            
            let displayedW, displayedH, offsetX, offsetY;
            
            if(videoAspect > containerAspect) {
                // Video is wider - letterbox top/bottom
                displayedW = containerW;
                displayedH = containerW / videoAspect;
                offsetX = 0;
                offsetY = (containerH - displayedH) / 2;
            } else {
                // Video is taller - letterbox left/right
                displayedH = containerH;
                displayedW = containerH * videoAspect;
                offsetX = (containerW - displayedW) / 2;
                offsetY = 0;
            }
            
            // Position defect layer to match actual video display area
            // Note: Don't rotate layer - we transform marker positions instead
            layer.style.position = 'absolute';
            layer.style.width = displayedW + 'px';
            layer.style.height = displayedH + 'px';
            layer.style.left = offsetX + 'px';
            layer.style.top = offsetY + 'px';
            layer.style.zIndex = '5';
            layer.style.transform = '';
            layer.style.transformOrigin = '';
        }
        
        // Update on window resize
        window.addEventListener('resize', () => {
            updateDefectLayerPosition();
            if(defectMarkers.length > 0) {
                renderDefectMarkers();
            }
        });
        
        // ============ ZOOM FUNCTIONS ============
        let currentZoom = 1.0;
        
        function resetZoom() {
            currentZoom = 1.0;
            updateDefectLayerPosition();
        }
        
        async function switchCamera(deviceId) { 
            if(!deviceId) {
                debugLog('switchCamera called with no deviceId!', 'error');
                return; 
            }
            
            debugLog(`Switching to camera: ${deviceId.slice(0,8)}...`, 'info');
            
            const video = document.getElementById('camera-video');
            if(!video) {
                debugLog('Video element not found!', 'error');
                return;
            }
            
            // Add switching class for smooth transition
            video.classList.add('switching');
            
            // Stop stabilizer first
            stopStabilizer();
            
            // Reset zoom when switching cameras
            resetZoom();
            
            // Stop current stream first
            if(currentStream) {
                debugLog('Stopping current stream...', 'info');
                currentStream.getTracks().forEach(t=>t.stop()); 
                currentStream = null;
            }
            
            // Small delay to let camera release
            await new Promise(r => setTimeout(r, 200));
            
            // STEP 1: Get camera capabilities first
            let maxWidth = 1920, maxHeight = 1080;
            try {
                debugLog('Getting camera capabilities...', 'info');
                const tempStream = await navigator.mediaDevices.getUserMedia({
                    video: { deviceId: { exact: deviceId } }
                });
                const track = tempStream.getVideoTracks()[0];
                const capabilities = track.getCapabilities();
                
                if(capabilities.width?.max) maxWidth = capabilities.width.max;
                if(capabilities.height?.max) maxHeight = capabilities.height.max;
                
                debugLog(`Camera max: ${maxWidth}x${maxHeight}`, 'info');
                tempStream.getTracks().forEach(t => t.stop());
                await new Promise(r => setTimeout(r, 100));
            } catch(e) {
                debugLog(`Could not get capabilities: ${e.message}`, 'warn');
            }
            
            // STEP 2: Request the MAXIMUM resolution with exact/min constraints
            const isMainCamera = deviceId === mainCameraId;
            let success = false;
            
            // Try exact max resolution first, then fall back
            const resolutions = [];
            
            if(maxWidth >= 3840) {
                resolutions.push({ width: 3840, height: 2160, name: '4K' });
            }
            if(maxWidth >= 1920) {
                resolutions.push({ width: 1920, height: 1080, name: '1080p' });
            }
            resolutions.push({ width: 1280, height: 720, name: '720p' });
            resolutions.push({ width: 640, height: 480, name: '480p' });
            
            debugLog(`Trying ${resolutions.length} resolutions...`, 'info');
            
            for(const res of resolutions) {
                try {
                    debugLog(`Trying ${res.name}...`, 'info');
                    
                    // Use 'min' to FORCE at least this resolution, 'ideal' for target
                    const constraints = {
                        video: {
                            deviceId: { exact: deviceId },
                            width: { min: res.width, ideal: res.width },
                            height: { min: res.height, ideal: res.height }
                        }
                    };
                    
                    currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    // Verify we got what we asked for
                    const track = currentStream.getVideoTracks()[0];
                    const settings = track.getSettings();
                    debugLog(`Got stream: ${settings.width}x${settings.height}`, 'success');
                    
                    // Check if resolution is acceptable
                    if(settings.width < res.width * 0.9) {
                        debugLog(`Resolution too low, trying next...`, 'warn');
                        currentStream.getTracks().forEach(t => t.stop());
                        currentStream = null;
                        continue;
                    }
                    
                    video.srcObject = currentStream; 
                    video.style.display = 'block'; 
                    document.getElementById('camera-placeholder').style.display = 'none'; 
                    document.getElementById('camera-overlay').style.display = 'block'; 
                    document.getElementById('camera-status').textContent = 'LIVE'; 
                    document.getElementById('camera-status').classList.add('live'); 
                    activeCameraId = deviceId;
                    document.getElementById('camera-select').value = deviceId;
                    
                    // Apply flip transform if configured
                    applyFlipTransform();
                    
                    video.onloadedmetadata = () => {
                        debugLog(`Video ready: ${video.videoWidth}x${video.videoHeight}`, 'success');
                        document.getElementById('camera-resolution').textContent = `${video.videoWidth}×${video.videoHeight}`;
                        
                        // Color code resolution
                        const resEl = document.getElementById('camera-resolution');
                        if(video.videoWidth >= 3800) {
                            resEl.style.color = '#22c55e'; // Green for 4K
                        } else if(video.videoWidth >= 1900) {
                            resEl.style.color = '#3b82f6'; // Blue for 1080p
                        } else if(video.videoWidth >= 1200) {
                            resEl.style.color = '#f59e0b'; // Orange for 720p
                        } else {
                            resEl.style.color = '#ef4444'; // Red for low res
                        }
                        
                        setTimeout(() => video.classList.remove('switching'), 50);
                        
                        // Update defect layer for main mode
                        if(photoMode === 'main') {
                            setTimeout(() => {
                                updateDefectLayerPosition();
                                renderDefectMarkers();
                                enableDefectMarking();
                            }, 100);
                        }
                        
                        // Start stabilizer after video is ready
                        stopStabilizer();
                        setTimeout(() => startStabilizer(), 200);
                    };
                    
                    updateCameraIndicator();
                    success = true;
                    break;
                    
                } catch(err) {
                    debugLog(`${res.name} failed: ${err.message}`, 'warn');
                }
            }
            
            if(!success) {
                // Last resort: let browser pick any resolution
                debugLog('Fallback: letting browser choose resolution...', 'warn');
                try {
                    currentStream = await navigator.mediaDevices.getUserMedia({
                        video: { deviceId: { exact: deviceId } }
                    });
                    video.srcObject = currentStream;
                    video.style.display = 'block';
                    document.getElementById('camera-placeholder').style.display = 'none';
                    document.getElementById('camera-overlay').style.display = 'block';
                    document.getElementById('camera-status').textContent = 'LIVE';
                    document.getElementById('camera-status').classList.add('live');
                    activeCameraId = deviceId;
                    document.getElementById('camera-select').value = deviceId;
                    
                    // Apply flip transform if configured
                    applyFlipTransform();
                    
                    video.onloadedmetadata = () => {
                        debugLog(`Fallback resolution: ${video.videoWidth}x${video.videoHeight}`, 'warn');
                        document.getElementById('camera-resolution').textContent = `${video.videoWidth}×${video.videoHeight}`;
                        document.getElementById('camera-resolution').style.color = '#ef4444';
                        video.classList.remove('switching');
                        
                        // Update defect layer for main mode
                        if(photoMode === 'main') {
                            setTimeout(() => {
                                updateDefectLayerPosition();
                                renderDefectMarkers();
                                enableDefectMarking();
                            }, 100);
                        }
                        
                        // Start stabilizer after video is ready
                        stopStabilizer();
                        setTimeout(() => startStabilizer(), 200);
                    };
                    updateCameraIndicator();
                    success = true;
                } catch(err2) {
                    debugLog(`All camera attempts failed: ${err2.message}`, 'error');
                    showToast('error', 'Camera Error', err2.message);
                    video.classList.remove('switching');
                }
            }
            
            debugLog(`Camera switch ${success ? 'SUCCESS' : 'FAILED'}`, success ? 'success' : 'error');
        }
        
        async function setPhotoMode(mode) { 
            debugLog(`setPhotoMode: ${mode}`, 'info');
            
            const previousMode = photoMode;
            trackModeChange(mode); // Track mode change for metrics
            photoMode = mode; 
            document.querySelectorAll('.mode-btn').forEach(b=>b.classList.remove('active')); 
            const modeBtn = document.getElementById(`mode-${mode}`);
            if(modeBtn) modeBtn.classList.add('active'); 
            
            const video = document.getElementById('camera-video');
            const singleView = document.getElementById('single-camera-view');
            const splitView = document.getElementById('split-defect-view');
            
            // Hide split view by default and stop split camera if running
            splitView.style.display = 'none';
            singleView.style.display = 'flex';
            if(previousMode === 'defect-closeup' && mode !== 'defect-closeup') {
                stopSplitCameraFeed();
            }
            
            if(mode === 'main') {
                // Enable defect marking in main mode
                enableDefectMarking();
                // Show shot sequence hint
                updateShotHint();
                const hintEl = document.getElementById('shot-hint');
                if(hintEl) hintEl.style.display = 'block';
            } else {
                video.style.transform = ''; // Clear transform
                disableDefectMarking();
                // Hide shot sequence hint for other modes
                const hintEl = document.getElementById('shot-hint');
                if(hintEl) hintEl.style.display = 'none';
            }
            
            // Reset zoom when switching modes
            resetZoom();
            
            // Track camera switch start time
            const previousCameraId = activeCameraId;
            
            // Auto-switch cameras based on mode
            if(mode === 'main') {
                // Single camera mode
                video.style.display = 'block';
                
                // Reset and show defect layer
                resetDefectLayerStyles();
                document.getElementById('defect-markers-layer').style.display = 'block';
                
                if(mainCameraId) {
                    console.log(`📷 Main mode: checking if need to switch (active=${activeCameraId?.slice(0,8)}, target=${mainCameraId?.slice(0,8)})`);
                    if(activeCameraId !== mainCameraId) {
                        console.log('📷 SWITCHING to MAIN camera (ARDUCAM)...');
                        trackCameraSwitch(previousCameraId, mainCameraId); // Start tracking switch
                        try {
                            await switchCameraMaxRes(mainCameraId);
                            trackCameraSwitchComplete(previousCameraId, mainCameraId); // Complete tracking
                            console.log('📷 Switch to ARDUCAM complete');
                            setTimeout(() => {
                                forceMaxResolution();
                                enableDefectMarking();
                            }, 500);
                        } catch(e) {
                            console.error('📷 Switch to ARDUCAM failed:', e);
                        }
                    } else {
                        console.log('📷 Already on MAIN camera - forcing max resolution');
                        setTimeout(() => {
                            forceMaxResolution();
                            updateDefectLayerPosition();
                            renderDefectMarkers();
                            enableDefectMarking();
                        }, 100);
                    }
                } else {
                    console.warn('⚠️ mainCameraId not set');
                }
            } else if(mode === 'defect-closeup') {
                // SPLIT SCREEN MODE for defect closeups
                singleView.style.display = 'none';
                splitView.style.display = 'flex';
                
                // Render main photo with defect dots
                renderSplitDefectView();
                
                // Start secondary camera in split view
                if(secondaryCameraId) {
                    await startSplitCameraFeed(secondaryCameraId);
                } else if(mainCameraId) {
                    await startSplitCameraFeed(mainCameraId);
                    showToast('warning', 'No C922X Found', 'Using main camera', 2000);
                }
            } else if(mode === 'tag' || mode === 'defect' || mode === 'features') {
                // Reset and show defect layer (though it won't be active in these modes)
                resetDefectLayerStyles();
                document.getElementById('defect-markers-layer').style.display = 'block';
                document.getElementById('camera-placeholder').style.display = 'none';
                video.style.display = 'block';
                
                if(secondaryCameraId) {
                    console.log(`📷 ${mode} mode: switching to secondary camera`);
                    
                    if(activeCameraId !== secondaryCameraId) {
                        console.log('📷 SWITCHING to SECONDARY camera (C922X)...');
                        trackCameraSwitch(previousCameraId, secondaryCameraId); // Start tracking switch
                        try {
                            await switchCamera(secondaryCameraId);
                            trackCameraSwitchComplete(previousCameraId, secondaryCameraId); // Complete tracking
                            console.log('📷 Switch to C922X complete');
                        } catch(e) {
                            console.error('📷 Switch to C922X failed:', e);
                            showToast('error', 'Camera Switch Failed', e.message, 3000);
                        }
                    } else {
                        console.log('📷 Already on SECONDARY camera');
                    }
                } else {
                    console.warn('⚠️ No secondary camera (C922X) detected - using main camera');
                    showToast('warning', 'No C922X Found', 'Using main camera for close-ups', 3000);
                    if(mainCameraId && activeCameraId !== mainCameraId) {
                        try {
                            await switchCamera(mainCameraId);
                        } catch(e) {
                            console.error('📷 Fallback to main camera failed:', e);
                        }
                    }
                }
            }
            
            // Always update camera indicator after mode change
            updateCameraIndicator();
            
            // Update selection panels based on mode
            updateDefectLinkPanel();
            updateFeatureTypePanel();
            updateDetailTypePanel();
        }
        
        function updateCameraIndicator() {
            const indicator = document.getElementById('camera-indicator');
            if(!indicator) return;
            if(activeCameraId === mainCameraId) {
                indicator.textContent = '📦 ARDUCAM 48MP (Main)';
                indicator.style.background = '#3b82f6';
            } else if(activeCameraId === secondaryCameraId) {
                if(photoMode === 'defect-closeup') {
                    indicator.textContent = '🔴 C922X (Defect Close-up)';
                    indicator.style.background = '#dc2626';
                } else if(photoMode === 'features') {
                    indicator.textContent = '✨ C922X (Feature Close-up)';
                    indicator.style.background = '#7c3aed';
                } else {
                    indicator.textContent = '🏷️ C922X (Tag)';
                    indicator.style.background = '#f59e0b';
                }
            } else {
                indicator.textContent = 'Camera';
                indicator.style.background = '#64748b';
            }
        }
        // Track last capture method for metrics
        let lastCaptureMethod = 'shutterClick';
        
        function capturePhoto(method = 'shutterClick') { 
            lastCaptureMethod = method;
            
            // Use split camera video in defect-closeup mode, otherwise main video
            const video = photoMode === 'defect-closeup' 
                ? document.getElementById('split-camera-video')
                : document.getElementById('camera-video'); 
            if(!video || !video.srcObject) {
                showToast('warning', 'No Camera', 'Camera not ready', 2000);
                return; 
            }
            
            // Capture current stability metrics before taking photo
            const stabilityScore = currentMotionDelta || 0;
            const wasStable = isStable;
            const waitSeconds = getStabilizerWaitTime();
            const cameraName = activeCameraId === mainCameraId ? 
                (metrics?.hardware?.primaryCamera?.name || 'Primary') : 
                (metrics?.hardware?.secondaryCamera?.name || 'Secondary');
            
            // Track photo capture in metrics
            trackPhotoCapture(photoMode, cameraName, method, stabilityScore, wasStable, waitSeconds);
            
            // Reset stabilizer wait tracking for next photo
            trackStabilizerWaitStart();
            
            // Warn if not stable but still allow capture
            if(!isStable && navigator.vibrate) navigator.vibrate(100);
            
            // Check resolution before capture
            if(video.videoWidth < 1280) {
                console.error(`⚠️ LOW RESOLUTION CAPTURE: ${video.videoWidth}x${video.videoHeight}`);
                showToast('warning', 'Low Resolution', `Capturing at ${video.videoWidth}x${video.videoHeight}`, 3000);
            }
            
            // Flash effect
            document.getElementById('flash-overlay').classList.add('flash'); 
            setTimeout(()=>document.getElementById('flash-overlay').classList.remove('flash'),100); 
            
            const sourceW = video.videoWidth;
            const sourceH = video.videoHeight;
            
            if(photoMode === 'main') {
                // MAIN PHOTOS: Handle defect markers if any
                captureMainWithDefects(video, sourceW, sourceH);
            } else {
                // TAG/DEFECTS/SKU: Square 1:1 ratio (center crop)
                const canvas = document.createElement('canvas'); 
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                
                const isFlipped = isCameraFlipped();
                const isRotated = isCameraRotated90();
                
                // If rotated 90°, swap dimensions for crop calculation
                const effectiveW = isRotated ? sourceH : sourceW;
                const effectiveH = isRotated ? sourceW : sourceH;
                
                const size = Math.min(effectiveW, effectiveH);
                const cropX = Math.round((effectiveW - size) / 2);
                const cropY = Math.round((effectiveH - size) / 2);
                
                canvas.width = size;
                canvas.height = size;
                
                // Handle transforms
                ctx.save();
                if(isRotated) {
                    // Rotate 90° CW, then draw
                    ctx.translate(size/2, size/2);
                    ctx.rotate(Math.PI / 2);
                    ctx.translate(-size/2, -size/2);
                    
                    // Recalculate crop for rotated source
                    const rotCropX = Math.round((sourceW - size) / 2);
                    const rotCropY = Math.round((sourceH - size) / 2);
                    
                    if(isFlipped) {
                        ctx.translate(size, size);
                        ctx.rotate(Math.PI);
                    }
                    ctx.drawImage(video, rotCropY, rotCropX, size, size, 0, 0, size, size);
                } else if(isFlipped) {
                    ctx.translate(size, size);
                    ctx.rotate(Math.PI);
                    ctx.drawImage(video, cropX, cropY, size, size, 0, 0, size, size);
                } else {
                    ctx.drawImage(video, cropX, cropY, size, size, 0, 0, size, size);
                }
                ctx.restore();
                
                console.log(`📸 ${photoMode.toUpperCase()} Square: ${sourceW}x${sourceH} → ${canvas.width}x${canvas.height} (flip:${isFlipped}, rot:${isRotated})`);
                
                // Maximum JPEG quality (0.95) for best detail preservation
                canvas.toBlob(blob => { 
                    const photo = { 
                        blob, 
                        url: URL.createObjectURL(blob), 
                        width: canvas.width, 
                        height: canvas.height 
                    }; 
                    if(photoMode === 'tag') {
                        data.tagPhotos.push(photo);
                        // Auto-save to folder if selected
                        if(saveDirectoryHandle) {
                            const filename = generatePhotoFilename('tag', data.tagPhotos.length);
                            savePhotoToFolder(blob, filename);
                        }
                        showToast('success', `Tag Photo ${data.tagPhotos.length}`, `${canvas.width}×${canvas.height}`, 1500);
                        
                        // AI Analysis - analyze first tag photo
                        if(data.tagPhotos.length === 1) {
                            analyzeTagWithAI(blob);
                        }
                    }
                    else if(photoMode === 'defect-closeup') {
                        // Add linked defect info from visual picker
                        if(selectedDefectForCloseup) {
                            photo.linkedDefect = {
                                photoIndex: selectedDefectForCloseup.photoIndex,
                                defectIndex: selectedDefectForCloseup.defectIndex,
                                type: selectedDefectForCloseup.type,
                                x: selectedDefectForCloseup.x,
                                y: selectedDefectForCloseup.y
                            };
                        }
                        data.defectCloseupPhotos.push(photo);
                        // Auto-save to folder if selected
                        if(saveDirectoryHandle) {
                            const filename = generatePhotoFilename('defect-closeup', data.defectCloseupPhotos.length);
                            savePhotoToFolder(blob, filename);
                        }
                        const linkText = selectedDefectForCloseup ? ` → #${selectedDefectForCloseup.defectIndex + 1} ${selectedDefectForCloseup.type.toUpperCase()}` : '';
                        showToast('success', `🔴 Defect Close-up ${data.defectCloseupPhotos.length}${linkText}`, `${canvas.width}×${canvas.height}`, 1500);
                    }
                    else if(photoMode === 'features') {
                        // Add feature type if selected
                        photo.featureType = selectedFeatureType || null;
                        data.featuresPhotos.push(photo);
                        // Auto-save to folder if selected
                        if(saveDirectoryHandle) {
                            const filename = generatePhotoFilename('feature', data.featuresPhotos.length);
                            savePhotoToFolder(blob, filename);
                        }
                        const typeText = selectedFeatureType ? ` (${selectedFeatureType})` : '';
                        showToast('success', `✨ Feature Close-up ${data.featuresPhotos.length}${typeText}`, `${canvas.width}×${canvas.height}`, 1500);
                    }
                    else {
                        data.defectPhotos.push(photo);
                        // Auto-save to folder if selected
                        if(saveDirectoryHandle) {
                            const filename = generatePhotoFilename('defect', data.defectPhotos.length);
                            savePhotoToFolder(blob, filename);
                        }
                        showToast('success', `Defect Photo ${data.defectPhotos.length}`, `${canvas.width}×${canvas.height}`, 1500);
                    }
                    
                    const sizeMB = (blob.size / 1024 / 1024).toFixed(2);
                    console.log(`📸 ${photoMode.toUpperCase()}: ${canvas.width}×${canvas.height} | ${sizeMB}MB`);
                    
                    updatePhotoGrids(); 
                    updateValidation(); 
                }, 'image/jpeg', 0.95); 
            }
        }
        
        
        function captureMainWithDefects(video, sourceW, sourceH) {
            const isFlipped = isCameraFlipped();
            const isRotated = isCameraRotated90();
            
            // Calculate final output dimensions
            let outputW, outputH;
            
            if(isRotated) {
                // Hardware rotation swaps dimensions
                outputW = sourceH;
                outputH = sourceW;
            } else {
                outputW = sourceW;
                outputH = sourceH;
            }
            
            // Portrait mode swaps again
            if(mainPhotoPortrait) {
                const temp = outputW;
                outputW = outputH;
                outputH = temp;
            }
            
            const mainCanvas = document.createElement('canvas');
            const ctx = mainCanvas.getContext('2d');
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            mainCanvas.width = outputW;
            mainCanvas.height = outputH;
            
            ctx.save();
            
            // Move to center for rotation
            ctx.translate(outputW/2, outputH/2);
            
            // Apply rotations
            let totalRotation = 0;
            if(isRotated) totalRotation += Math.PI / 2;  // 90° for hardware
            if(mainPhotoPortrait) totalRotation += Math.PI / 2;  // 90° for portrait
            if(isFlipped) totalRotation += Math.PI;  // 180° for flip
            
            ctx.rotate(totalRotation);
            
            // Draw centered
            ctx.drawImage(video, -sourceW/2, -sourceH/2, sourceW, sourceH);
            ctx.restore();
            
            console.log(`📸 MAIN: ${sourceW}x${sourceH} → ${mainCanvas.width}x${mainCanvas.height} (flip:${isFlipped}, hwRot:${isRotated}, portrait:${mainPhotoPortrait})`);
            
            // Save main photo with defect markers
            mainCanvas.toBlob(async (fullResBlob) => {
                // Deep copy defect markers to store with this photo
                const photoDefects = defectMarkers.map((m, idx) => ({
                    ...m,
                    photoIndex: data.mainPhotos.length, // Which main photo this belongs to
                    globalIndex: idx + 1 // 1-based index for display
                }));
                
                // Generate filename for S3
                const shotId = getCurrentShotId();
                const photoIndex = data.mainPhotos.length + 1;
                const filename = generatePhotoFilename(shotId || 'main', photoIndex);
                
                // Compress for memory storage (keeps browser fast)
                // Full 48MP → ~2K preview (2048px max dimension)
                const compressedBlob = await compressImageForMemory(fullResBlob, 2048, 0.75);
                
                const mainPhoto = { 
                    blob: compressedBlob, // Compressed for memory
                    fullResBlob: fullResBlob, // Keep full res for S3 upload (if immediate fails)
                    url: URL.createObjectURL(compressedBlob), 
                    width: mainCanvas.width, 
                    height: mainCanvas.height,
                    isPortrait: mainPhotoPortrait,
                    defects: photoDefects, // Store defects with the photo
                    defectSide: pendingDefectSide || null, // 'front', 'back', or null
                    // Track shot sequence for S3 naming
                    shotId: shotId,
                    filename: filename,
                    s3Key: null, // Will be set after upload
                    s3Uploaded: false
                };
                data.mainPhotos.push(mainPhoto);
                
                // Advance shot sequence for next photo
                advanceShotSequence();
                
                // Clear the pending side after use
                pendingDefectSide = null;
                
                // Auto-save to folder if selected
                if(saveDirectoryHandle) {
                    savePhotoToFolder(fullResBlob, filename); // Save full res locally
                }
                
                const fullSizeMB = (fullResBlob.size / 1024 / 1024).toFixed(2);
                const compSizeMB = (compressedBlob.size / 1024 / 1024).toFixed(2);
                console.log(`📸 MAIN: ${mainCanvas.width}×${mainCanvas.height} | Full: ${fullSizeMB}MB → Memory: ${compSizeMB}MB`);
                
                // Upload full res to S3 immediately (background, non-blocking)
                uploadMainPhotoToS3Immediately(fullResBlob, filename).then(s3Key => {
                    if (s3Key) {
                        mainPhoto.s3Key = s3Key;
                        mainPhoto.s3Uploaded = true;
                        // Clear full res blob from memory after successful upload
                        mainPhoto.fullResBlob = null;
                        console.log(`💾 Cleared full res blob from memory after S3 upload`);
                    }
                });
                
                // If we have defect markers, create crops and annotated version
                if(defectMarkers.length > 0) {
                    createDefectCrops(mainCanvas);
                    createAnnotatedPhoto(mainCanvas);
                    showToast('success', 'Photos Captured!', `Main + ${defectMarkers.length} defect crops`, 2000);
                } else {
                    showToast('success', `Main Photo ${data.mainPhotos.length}`, `${mainCanvas.width}×${mainCanvas.height}`, 1500);
                }
                
                updatePhotoGrids();
                updateValidation();
                
                // AI Analysis - analyze first main photo (use compressed for speed)
                if(data.mainPhotos.length === 1) {
                    analyzeMainPhotoWithAI(compressedBlob);
                }
            }, 'image/jpeg', 0.95);
        }
        
        function createDefectCrops(mainCanvas) {
            const mainW = mainCanvas.width;
            const mainH = mainCanvas.height;
            // Use MAX dimension so portrait photos get larger crops
            const cropSize = Math.round(Math.max(mainW, mainH) * DEFECT_CROP_SIZE);
            
            // Defect type display names
            const DEFECT_LABELS = {
                stain: 'STAIN',
                hole: 'HOLE',
                tear: 'TEAR',
                fade: 'FADE',
                repair: 'REPAIR',
                other: 'DEFECT'
            };
            
            defectMarkers.forEach((marker, idx) => {
                // Transform marker coordinates if in portrait mode
                // Markers are stored in landscape coordinates, need to rotate 90° clockwise
                let markerX = marker.x;
                let markerY = marker.y;
                
                if(mainPhotoPortrait) {
                    // 90° clockwise: (x, y) -> (100-y, x)
                    markerX = 100 - marker.y;
                    markerY = marker.x;
                }
                
                // Convert marker percentage to pixel position on main canvas
                const centerX = Math.round((markerX / 100) * mainW);
                const centerY = Math.round((markerY / 100) * mainH);
                
                // Calculate crop bounds (centered on marker)
                let cropX = centerX - Math.round(cropSize / 2);
                let cropY = centerY - Math.round(cropSize / 2);
                
                // Track how much we had to shift the crop (for circle positioning)
                const originalCropX = cropX;
                const originalCropY = cropY;
                
                // Clamp to image bounds
                cropX = Math.max(0, Math.min(cropX, mainW - cropSize));
                cropY = Math.max(0, Math.min(cropY, mainH - cropSize));
                
                // Calculate where the defect actually is within the crop
                // (may not be exactly center if we hit image bounds)
                const defectInCropX = centerX - cropX;
                const defectInCropY = centerY - cropY;
                
                // Create crop canvas
                const cropCanvas = document.createElement('canvas');
                const cropCtx = cropCanvas.getContext('2d');
                cropCanvas.width = cropSize;
                cropCanvas.height = cropSize;
                
                // Draw the cropped image
                cropCtx.drawImage(mainCanvas, cropX, cropY, cropSize, cropSize, 0, 0, cropSize, cropSize);
                
                // Scale factors for annotations based on crop size
                const scale = cropSize / 1000; // Base scale on 1000px reference
                const circleRadius = Math.round(80 * scale);
                const lineWidth = Math.max(3, Math.round(6 * scale));
                const fontSize = Math.round(42 * scale);
                const arrowSize = Math.round(20 * scale);
                const labelPadding = Math.round(16 * scale);
                
                const defectColor = DEFECT_COLORS[marker.type] || '#ef4444';
                const label = DEFECT_LABELS[marker.type] || 'DEFECT';
                
                // === DRAW CIRCLE AROUND DEFECT ===
                cropCtx.strokeStyle = defectColor;
                cropCtx.lineWidth = lineWidth;
                cropCtx.setLineDash([lineWidth * 2, lineWidth]); // Dashed line
                cropCtx.beginPath();
                cropCtx.arc(defectInCropX, defectInCropY, circleRadius, 0, Math.PI * 2);
                cropCtx.stroke();
                cropCtx.setLineDash([]); // Reset to solid
                
                // === DRAW ARROW FROM TOP-LEFT TO CIRCLE ===
                // Arrow starts from top-left area, points to edge of circle
                const arrowStartX = Math.round(cropSize * 0.12);
                const arrowStartY = Math.round(cropSize * 0.12);
                
                // Calculate angle from arrow start to defect center
                const angle = Math.atan2(defectInCropY - arrowStartY, defectInCropX - arrowStartX);
                
                // Arrow ends at edge of circle
                const arrowEndX = defectInCropX - Math.cos(angle) * (circleRadius + lineWidth);
                const arrowEndY = defectInCropY - Math.sin(angle) * (circleRadius + lineWidth);
                
                // Draw arrow line with shadow for visibility
                cropCtx.shadowColor = 'rgba(0,0,0,0.5)';
                cropCtx.shadowBlur = 4;
                cropCtx.strokeStyle = defectColor;
                cropCtx.lineWidth = lineWidth;
                cropCtx.lineCap = 'round';
                cropCtx.beginPath();
                cropCtx.moveTo(arrowStartX, arrowStartY);
                cropCtx.lineTo(arrowEndX, arrowEndY);
                cropCtx.stroke();
                
                // Draw arrowhead
                cropCtx.fillStyle = defectColor;
                cropCtx.beginPath();
                cropCtx.moveTo(arrowEndX, arrowEndY);
                cropCtx.lineTo(
                    arrowEndX - arrowSize * Math.cos(angle - Math.PI/6),
                    arrowEndY - arrowSize * Math.sin(angle - Math.PI/6)
                );
                cropCtx.lineTo(
                    arrowEndX - arrowSize * Math.cos(angle + Math.PI/6),
                    arrowEndY - arrowSize * Math.sin(angle + Math.PI/6)
                );
                cropCtx.closePath();
                cropCtx.fill();
                cropCtx.shadowBlur = 0;
                
                // === DRAW LABEL BOX ===
                cropCtx.font = `bold ${fontSize}px Arial`;
                const textMetrics = cropCtx.measureText(label);
                const textWidth = textMetrics.width;
                const textHeight = fontSize;
                
                // Position label in top-left, connected to arrow
                const labelX = arrowStartX;
                const labelY = arrowStartY + Math.round(fontSize * 0.8);
                
                // Draw label background with rounded corners
                const boxX = labelX - labelPadding;
                const boxY = labelY - textHeight - labelPadding/2;
                const boxW = textWidth + labelPadding * 2;
                const boxH = textHeight + labelPadding;
                const boxRadius = Math.round(8 * scale);
                
                cropCtx.shadowColor = 'rgba(0,0,0,0.4)';
                cropCtx.shadowBlur = 8;
                cropCtx.fillStyle = defectColor;
                cropCtx.beginPath();
                // Use roundRect if available, fallback to regular rect
                if(cropCtx.roundRect) {
                    cropCtx.roundRect(boxX, boxY, boxW, boxH, boxRadius);
                } else {
                    cropCtx.rect(boxX, boxY, boxW, boxH);
                }
                cropCtx.fill();
                cropCtx.shadowBlur = 0;
                
                // Draw label text
                cropCtx.fillStyle = 'white';
                cropCtx.textAlign = 'left';
                cropCtx.textBaseline = 'bottom';
                cropCtx.fillText(label, labelX, labelY);
                
                // === DRAW SMALL NUMBER BADGE IN CORNER ===
                const badgeSize = Math.round(40 * scale);
                const badgeX = cropSize - badgeSize - Math.round(15 * scale);
                const badgeY = Math.round(15 * scale);
                
                cropCtx.fillStyle = 'rgba(0,0,0,0.7)';
                cropCtx.beginPath();
                cropCtx.arc(badgeX + badgeSize/2, badgeY + badgeSize/2, badgeSize/2, 0, Math.PI * 2);
                cropCtx.fill();
                cropCtx.strokeStyle = 'white';
                cropCtx.lineWidth = 2;
                cropCtx.stroke();
                
                cropCtx.fillStyle = 'white';
                cropCtx.font = `bold ${Math.round(24 * scale)}px Arial`;
                cropCtx.textAlign = 'center';
                cropCtx.textBaseline = 'middle';
                cropCtx.fillText(idx + 1, badgeX + badgeSize/2, badgeY + badgeSize/2);
                
                cropCanvas.toBlob(blob => {
                    const defectPhoto = {
                        blob,
                        url: URL.createObjectURL(blob),
                        width: cropSize,
                        height: cropSize,
                        defectType: marker.type,
                        markerIndex: idx + 1
                    };
                    data.defectPhotos.push(defectPhoto);
                    
                    // Auto-save to folder if selected
                    if(saveDirectoryHandle) {
                        const filename = generatePhotoFilename(`defect_${marker.type}`, idx + 1);
                        savePhotoToFolder(blob, filename);
                    }
                    
                    console.log(`📸 DEFECT CROP ${idx + 1} (${marker.type}): ${cropSize}×${cropSize} with annotations`);
                    updatePhotoGrids();
                }, 'image/jpeg', 0.95);
            });
        }
        
        function createAnnotatedPhoto(mainCanvas) {
            // Create a copy with markers drawn on it
            const annotatedCanvas = document.createElement('canvas');
            const ctx = annotatedCanvas.getContext('2d');
            annotatedCanvas.width = mainCanvas.width;
            annotatedCanvas.height = mainCanvas.height;
            
            // Draw original image
            ctx.drawImage(mainCanvas, 0, 0);
            
            // Defect type display names
            const DEFECT_LABELS = {
                stain: 'STAIN',
                hole: 'HOLE',
                tear: 'TEAR',
                fade: 'FADE',
                repair: 'REPAIR',
                other: 'DEFECT'
            };
            
            // Scale marker size based on image resolution (larger on 4K)
            const scaleFactor = Math.max(annotatedCanvas.width, annotatedCanvas.height) / 1920;
            const markerRadius = Math.round(40 * scaleFactor);
            const fontSize = Math.round(28 * scaleFactor);
            const labelFontSize = Math.round(32 * scaleFactor);
            const lineWidth = Math.round(5 * scaleFactor);
            const labelPadding = Math.round(12 * scaleFactor);
            
            // PASS 0: Cluster nearby defects of the same type
            const clusterThreshold = 12; // percentage of image - defects within this distance get grouped
            
            const clusterDefects = (markers) => {
                if(markers.length <= 1) return markers.map((m, i) => ({ ...m, count: 1, indices: [i] }));
                
                const used = new Set();
                const clusters = [];
                
                for(let i = 0; i < markers.length; i++) {
                    if(used.has(i)) continue;
                    
                    const cluster = { 
                        type: markers[i].type,
                        indices: [i],
                        sumX: markers[i].x,
                        sumY: markers[i].y
                    };
                    used.add(i);
                    
                    // Find all nearby markers of same type
                    for(let j = i + 1; j < markers.length; j++) {
                        if(used.has(j)) continue;
                        if(markers[j].type !== markers[i].type) continue;
                        
                        // Check distance to cluster centroid
                        const cx = cluster.sumX / cluster.indices.length;
                        const cy = cluster.sumY / cluster.indices.length;
                        const dist = Math.sqrt((markers[j].x - cx)**2 + (markers[j].y - cy)**2);
                        
                        if(dist < clusterThreshold) {
                            cluster.indices.push(j);
                            cluster.sumX += markers[j].x;
                            cluster.sumY += markers[j].y;
                            used.add(j);
                        }
                    }
                    
                    // Create cluster marker at centroid
                    clusters.push({
                        x: cluster.sumX / cluster.indices.length,
                        y: cluster.sumY / cluster.indices.length,
                        type: cluster.type,
                        count: cluster.indices.length,
                        indices: cluster.indices
                    });
                }
                
                return clusters;
            };
            
            const clusteredMarkers = clusterDefects(defectMarkers);
            
            // PASS 1: Calculate all marker and label positions
            ctx.font = `bold ${labelFontSize}px Arial`;
            const markerData = clusteredMarkers.map((marker, idx) => {
                // Transform marker coordinates if in portrait mode
                let markerX = marker.x;
                let markerY = marker.y;
                
                if(mainPhotoPortrait) {
                    markerX = 100 - marker.y;
                    markerY = marker.x;
                }
                
                const x = (markerX / 100) * annotatedCanvas.width;
                const y = (markerY / 100) * annotatedCanvas.height;
                const defectColor = DEFECT_COLORS[marker.type] || '#ef4444';
                const baseLabel = DEFECT_LABELS[marker.type] || 'DEFECT';
                // Add count if more than 1
                const label = marker.count > 1 ? `${baseLabel} ×${marker.count}` : baseLabel;
                
                const textMetrics = ctx.measureText(label);
                const textWidth = textMetrics.width;
                const boxWidth = textWidth + labelPadding * 2;
                const boxHeight = labelFontSize + labelPadding;
                
                // Initial label position (to the right of marker)
                let boxX = x + markerRadius + labelPadding;
                let boxY = y - boxHeight/2;
                
                // Keep on screen
                if(boxX + boxWidth > annotatedCanvas.width - 10) {
                    boxX = x - markerRadius - boxWidth - labelPadding;
                }
                if(boxY < 10) boxY = 10;
                if(boxY + boxHeight > annotatedCanvas.height - 10) {
                    boxY = annotatedCanvas.height - boxHeight - 10;
                }
                
                return { x, y, defectColor, label, boxX, boxY, boxWidth, boxHeight, idx, count: marker.count, indices: marker.indices };
            });
            
            // PASS 2: Resolve label collisions with improved algorithm
            const resolveCollisions = (data) => {
                const margin = Math.round(10 * scaleFactor);
                
                // Helper to check if two boxes overlap
                const boxesOverlap = (a, b) => {
                    return a.boxX < b.boxX + b.boxWidth + margin && 
                           a.boxX + a.boxWidth + margin > b.boxX &&
                           a.boxY < b.boxY + b.boxHeight + margin && 
                           a.boxY + a.boxHeight + margin > b.boxY;
                };
                
                // Helper to check if label overlaps a marker circle
                const overlapsMarker = (box, markerX, markerY) => {
                    const closestX = Math.max(box.boxX, Math.min(markerX, box.boxX + box.boxWidth));
                    const closestY = Math.max(box.boxY, Math.min(markerY, box.boxY + box.boxHeight));
                    const dist = Math.sqrt((markerX - closestX)**2 + (markerY - closestY)**2);
                    return dist < markerRadius + margin;
                };
                
                // Helper to check if label overlaps any placed label or any marker
                const overlapsAny = (current, placed, allMarkers) => {
                    for(const other of placed) {
                        if(boxesOverlap(current, other)) return true;
                    }
                    // Also check against all marker circles
                    for(const m of allMarkers) {
                        if(m.idx !== current.idx && overlapsMarker(current, m.x, m.y)) return true;
                    }
                    return false;
                };
                
                // Generate candidate positions for a label
                const getCandidates = (m) => {
                    const candidates = [];
                    const gap = markerRadius + labelPadding;
                    
                    // Right of marker
                    candidates.push({ x: m.x + gap, y: m.y - m.boxHeight/2 });
                    // Left of marker  
                    candidates.push({ x: m.x - gap - m.boxWidth, y: m.y - m.boxHeight/2 });
                    // Below marker
                    candidates.push({ x: m.x - m.boxWidth/2, y: m.y + gap });
                    // Above marker
                    candidates.push({ x: m.x - m.boxWidth/2, y: m.y - gap - m.boxHeight });
                    // Right-below
                    candidates.push({ x: m.x + gap, y: m.y + gap/2 });
                    // Right-above
                    candidates.push({ x: m.x + gap, y: m.y - gap/2 - m.boxHeight });
                    // Left-below
                    candidates.push({ x: m.x - gap - m.boxWidth, y: m.y + gap/2 });
                    // Left-above
                    candidates.push({ x: m.x - gap - m.boxWidth, y: m.y - gap/2 - m.boxHeight });
                    
                    return candidates;
                };
                
                // Constrain position to canvas
                const constrain = (m) => {
                    if(m.boxX < 10) m.boxX = 10;
                    if(m.boxX + m.boxWidth > annotatedCanvas.width - 10) {
                        m.boxX = annotatedCanvas.width - m.boxWidth - 10;
                    }
                    if(m.boxY < 10) m.boxY = 10;
                    if(m.boxY + m.boxHeight > annotatedCanvas.height - 10) {
                        m.boxY = annotatedCanvas.height - m.boxHeight - 10;
                    }
                };
                
                // Sort by X position (left to right) to handle side-by-side markers better
                data.sort((a, b) => a.x - b.x);
                
                const placed = [];
                
                for(let i = 0; i < data.length; i++) {
                    const m = data[i];
                    const candidates = getCandidates(m);
                    let bestCandidate = null;
                    
                    // Try each candidate position
                    for(const cand of candidates) {
                        m.boxX = cand.x;
                        m.boxY = cand.y;
                        constrain(m);
                        
                        if(!overlapsAny(m, placed, data)) {
                            bestCandidate = { x: m.boxX, y: m.boxY };
                            break;
                        }
                    }
                    
                    // If no clean position found, use first candidate with vertical offset
                    if(!bestCandidate) {
                        m.boxX = candidates[0].x;
                        m.boxY = candidates[0].y;
                        constrain(m);
                        
                        // Try shifting vertically until clear
                        let shift = 0;
                        const shiftAmount = m.boxHeight + margin;
                        for(let tries = 0; tries < 8; tries++) {
                            shift = (tries % 2 === 0 ? 1 : -1) * Math.ceil((tries+1)/2) * shiftAmount;
                            m.boxY = candidates[0].y + shift;
                            constrain(m);
                            if(!overlapsAny(m, placed, data)) break;
                        }
                    } else {
                        m.boxX = bestCandidate.x;
                        m.boxY = bestCandidate.y;
                    }
                    
                    placed.push(m);
                }
                
                // Restore original order by index
                data.sort((a, b) => a.idx - b.idx);
            };
            
            resolveCollisions(markerData);
            
            // PASS 3: Draw all markers and labels
            markerData.forEach((m, clusterIdx) => {
                // Make marker slightly bigger for clusters
                const thisRadius = m.count > 1 ? markerRadius * 1.15 : markerRadius;
                
                // Draw circle with shadow
                ctx.shadowColor = 'rgba(0,0,0,0.5)';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(m.x, m.y, thisRadius, 0, Math.PI * 2);
                ctx.fillStyle = m.defectColor;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.strokeStyle = 'white';
                ctx.lineWidth = lineWidth;
                ctx.stroke();
                
                // For clusters, draw a second ring to indicate multiple
                if(m.count > 1) {
                    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                    ctx.lineWidth = lineWidth * 0.5;
                    ctx.beginPath();
                    ctx.arc(m.x, m.y, thisRadius + lineWidth * 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Draw number in circle (cluster index)
                ctx.fillStyle = 'white';
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(clusterIdx + 1, m.x, m.y);
                
                // Draw connecting line from marker to label
                // Determine if label is to the left or right of marker
                const labelIsRight = m.boxX > m.x;
                const lineStartX = labelIsRight ? m.x + thisRadius : m.x - thisRadius;
                const lineStartY = m.y;
                const lineEndX = labelIsRight ? m.boxX : m.boxX + m.boxWidth;
                const lineEndY = m.boxY + m.boxHeight/2;
                
                ctx.strokeStyle = m.defectColor;
                ctx.lineWidth = Math.round(3 * scaleFactor);
                ctx.setLineDash([Math.round(6 * scaleFactor), Math.round(4 * scaleFactor)]);
                ctx.beginPath();
                ctx.moveTo(lineStartX, lineStartY);
                ctx.lineTo(lineEndX, lineEndY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw label background
                ctx.shadowColor = 'rgba(0,0,0,0.4)';
                ctx.shadowBlur = 8;
                ctx.fillStyle = m.defectColor;
                ctx.beginPath();
                if(ctx.roundRect) {
                    ctx.roundRect(m.boxX, m.boxY, m.boxWidth, m.boxHeight, Math.round(8 * scaleFactor));
                } else {
                    ctx.rect(m.boxX, m.boxY, m.boxWidth, m.boxHeight);
                }
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Draw white border on label
                ctx.strokeStyle = 'white';
                ctx.lineWidth = Math.round(3 * scaleFactor);
                ctx.stroke();
                
                // Draw label text
                ctx.fillStyle = 'white';
                ctx.font = `bold ${labelFontSize}px Arial`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(m.label, m.boxX + labelPadding, m.boxY + m.boxHeight/2);
            });
            
            // Save as defect overview photo (goes to defectPhotos, not mainPhotos)
            annotatedCanvas.toBlob(blob => {
                const annotatedPhoto = {
                    blob,
                    url: URL.createObjectURL(blob),
                    width: annotatedCanvas.width,
                    height: annotatedCanvas.height,
                    isAnnotated: true,
                    isOverview: true,
                    markerCount: defectMarkers.length
                };
                // Store in DEFECT photos (overview of all defects)
                data.defectPhotos.push(annotatedPhoto);
                
                // Auto-save to folder if selected
                if(saveDirectoryHandle) {
                    const filename = generatePhotoFilename('defect_overview', data.defectPhotos.length);
                    savePhotoToFolder(blob, filename);
                }
                
                console.log(`📸 DEFECT OVERVIEW: ${annotatedCanvas.width}×${annotatedCanvas.height} with ${defectMarkers.length} markers`);
                
                // Clear markers after successful capture
                clearDefectMarkers();
                
                // Re-enable defect marking for next round
                setTimeout(() => enableDefectMarking(), 100);
                
                updatePhotoGrids();
            }, 'image/jpeg', 0.95);
        }
        
        // ============ STABILIZER FUNCTIONS ============
        function startStabilizer() {
            const video = document.getElementById('camera-video');
            
            if(!video || !video.srcObject) {
                console.log('📷 Stabilizer: No video source available');
                return;
            }
            
            // Create small canvas for frame comparison (very lightweight)
            stabilizerCanvas = document.createElement('canvas');
            stabilizerCanvas.width = 64;
            stabilizerCanvas.height = 64;
            stabilizerCtx = stabilizerCanvas.getContext('2d', { willReadFrequently: true });
            
            previousFrame = null;
            stableFrameCount = 0;
            isStable = false;
            updateStabilizerUI(false);
            
            // Check frames 10x per second
            stabilizerInterval = setInterval(() => {
                checkStability(video);
            }, 100);
            
            console.log('📷 Stabilizer started');
        }
        
        function checkStability(video) {
            if(!video.videoWidth || !stabilizerCtx) return;
            
            // Draw scaled-down frame
            stabilizerCtx.drawImage(video, 0, 0, 64, 64);
            const currentFrame = stabilizerCtx.getImageData(0, 0, 64, 64).data;
            
            if(previousFrame) {
                const diff = calculateFrameDifference(previousFrame, currentFrame);
                currentMotionDelta = Math.round(diff * 10) / 10; // Store for metrics
                
                if(diff < STABILITY_THRESHOLD) {
                    stableFrameCount++;
                    if(stableFrameCount >= FRAMES_NEEDED && !isStable) {
                        isStable = true;
                        updateStabilizerUI(true);
                    }
                } else {
                    stableFrameCount = 0;
                    if(isStable) {
                        isStable = false;
                        updateStabilizerUI(false);
                    }
                }
            }
            
            previousFrame = currentFrame;
        }
        
        function calculateFrameDifference(prev, curr) {
            let diff = 0;
            const sampleStep = 4; // Sample every 4th pixel for speed
            for(let i = 0; i < prev.length; i += 4 * sampleStep) {
                diff += Math.abs(prev[i] - curr[i]);     // R
                diff += Math.abs(prev[i+1] - curr[i+1]); // G
                diff += Math.abs(prev[i+2] - curr[i+2]); // B
            }
            return diff / (prev.length / sampleStep / 4) / 3; // Average per sampled pixel
        }
        
        function updateStabilizerUI(stable) {
            const dot = document.getElementById('stabilizer-dot');
            const text = document.getElementById('stabilizer-text');
            if(!dot || !text) return;
            
            if(stable) {
                dot.classList.add('stable');
                text.textContent = 'STABLE ✓';
                text.style.color = '#22c55e';
            } else {
                dot.classList.remove('stable');
                text.textContent = 'HOLD STEADY';
                text.style.color = 'white';
            }
        }
        
        function stopStabilizer() {
            if(stabilizerInterval) {
                clearInterval(stabilizerInterval);
                stabilizerInterval = null;
            }
            previousFrame = null;
            stableFrameCount = 0;
            isStable = false;
            console.log('📷 Stabilizer stopped');
        }
        
        function updatePhotoGrids() { 
            const renderGrid = (photos, gridId, mode) => { 
                // Main = portrait (full res), Tag/Defect/etc = square (1:1)
                const thumbClass = (mode === 'main') ? 'photo-thumb' : 'photo-thumb square';
                let thumbStyle = '';
                if(mode === 'defect-closeup') thumbStyle = 'border-color:#dc2626;';
                else if(mode === 'features') thumbStyle = 'border-color:#7c3aed;';
                
                document.getElementById(gridId).innerHTML = photos.map((p,i) => {
                    let badge = '';
                    // Show front/back + defect count for main photos with defectSide
                    if(mode === 'main' && p.defectSide) {
                        const sideColor = p.defectSide === 'front' ? '#0ea5e9' : '#8b5cf6';
                        const sideLabel = p.defectSide === 'front' ? 'F' : 'B';
                        const defectCount = p.defects ? p.defects.length : 0;
                        badge = `<span style="position:absolute;top:2px;left:2px;background:${sideColor};color:white;font-size:9px;padding:2px 5px;border-radius:4px;font-weight:700;">${sideLabel} ×${defectCount}</span>`;
                    }
                    // Show linked defect info for defect close-ups (new format)
                    else if(mode === 'defect-closeup' && p.linkedDefect) {
                        const sideLabel = p.linkedDefect.side ? p.linkedDefect.side.charAt(0).toUpperCase() : '';
                        const typeInitial = p.linkedDefect.type ? p.linkedDefect.type.charAt(0).toUpperCase() : '';
                        badge = `<span style="position:absolute;top:2px;left:2px;background:#dc2626;color:white;font-size:9px;padding:1px 4px;border-radius:4px;font-weight:700;">${sideLabel}#${p.linkedDefect.defectIndex + 1}</span>`;
                    }
                    // Legacy support for old format
                    else if(mode === 'defect-closeup' && p.linkedDefectIndex !== null && p.linkedDefectIndex !== undefined) {
                        badge = `<span style="position:absolute;top:2px;left:2px;background:#dc2626;color:white;font-size:9px;padding:1px 4px;border-radius:4px;font-weight:700;">#${p.linkedDefectIndex + 1}</span>`;
                    }
                    // Show feature type for feature close-ups
                    if(mode === 'features' && p.featureType) {
                        badge = `<span style="position:absolute;top:2px;left:2px;background:#7c3aed;color:white;font-size:8px;padding:1px 3px;border-radius:3px;font-weight:600;">${p.featureType}</span>`;
                    }
                    return `<div class="${thumbClass}" style="${thumbStyle}" ondblclick="openPreview('${mode}',${i})" title="Double-click to preview">
                        <img src="${p.url}">${badge}
                        <button class="photo-thumb-delete" onclick="event.stopPropagation();deletePhoto('${mode}',${i})">×</button>
                    </div>`;
                }).join('') + `<div class="${thumbClass} photo-thumb-empty" style="${thumbStyle}" onclick="setPhotoMode('${mode}')">+</div>`; 
            }; 
            renderGrid(data.mainPhotos,'main-photos-grid','main'); 
            renderGrid(data.tagPhotos,'tag-photos-grid','tag'); 
            renderGrid(data.defectPhotos,'defect-photos-grid','defect'); 
            renderGrid(data.defectCloseupPhotos,'defect-closeup-photos-grid','defect-closeup'); 
            renderGrid(data.featuresPhotos,'features-photos-grid','features'); 
            document.getElementById('main-count').textContent = data.mainPhotos.length; 
            document.getElementById('tag-count').textContent = data.tagPhotos.length; 
            document.getElementById('defect-count').textContent = data.defectPhotos.length; 
            document.getElementById('defect-closeup-count').textContent = data.defectCloseupPhotos.length; 
            document.getElementById('features-count').textContent = data.featuresPhotos.length; 
            document.getElementById('photo-count').textContent = data.mainPhotos.length+data.tagPhotos.length+data.defectPhotos.length+data.defectCloseupPhotos.length+data.featuresPhotos.length; 
            
            // Update defect link panel when photos change
            updateDefectLinkPanel();
        }
        function deletePhoto(mode,index) { 
            // Track deletion in metrics
            trackPhotoDeletion(mode, index);
            
            if(mode==='main'){URL.revokeObjectURL(data.mainPhotos[index].url);data.mainPhotos.splice(index,1);} 
            else if(mode==='tag'){URL.revokeObjectURL(data.tagPhotos[index].url);data.tagPhotos.splice(index,1);} 
            else if(mode==='defect-closeup'){URL.revokeObjectURL(data.defectCloseupPhotos[index].url);data.defectCloseupPhotos.splice(index,1);} 
            else if(mode==='features'){URL.revokeObjectURL(data.featuresPhotos[index].url);data.featuresPhotos.splice(index,1);} 
            else{URL.revokeObjectURL(data.defectPhotos[index].url);data.defectPhotos.splice(index,1);} 
            updatePhotoGrids(); updateValidation(); 
        }
        
        // Photo Preview Functions
        function openPreview(mode, index) {
            previewMode = mode;
            previewIndex = index;
            const photos = mode === 'main' ? data.mainPhotos : mode === 'tag' ? data.tagPhotos : mode === 'defect-closeup' ? data.defectCloseupPhotos : mode === 'features' ? data.featuresPhotos : data.defectPhotos;
            if(photos.length === 0) return;
            
            const photo = photos[index];
            document.getElementById('preview-image').src = photo.url;
            const is4K = photo.width >= 3800;
            const resLabel = photo.width ? `${photo.width}×${photo.height}${is4K ? ' 4K' : ''}` : '';
            let modeLabel = mode.toUpperCase();
            if(mode === 'defect-closeup') modeLabel = '🔴 DEFECT CLOSE-UP';
            else if(mode === 'features') modeLabel = '✨ FEATURE';
            document.getElementById('preview-type').textContent = modeLabel + (resLabel ? ` • ${resLabel}` : '');
            let bgColor = '#3b82f6'; // main default
            if(mode === 'tag') bgColor = '#f59e0b';
            else if(mode === 'defect-closeup') bgColor = '#dc2626';
            else if(mode === 'features') bgColor = '#7c3aed';
            else if(mode === 'defect') bgColor = '#ef4444';
            document.getElementById('preview-type').style.background = bgColor;
            updatePreviewNav();
            document.getElementById('preview-modal').classList.add('active');
            document.body.style.overflow = 'hidden';
        }
        
        function closePreview() {
            document.getElementById('preview-modal').classList.remove('active');
            document.body.style.overflow = '';
            previewMode = null;
            previewIndex = 0;
        }
        
        function navigatePreview(dir) {
            const photos = previewMode === 'main' ? data.mainPhotos : previewMode === 'tag' ? data.tagPhotos : previewMode === 'defect-closeup' ? data.defectCloseupPhotos : previewMode === 'features' ? data.featuresPhotos : data.defectPhotos;
            previewIndex += dir;
            if(previewIndex < 0) previewIndex = 0;
            if(previewIndex >= photos.length) previewIndex = photos.length - 1;
            const photo = photos[previewIndex];
            document.getElementById('preview-image').src = photo.url;
            const is4K = photo.width >= 3800;
            const resLabel = photo.width ? `${photo.width}×${photo.height}${is4K ? ' 4K' : ''}` : '';
            document.getElementById('preview-type').textContent = previewMode.toUpperCase() + (resLabel ? ` • ${resLabel}` : '');
            updatePreviewNav();
        }
        
        function updatePreviewNav() {
            const photos = previewMode === 'main' ? data.mainPhotos : previewMode === 'tag' ? data.tagPhotos : data.defectPhotos;
            document.getElementById('preview-prev').disabled = previewIndex <= 0;
            document.getElementById('preview-next').disabled = previewIndex >= photos.length - 1;
            document.getElementById('preview-counter').textContent = `${previewIndex + 1} / ${photos.length}`;
        }
        
        function deleteFromPreview() {
            if(!previewMode) return;
            deletePhoto(previewMode, previewIndex);
            const photos = previewMode === 'main' ? data.mainPhotos : previewMode === 'tag' ? data.tagPhotos : data.defectPhotos;
            if(photos.length === 0) {
                closePreview();
                return;
            }
            if(previewIndex >= photos.length) previewIndex = photos.length - 1;
            const photo = photos[previewIndex];
            document.getElementById('preview-image').src = photo.url;
            const is4K = photo.width >= 3800;
            const resLabel = photo.width ? `${photo.width}×${photo.height}${is4K ? ' 4K' : ''}` : '';
            document.getElementById('preview-type').textContent = previewMode.toUpperCase() + (resLabel ? ` • ${resLabel}` : '');
            updatePreviewNav();
        }
        
        // Keyboard navigation for preview
        document.addEventListener('keydown', (e) => {
            // Close defect picker on ESC
            if(document.getElementById('defect-picker-modal').classList.contains('active')) {
                if(e.key === 'Escape') closeDefectPicker();
                return; // Don't process other keys when picker is open
            }
            if(document.getElementById('preview-modal').classList.contains('active')) {
                if(e.key === 'Escape') closePreview();
                if(e.key === 'ArrowLeft') navigatePreview(-1);
                if(e.key === 'ArrowRight') navigatePreview(1);
                if(e.key === 'Delete' || e.key === 'Backspace') deleteFromPreview();
            }
            // G key toggles grid (when not in input field)
            if((e.key === 'g' || e.key === 'G') && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                toggleGrid();
            }
            // R key toggles rotation (when not in input field and in main mode)
            if((e.key === 'r' || e.key === 'R') && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && photoMode === 'main') {
                toggleRotation();
            }
            // F key captures FRONT defect photo (when in main mode with defects marked)
            if((e.key === 'f' || e.key === 'F') && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && photoMode === 'main' && defectMarkers.length > 0) {
                e.preventDefault();
                captureDefectSide('front');
            }
            // B key captures BACK defect photo (when in main mode with defects marked)
            if((e.key === 'b' || e.key === 'B') && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA' && photoMode === 'main' && defectMarkers.length > 0) {
                e.preventDefault();
                captureDefectSide('back');
            }
        });
        
        // Toggle centering grid overlay
        function toggleGrid() {
            const grid = document.getElementById('grid-overlay');
            if(grid) {
                const isVisible = grid.style.display === 'block';
                grid.style.display = isVisible ? 'none' : 'block';
            }
        }
        
        // Toggle between landscape and portrait mode
        function toggleRotation() {
            mainPhotoPortrait = !mainPhotoPortrait;
            
            const btn = document.getElementById('rotate-btn');
            const video = document.getElementById('camera-video');
            
            // Track rotation change in metrics
            trackClick('photos');
            
            if(mainPhotoPortrait) {
                btn.textContent = '🔄 PORTRAIT';
                btn.style.background = '#22c55e';
                
                // Rotate video 90° CW visually
                video.style.transform = 'rotate(90deg)';
                video.style.maxWidth = '100vh';
                video.style.maxHeight = '100vw';
                
                showToast('info', 'Portrait Mode ON', 'Vertical garment layout', 2000);
            } else {
                btn.textContent = '🔄 LANDSCAPE';
                btn.style.background = '#8b5cf6';
                
                // Reset to landscape
                video.style.transform = '';
                video.style.maxWidth = '';
                video.style.maxHeight = '';
                
                showToast('info', 'Landscape Mode', 'Horizontal layout', 1500);
            }
            
            // Re-position defect layer and re-render markers with transformed coordinates
            setTimeout(() => {
                updateDefectLayerPosition();
                renderDefectMarkers();
            }, 100);
            
            console.log(`📷 Rotation: ${mainPhotoPortrait ? 'PORTRAIT' : 'LANDSCAPE'}`);
        }
        
        function setSuperCategory(cat, btn) { 
            data.superCategory = cat; 
            data.category = ''; 
            document.querySelectorAll('.super-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); 
            btn.classList.add('selected','btn-hero'); 
            btn.classList.remove('btn-secondary'); 
            
            // Toggle Construction sections based on category type
            const isBottoms = (cat === 'bottoms');
            document.getElementById('tops-construction').classList.toggle('hidden', isBottoms);
            document.getElementById('bottoms-construction').classList.toggle('hidden', !isBottoms);
            
            // Clear construction data when switching
            if(isBottoms) {
                data.sleeveLength = ''; data.sleeveStyle = ''; data.stitch = ''; data.cutoffType = ''; data.bodyConstruction = '';
                document.querySelectorAll('.sleeve-btn, .style-btn, .stitch-btn, .body-btn').forEach(b => { 
                    b.classList.remove('selected','btn-hero'); 
                    b.classList.add('btn-secondary'); 
                });
            } else {
                data.legStyle = ''; data.rise = '';
                document.querySelectorAll('.leg-btn, .rise-btn').forEach(b => { 
                    b.classList.remove('selected','btn-hero'); 
                    b.classList.add('btn-secondary'); 
                });
            }
            
            renderSubCategories(cat); 
            updateValidation(); 
        }
        
        function renderSubCategories(superCat) { 
            const config = categoryConfig[superCat]; 
            const container = document.getElementById('sub-categories'); 
            container.innerHTML = `<button onclick="setCategory('${config.heroes[0]}', this)" class="cat-hero cat-btn"><span style="font-size:20px;">${catEmojis[config.heroes[0]]||'👕'}</span> ${config.heroes[0].toUpperCase()}</button><div class="btn-grid btn-grid-2" style="margin-bottom:8px;">${config.heroes.slice(1).map(c=>`<button onclick="setCategory('${c}', this)" class="cat-secondary cat-btn"><span>${catEmojis[c]||'👕'}</span> ${c}</button>`).join('')}</div><div class="btn-grid btn-grid-4">${config.others.map(c=>`<button onclick="setCategory('${c}', this)" class="cat-other cat-btn">${c}</button>`).join('')}</div>`; 
        }
        function setCategory(cat, btn) { 
            data.category = cat; 
            // Remove selected from ALL category buttons
            document.querySelectorAll('.cat-btn').forEach(b => { 
                b.classList.remove('selected'); 
            }); 
            // Add selected to clicked button
            btn.classList.add('selected'); 
            document.getElementById('category-label').textContent = '— ' + cat.toUpperCase(); 
            // Show elastic check for Sweatpants
            const elasticSection = document.getElementById('elastic-section');
            if(elasticSection) elasticSection.classList.toggle('hidden', cat !== 'Sweatpants');
            // Update shot sequence based on category
            updateShotSequence();
            // Update measurement hints based on category
            updateMeasurementHints(cat);
            // Update tag location help if panel is open
            if(!document.getElementById('tag-location-panel').classList.contains('hidden')) {
                updateTagLocationHelp();
            }
            // Update sleeve defaults based on category
            updateSleeveDefaults(cat);
            // Update stitch defaults based on category
            updateStitchDefaults(cat);
            // Update leg style defaults based on category (for bottoms)
            updateLegStyleDefaults(cat);
            renderFabricCards(); 
            renderMaterialCards(); 
            updateValidation(); 
        }
        
        // QA FIX: Dynamic sleeve defaults based on category
        function updateSleeveDefaults(cat) {
            // Reset all sleeve buttons to secondary
            document.querySelectorAll('.sleeve-btn').forEach(b => {
                if(!b.classList.contains('selected')) {
                    b.classList.add('btn-secondary');
                }
            });
        }
        
        // QA FIX: Dynamic stitch defaults based on category
        function updateStitchDefaults(cat) {
            // Reset stitch buttons
            document.querySelectorAll('.stitch-btn').forEach(b => {
                if(!b.classList.contains('selected')) {
                    b.classList.add('btn-secondary');
                }
            });
        }
        
        // QA FIX: Dynamic leg style defaults based on bottoms category
        function updateLegStyleDefaults(cat) {
            // Only apply to bottoms categories
            const bottomsCategories = ['Jeans', 'Pants', 'Shorts', 'Sweatpants'];
            if(!bottomsCategories.includes(cat)) return;
            
            // Reset all leg buttons to secondary
            document.querySelectorAll('.leg-btn').forEach(b => {
                if(!b.classList.contains('selected')) {
                    b.classList.add('btn-secondary');
                }
            });
        }
        
        function updateMeasurementHints(cat) {
            // Hide all measurement hints first
            document.getElementById('measure-hint-tops').classList.add('hidden');
            document.getElementById('measure-hint-button-shirt').classList.add('hidden');
            document.getElementById('measure-hint-bottoms').classList.add('hidden');
            document.getElementById('measure-hint-outer').classList.add('hidden');
            
            // Show appropriate hint based on category
            if(cat === 'Button Shirt' || cat === 'Flannel') {
                document.getElementById('measure-hint-button-shirt').classList.remove('hidden');
            } else if(['Jeans','Pants','Shorts','Sweatpants'].includes(cat)) {
                document.getElementById('measure-hint-bottoms').classList.remove('hidden');
            } else if(['Jacket','Coat','Vest'].includes(cat)) {
                document.getElementById('measure-hint-outer').classList.remove('hidden');
            } else {
                document.getElementById('measure-hint-tops').classList.remove('hidden');
            }
            
            // Update sleeve-specific hints (standard/raglan/sleeveless)
            updateMeasurementHintsForSleeveStyle(data.sleeveStyle || 'Standard', data.sleeveLength || '');
        }
        
        function setTagStatus(status, btn) { 
            data.tagStatus = status; 
            document.querySelectorAll('.tag-btn').forEach(b => { 
                b.classList.remove('selected','btn-hero'); 
                b.classList.add('btn-secondary'); 
            }); 
            btn.classList.add('selected','btn-hero'); 
            btn.classList.remove('btn-secondary'); 
            document.getElementById('tag-details').classList.toggle('hidden', status !== 'has'); 
            document.getElementById('material-tag-warning').classList.toggle('hidden', status === 'has'); 
            
            // TAG CUT MODE: When tag is missing/cut, traits become mandatory, selections disabled
            tagCutMode = (status === 'cut' || status === 'missing');
            
            // Fabric tag cut section
            const fabricTagCutSection = document.getElementById('fabric-tag-cut-section');
            const fabricHelpBtn = document.getElementById('fabric-help-btn');
            const fabricHelpPanel = document.getElementById('fabric-help-panel');
            
            if(fabricTagCutSection) {
                fabricTagCutSection.classList.toggle('hidden', !tagCutMode);
            }
            if(fabricHelpBtn) {
                fabricHelpBtn.classList.toggle('hidden', tagCutMode);
            }
            if(fabricHelpPanel && tagCutMode) {
                fabricHelpPanel.classList.add('hidden');
            }
            
            // Material tag cut section
            const materialTagCutSection = document.getElementById('material-tag-cut-section');
            const materialHelpBtn = document.getElementById('material-help-btn');
            const materialHelpPanel = document.getElementById('material-help-panel');
            
            if(materialTagCutSection) {
                materialTagCutSection.classList.toggle('hidden', !tagCutMode);
            }
            if(materialHelpBtn) {
                materialHelpBtn.classList.toggle('hidden', tagCutMode);
            }
            if(materialHelpPanel && tagCutMode) {
                materialHelpPanel.classList.add('hidden');
            }
            
            // Re-render cards (they'll be disabled in tagCutMode)
            renderFabricCards();
            renderMaterialCards();
            updateValidation(); 
        }
        function setSize(size, btn) { data.tagSize = size; document.querySelectorAll('.size-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); btn.classList.add('selected','btn-hero'); btn.classList.remove('btn-secondary'); document.getElementById('tag-size-input').value=''; }
        function clearSizeBtns() { document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('selected')); }
        function onSizeInput(el) { data.tagSize = el.value.trim(); document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('selected')); }
        function setOrigin(origin, btn) { data.origin = origin; document.querySelectorAll('.origin-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); btn.classList.add('selected','btn-hero'); btn.classList.remove('btn-secondary'); document.getElementById('country-section').classList.toggle('hidden', origin !== 'import'); if(origin==='usa')data.country='USA'; }
        function setCountry(country, btn) { 
            document.querySelectorAll('.country-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); 
            btn.classList.add('selected','btn-hero'); btn.classList.remove('btn-secondary'); 
            if(country === 'Other') {
                document.getElementById('country-other-input').classList.remove('hidden');
                document.getElementById('country-other-input').focus();
            } else {
                document.getElementById('country-other-input').classList.add('hidden');
                document.getElementById('country-other-input').value = '';
                data.country = country;
            }
        }
        function onCountryOtherInput() { data.country = document.getElementById('country-other-input').value.trim(); }
        function setGender(gender, btn) { data.gender = gender; document.querySelectorAll('.gender-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); btn.classList.add('selected','btn-hero'); btn.classList.remove('btn-secondary'); }
        function toggleColor(color, btn) { const idx = data.colors.indexOf(color); if(idx>-1){data.colors.splice(idx,1);btn.classList.remove('selected');} else{data.colors.push(color);btn.classList.add('selected');} updateValidation(); }
        function setFade(fade, btn) { data.fade = fade; document.querySelectorAll('.fade-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); btn.classList.add('selected','btn-hero'); btn.classList.remove('btn-secondary'); updateValidation(); }
        function setPattern(pattern, btn) { 
            data.pattern = pattern; 
            document.querySelectorAll('.pattern-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); 
            btn.classList.add('selected','btn-hero'); 
            btn.classList.remove('btn-secondary'); 
            // Show/hide print type and graphic category sections for Graphic
            const showGraphicOptions = (pattern === 'Graphic');
            document.getElementById('print-type-section').classList.toggle('hidden', !showGraphicOptions);
            document.getElementById('graphic-category-section').classList.toggle('hidden', !showGraphicOptions);
            // Clear print type and graphic category if not Graphic
            if(!showGraphicOptions) { 
                data.printType = ''; data.graphicCategory = ''; 
                document.querySelectorAll('.print-btn, .graphic-cat-btn').forEach(b => b.classList.remove('selected','btn-hero')); 
            }
            updateValidation(); 
        }
        function toggleOtherPatterns() { 
            const el = document.getElementById('pattern-others'); 
            el.classList.toggle('hidden'); 
            document.getElementById('other-patterns-toggle').textContent = el.classList.contains('hidden') ? '+ More patterns' : '− Hide patterns'; 
        }
        function setPrintType(type, btn) { data.printType = type; document.querySelectorAll('.print-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); btn.classList.add('selected','btn-hero'); btn.classList.remove('btn-secondary'); }
        function setGraphicCategory(cat, btn) { data.graphicCategory = cat; document.querySelectorAll('.graphic-cat-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); btn.classList.add('selected','btn-hero'); btn.classList.remove('btn-secondary'); }
        function setSleeve(length, btn) { 
            data.sleeveLength = length; 
            document.querySelectorAll('.sleeve-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); 
            btn.classList.add('selected','btn-hero'); 
            btn.classList.remove('btn-secondary'); 
            // Hide sleeve style when None
            document.getElementById('sleeve-style-section').classList.toggle('hidden', length==='None'); 
            // Show cutoff section for T-Shirts when sleeveless
            const isTShirt = ['T-Shirt','Sweatshirt','Hoodie'].includes(data.category);
            document.getElementById('cutoff-section').classList.toggle('hidden', !(length==='None' && isTShirt));
            // Clear cutoff if not sleeveless
            if(length !== 'None') { data.cutoffType = ''; document.querySelectorAll('.cutoff-btn').forEach(b => b.classList.remove('selected','btn-hero')); }
            // Update measurement hints for sleeveless
            updateMeasurementHintsForSleeveStyle(data.sleeveStyle, length);
            // Update shot sequence - long sleeves need T-shape
            updateShotSequence();
            updateValidation(); 
        }
        function setCutoff(type, btn) { data.cutoffType = type; document.querySelectorAll('.cutoff-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); btn.classList.add('selected','btn-hero'); btn.classList.remove('btn-secondary'); }
        function setSleeveStyle(style, btn) { 
            data.sleeveStyle = style; 
            document.querySelectorAll('.style-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); 
            btn.classList.add('selected','btn-hero'); 
            btn.classList.remove('btn-secondary'); 
            // Show/hide measurement notice for Raglan/Dolman
            const notice = document.getElementById('sleeve-measurement-notice');
            if(notice) notice.classList.toggle('hidden', style === 'Standard');
            // Update measurement hints based on sleeve style
            updateMeasurementHintsForSleeveStyle(data.sleeveStyle, data.sleeveLength);
        }
        function updateMeasurementHintsForSleeveStyle(sleeveStyle, sleeveLength) {
            const isRaglanDolman = (sleeveStyle === 'Raglan' || sleeveStyle === 'Dolman');
            const isSleeveless = (sleeveLength === 'Sleeveless' || sleeveLength === 'None' || data.category === 'Tank' || data.category === 'Vest');
            
            // TOPS hints
            const topsStd = document.getElementById('measure-tops-standard');
            const topsRag = document.getElementById('measure-tops-raglan');
            const topsSleeveless = document.getElementById('measure-tops-sleeveless');
            if(topsStd) topsStd.classList.toggle('hidden', isRaglanDolman || isSleeveless);
            if(topsRag) topsRag.classList.toggle('hidden', !isRaglanDolman || isSleeveless);
            if(topsSleeveless) topsSleeveless.classList.toggle('hidden', !isSleeveless);
            
            // BUTTON SHIRT hints
            const btnStd = document.getElementById('measure-button-standard');
            const btnRag = document.getElementById('measure-button-raglan');
            const btnSleeveless = document.getElementById('measure-button-sleeveless');
            if(btnStd) btnStd.classList.toggle('hidden', isRaglanDolman || isSleeveless);
            if(btnRag) btnRag.classList.toggle('hidden', !isRaglanDolman || isSleeveless);
            if(btnSleeveless) btnSleeveless.classList.toggle('hidden', !isSleeveless);
            
            // OUTER hints
            const outerStd = document.getElementById('measure-outer-standard');
            const outerRag = document.getElementById('measure-outer-raglan');
            const outerSleeveless = document.getElementById('measure-outer-sleeveless');
            if(outerStd) outerStd.classList.toggle('hidden', isRaglanDolman || isSleeveless);
            if(outerRag) outerRag.classList.toggle('hidden', !isRaglanDolman || isSleeveless);
            if(outerSleeveless) outerSleeveless.classList.toggle('hidden', !isSleeveless);
        }
        function setStitch(stitch, btn) { data.stitch = stitch; document.querySelectorAll('.stitch-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); btn.classList.add('selected','btn-hero'); btn.classList.remove('btn-secondary'); }
        function setBodyConstruction(type, btn) { data.bodyConstruction = type; document.querySelectorAll('.body-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); btn.classList.add('selected','btn-hero'); btn.classList.remove('btn-secondary'); }
        
        // BOTTOMS: Leg Style Functions
        function setLegStyle(style, btn) { 
            data.legStyle = style; 
            document.querySelectorAll('.leg-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); 
            btn.classList.add('selected','btn-hero'); 
            btn.classList.remove('btn-secondary'); 
            updateValidation(); 
        }
        function setRise(rise, btn) { 
            data.rise = rise; 
            document.querySelectorAll('.rise-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); 
            btn.classList.add('selected','btn-hero'); 
            btn.classList.remove('btn-secondary'); 
        }
        function toggleLegStyleHelp() {
            document.getElementById('leg-style-help').classList.toggle('hidden');
        }
        
        function setThickness(thickness, btn) { data.thickness = thickness; document.querySelectorAll('.thickness-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); btn.classList.add('selected','btn-hero'); btn.classList.remove('btn-secondary'); updateValidation(); }
        function setLayers(layers, btn) { data.layers = layers; document.querySelectorAll('.layers-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); btn.classList.add('selected','btn-hero'); btn.classList.remove('btn-secondary'); updateValidation(); }
        function setWash(wash, btn) { data.wash = wash; document.querySelectorAll('.wash-btn').forEach(b => { b.classList.remove('selected','btn-hero'); b.classList.add('btn-secondary'); }); btn.classList.add('selected','btn-hero'); btn.classList.remove('btn-secondary'); }
        function setClean(btn) { data.hasDefects = false; data.defectTypes = []; document.getElementById('btn-clean').classList.remove('btn-secondary'); document.getElementById('btn-clean').classList.add('selected','btn-hero'); document.querySelectorAll('.defect-type-btn').forEach(b => b.classList.remove('selected')); updateValidation(); }
        function toggleDefect(type, btn) { document.getElementById('btn-clean').classList.remove('selected','btn-hero'); document.getElementById('btn-clean').classList.add('btn-secondary'); data.hasDefects = true; const idx = data.defectTypes.indexOf(type); if(idx>-1){data.defectTypes.splice(idx,1);btn.classList.remove('selected');} else{data.defectTypes.push(type);btn.classList.add('selected');} if(data.defectTypes.length===0){data.hasDefects=null;} updateValidation(); }
        
        // FLAG AS UNUSUAL
        function toggleFlagUnusual() { 
            data.flagged = !data.flagged; 
            const btn = document.getElementById('flag-btn');
            const flagStatus = document.getElementById('flag-status');
            if(data.flagged) {
                btn.classList.add('flagged');
                btn.querySelector('span:first-child').textContent = '🚩';
                btn.querySelector('span:last-of-type').textContent = 'FLAGGED FOR REVIEW';
                if(flagStatus) flagStatus.classList.remove('hidden');
            } else {
                btn.classList.remove('flagged');
                btn.querySelector('span:first-child').textContent = '🤔';
                btn.querySelector('span:last-of-type').textContent = 'FLAG AS UNUSUAL';
                if(flagStatus) flagStatus.classList.add('hidden');
            }
        }
        
        // ELASTIC CHECK (for sweatpants)
        function setElastic(elastic, btn) {
            data.elasticCheck = elastic;
            document.querySelectorAll('.elastic-btn').forEach(b => {
                b.classList.remove('selected','btn-hero');
                b.classList.add('btn-secondary');
            });
            btn.classList.add('selected','btn-hero');
            btn.classList.remove('btn-secondary');
        }
        function updateWeight() { data.weightLb = parseInt(document.getElementById('weight-lb').value); data.weightOz = parseInt(document.getElementById('weight-oz').value); updateValidation(); }
        
        async function activateSkuScan() {
            console.log('📷 SKU Scan button clicked');
            console.log(`   secondaryCameraId: ${secondaryCameraId?.slice(0,8) || 'null'}`);
            
            // Show status
            const statusEl = document.getElementById('sku-camera-status');
            if(statusEl) {
                statusEl.style.display = 'block';
                statusEl.textContent = '📷 Switching to C922X...';
                statusEl.style.color = '#f59e0b';
            }
            
            // Switch to SKU photo mode (this will switch camera)
            setPhotoMode('sku');
            
            // Wait for camera to switch and provide feedback
            await new Promise(r => setTimeout(r, 500));
            
            if(activeCameraId === secondaryCameraId) {
                if(statusEl) {
                    statusEl.textContent = '🔍 Scanning for barcode...';
                    statusEl.style.color = '#3b82f6';
                }
                // Start barcode scanning
                setTimeout(() => startBarcodeScanning(), 300);
            } else if(!secondaryCameraId) {
                if(statusEl) {
                    statusEl.textContent = '⚠️ No C922X camera detected - type SKU manually';
                    statusEl.style.color = '#ef4444';
                }
            } else {
                if(statusEl) {
                    statusEl.textContent = '⚠️ Camera switch may have failed - try again';
                    statusEl.style.color = '#ef4444';
                }
            }
            
            // Focus input for barcode scanner
            const skuInput = document.getElementById('sku-input');
            if(skuInput) {
                skuInput.value = '';
                skuInput.focus();
            }
        }
        
        function handleSkuKeydown(event) {
            // Barcode scanners typically send Enter after scanning
            if(event.key === 'Enter') {
                event.preventDefault();
                const skuInput = document.getElementById('sku-input');
                data.sku = skuInput.value.trim();
                
                if(data.sku) {
                    // Show success feedback
                    document.getElementById('sku-status').innerHTML = '✅ SKU scanned: <strong>' + data.sku + '</strong>';
                    document.getElementById('sku-status').style.color = '#16a34a';
                    console.log('📷 SKU scanned:', data.sku);
                    
                    // Update badge
                    const skuBadge = document.getElementById('sku-badge');
                    skuBadge.textContent = 'SKU: ' + data.sku;
                    skuBadge.classList.add('visible');
                    
                    // Switch back to main photo mode after successful scan
                    setTimeout(() => {
                        setPhotoMode('main');
                    }, 500);
                }
                
                skuInput.blur();
                updateValidation();
            }
        }
        
        // V99.45: Camera-based Barcode Scanning using QuaggaJS (works in all browsers)
        let quaggaRunning = false;
        
        async function startBarcodeScanning() {
            const statusEl = document.getElementById('sku-camera-status');
            if(statusEl) statusEl.style.display = 'block';
            
            // Check if Quagga loaded
            if(typeof Quagga === 'undefined') {
                if(statusEl) {
                    statusEl.innerHTML = '⚠️ Barcode library failed to load<br><small style="font-size:9px;">Type SKU manually or use USB scanner</small>';
                    statusEl.style.color = '#f59e0b';
                }
                console.log('❌ QuaggaJS not loaded');
                return;
            }
            
            stopBarcodeScanning(); // Clear any existing
            
            const video = document.getElementById('camera-video');
            if(!video.srcObject) {
                if(statusEl) {
                    statusEl.textContent = '⚠️ Camera not active';
                    statusEl.style.color = '#f59e0b';
                }
                return;
            }
            
            console.log('🔍 Starting QuaggaJS barcode scanning...');
            if(statusEl) {
                statusEl.textContent = '🔍 Scanning for barcode...';
                statusEl.style.color = '#3b82f6';
            }
            
            // Create a canvas to capture frames from video
            const scanCanvas = document.createElement('canvas');
            const scanCtx = scanCanvas.getContext('2d', { willReadFrequently: true });
            
            let scanCount = 0;
            
            barcodeScanInterval = setInterval(() => {
                if(!video.videoWidth || video.paused || video.ended) return;
                if(photoMode !== 'sku') {
                    stopBarcodeScanning();
                    return;
                }
                
                scanCount++;
                
                // Update status periodically
                if(scanCount % 5 === 0) {
                    statusEl.textContent = '🔍 Scanning... (point camera at barcode)';
                }
                
                // Capture current frame
                scanCanvas.width = video.videoWidth;
                scanCanvas.height = video.videoHeight;
                scanCtx.drawImage(video, 0, 0);
                
                // Decode using Quagga
                Quagga.decodeSingle({
                    src: scanCanvas.toDataURL('image/jpeg'),
                    numOfWorkers: 0, // Use main thread for speed
                    decoder: {
                        readers: ['code_128_reader', 'ean_reader', 'ean_8_reader', 'upc_reader', 'upc_e_reader', 'code_39_reader', 'codabar_reader', 'i2of5_reader']
                    },
                    locate: true
                }, function(result) {
                    if(result && result.codeResult) {
                        const barcodeValue = result.codeResult.code;
                        console.log('✅ Barcode detected:', barcodeValue, result.codeResult.format);
                        
                        // Fill in the SKU
                        const skuInput = document.getElementById('sku-input');
                        skuInput.value = barcodeValue;
                        data.sku = barcodeValue;
                        
                        // Show success
                        statusEl.textContent = '✅ Scanned: ' + barcodeValue;
                        statusEl.style.color = '#16a34a';
                        
                        document.getElementById('sku-status').innerHTML = '✅ SKU scanned: <strong>' + barcodeValue + '</strong>';
                        document.getElementById('sku-status').style.color = '#16a34a';
                        
                        // Update badge
                        const skuBadge = document.getElementById('sku-badge');
                        skuBadge.textContent = 'SKU: ' + barcodeValue;
                        skuBadge.classList.add('visible');
                        
                        // Play success beep
                        try {
                            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                            const oscillator = audioCtx.createOscillator();
                            const gainNode = audioCtx.createGain();
                            oscillator.connect(gainNode);
                            gainNode.connect(audioCtx.destination);
                            oscillator.frequency.value = 1200;
                            oscillator.type = 'sine';
                            gainNode.gain.value = 0.1;
                            oscillator.start();
                            setTimeout(() => oscillator.stop(), 100);
                        } catch(e) {}
                        
                        // Stop scanning
                        stopBarcodeScanning();
                        
                        // Switch back to main after delay
                        setTimeout(() => {
                            setPhotoMode('main');
                        }, 1000);
                        
                        updateValidation();
                    }
                });
            }, 300); // Scan ~3 times per second
        }
        
        function stopBarcodeScanning() {
            if(barcodeScanInterval) {
                clearInterval(barcodeScanInterval);
                barcodeScanInterval = null;
                console.log('🛑 Barcode scanning stopped');
            }
        }
        
        // Audio Recording with OpenAI Whisper API
        let parsedMeasurements = {};
        let measurementIndex = 0;
        let isTranscribing = false;
        
        // Word to number conversion
        const wordToNum = {
            'zero': 0, 'oh': 0,
            'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5,
            'six': 6, 'seven': 7, 'eight': 8, 'nine': 9, 'ten': 10,
            'eleven': 11, 'twelve': 12, 'thirteen': 13, 'fourteen': 14, 'fifteen': 15,
            'sixteen': 16, 'seventeen': 17, 'eighteen': 18, 'nineteen': 19,
            'twenty': 20, 'thirty': 30, 'forty': 40, 'fifty': 50
        };
        
        // Category-specific measurement templates
        const measurementTemplates = {
            'tops-standard': [
                'Neck-to-Shoulder', 'Top Sleeve', 'Sleeve Opening', 'Bottom Sleeve',
                'Shoulder-to-Shoulder', 'Pit-to-Pit', 'Waist', 'Bottom Hem', 'Length'
            ],
            'tops-raglan': [
                'Neck-to-Cuff', 'Sleeve Opening', 'Bottom Sleeve',
                'Pit-to-Pit', 'Waist', 'Bottom Hem', 'Length'
            ],
            'tops-sleeveless': [
                'Neck-to-Shoulder', 'Shoulder-to-Shoulder', 'Pit-to-Pit',
                'Waist', 'Bottom Hem', 'Length'
            ],
            'button-standard': [
                'Neck Circumference', 'Neck-to-Shoulder', 'Top Sleeve', 'Sleeve Opening',
                'Bottom Sleeve', 'Shoulder-to-Shoulder', 'Pit-to-Pit', 'Waist', 'Bottom Hem', 'Length'
            ],
            'button-raglan': [
                'Neck Circumference', 'Neck-to-Cuff', 'Sleeve Opening', 'Bottom Sleeve',
                'Pit-to-Pit', 'Waist', 'Bottom Hem', 'Length'
            ],
            'button-sleeveless': [
                'Neck Circumference', 'Neck-to-Shoulder', 'Shoulder-to-Shoulder',
                'Pit-to-Pit', 'Waist', 'Bottom Hem', 'Length'
            ],
            'bottoms': [
                'Waist', 'Rise', 'Inseam', 'Thigh', 'Leg Opening', 'Total Length'
            ],
            'outer-standard': [
                'Neck-to-Shoulder', 'Top Sleeve', 'Sleeve Opening', 'Bottom Sleeve',
                'Shoulder-to-Shoulder', 'Pit-to-Pit', 'Waist', 'Bottom Hem', 'Length'
            ],
            'outer-raglan': [
                'Neck-to-Cuff', 'Sleeve Opening', 'Bottom Sleeve',
                'Pit-to-Pit', 'Waist', 'Bottom Hem', 'Length'
            ],
            'outer-sleeveless': [
                'Neck-to-Shoulder', 'Shoulder-to-Shoulder', 'Pit-to-Pit',
                'Waist', 'Bottom Hem', 'Length'
            ]
        };
        
        // Get current measurement template based on category
        function getCurrentMeasurementTemplate() {
            const cat = data.category;
            const sleeveStyle = data.sleeveStyle || 'Standard';
            const sleeveLength = data.sleeveLength || '';
            
            let templateKey = 'tops-standard';
            
            if(cat === 'Button Shirt' || cat === 'Flannel') {
                if(sleeveStyle === 'Raglan' || sleeveStyle === 'Dolman') {
                    templateKey = 'button-raglan';
                } else if(sleeveLength === 'Sleeveless' || sleeveLength === 'Tank') {
                    templateKey = 'button-sleeveless';
                } else {
                    templateKey = 'button-standard';
                }
            } else if(['Jeans','Pants','Shorts','Sweatpants'].includes(cat)) {
                templateKey = 'bottoms';
            } else if(['Jacket','Coat','Vest'].includes(cat)) {
                if(sleeveStyle === 'Raglan' || sleeveStyle === 'Dolman') {
                    templateKey = 'outer-raglan';
                } else if(sleeveLength === 'Sleeveless' || cat === 'Vest') {
                    templateKey = 'outer-sleeveless';
                } else {
                    templateKey = 'outer-standard';
                }
            } else {
                // Regular tops (t-shirts, sweaters, etc)
                if(sleeveStyle === 'Raglan' || sleeveStyle === 'Dolman') {
                    templateKey = 'tops-raglan';
                } else if(sleeveLength === 'Sleeveless' || sleeveLength === 'Tank') {
                    templateKey = 'tops-sleeveless';
                } else {
                    templateKey = 'tops-standard';
                }
            }
            
            return measurementTemplates[templateKey] || measurementTemplates['tops-standard'];
        }
        
        function parseNumbersFromTranscript(text) {
            if (!text) return [];
            
            const numbers = [];
            let str = text.toLowerCase().replace(/-/g, ' ');
            
            console.log('🔢 Input:', str.substring(0, 100));
            
            // Fraction patterns → placeholders (order matters: longer patterns first)
            const fractionMap = [
                [/\bpoint\s+seven\s+five\b/g, 'FRAC75'],
                [/\bpoint\s+two\s+five\b/g, 'FRAC25'],
                [/\band\s+a\s+quarter\b/g, 'FRAC25'],
                [/\bpoint\s+five\b/g, 'FRAC5'],
                [/\band\s+a\s+half\b/g, 'FRAC5'],
                [/\bpoint\s+75\b/g, 'FRAC75'],
                [/\bpoint\s+25\b/g, 'FRAC25'],
                [/\bpoint\s+5\b/g, 'FRAC5']
            ];
            fractionMap.forEach(([pattern, placeholder]) => { 
                str = str.replace(pattern, ' ' + placeholder.toLowerCase() + ' '); 
            });
            
            console.log('🔢 After fractions:', str.substring(0, 100));
            
            // Remove punctuation and filler words
            str = str.replace(/[.,!?;:'"]+/g, ' ');
            const skip = new Set(['inches','inch','is','are','the','and','to','a','an','neck','shoulder','sleeve',
                'opening','bottom','top','pit','waist','hem','length','collar','cuff','width','from',
                'measurement','measurements','next','then','okay','um','uh','about','around','approximately',
                'for','at','of','its',"it's",'that','so','point','five','quarter','half','seven']);
            const tokens = str.split(/\s+/).filter(t => t && !skip.has(t));
            
            console.log('🔢 Tokens:', tokens);
            
            // Fraction placeholder → value
            const fracVal = { frac5: 0.5, frac25: 0.25, frac75: 0.75 };
            
            let i = 0;
            while (i < tokens.length) {
                const tok = tokens[i];
                
                // Handle standalone fraction (delayed: "eight... point five")
                if (fracVal[tok] !== undefined) {
                    if (numbers.length > 0 && numbers[numbers.length-1] === Math.floor(numbers[numbers.length-1])) {
                        numbers[numbers.length-1] += fracVal[tok];
                        console.log('🔢 Attached fraction:', fracVal[tok], '→', numbers[numbers.length-1]);
                    }
                    i++; continue;
                }
                
                // Parse number (direct or word)
                let num = parseFloat(tok);
                if (isNaN(num) && wordToNum[tok] !== undefined) num = wordToNum[tok];
                
                if (!isNaN(num) && num >= 1 && num < 100) {
                    let advance = 1;
                    
                    // Compound: "twenty two" → 22
                    if (num >= 20 && num < 100 && i+1 < tokens.length) {
                        const next = tokens[i+1];
                        if (wordToNum[next] !== undefined && wordToNum[next] < 10) {
                            num += wordToNum[next];
                            advance++;
                        }
                    }
                    
                    // Immediate fraction: "eight frac5" → 8.5
                    if (i + advance < tokens.length && fracVal[tokens[i+advance]] !== undefined) {
                        num += fracVal[tokens[i+advance]];
                        advance++;
                    }
                    
                    console.log('🔢 Number:', tok, '→', num);
                    numbers.push(num);
                    i += advance;
                } else {
                    i++;
                }
            }
            
            console.log('🔢 Final:', numbers);
            return numbers;
        }
        
        // ============ AI VISION ANALYSIS ============
        let aiAnalysisInProgress = false;
        
        async function analyzeTagWithAI(imageBlob) {
            if (aiAnalysisInProgress) return;
            aiAnalysisInProgress = true;
            
            console.log('🤖 Starting AI tag analysis...');
            const aiToast = showToast('info', '🤖 AI Analyzing Tag...', 'Reading brand, size, materials...', 30000);
            
            try {
                // Convert blob to base64
                const base64 = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = reject;
                    reader.readAsDataURL(imageBlob);
                });
                
                // Call Lambda vision endpoint
                const response = await fetch(LAMBDA_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'vision',
                        type: 'tag',
                        image: base64
                    })
                });
                
                const result = await response.json();
                console.log('🤖 AI response:', result);
                
                aiToast.remove();
                
                if (result.success && result.data) {
                    applyAISuggestions(result.data, 'tag');
                    const provider = result.provider === 'gemini' ? '(Gemini)' : '(Claude)';
                    showToast('success', `🤖 AI Analysis Complete ${provider}`, 'Fields auto-filled from tag', 3000);
                } else if (result.flagForManualReview) {
                    console.warn('🤖 AI flagged for manual review:', result.details);
                    showToast('warning', '🤖 AI Unavailable', 'Please fill in tag info manually', 3000);
                    data.flagged = true; // Flag item for review
                } else {
                    console.warn('🤖 AI analysis failed:', result.error);
                    showToast('warning', '🤖 AI Analysis', 'Could not read tag clearly', 2500);
                }
            } catch (err) {
                console.error('🤖 AI analysis error:', err);
                aiToast.remove();
                showToast('error', '🤖 AI Error', err.message, 2500);
            } finally {
                aiAnalysisInProgress = false;
            }
        }
        
        function applyAISuggestions(aiData, type) {
            console.log('🤖 Applying AI suggestions:', aiData);
            let fieldsUpdated = [];
            
            if (type === 'tag') {
                // Size
                if (aiData.size && !data.tagSize) {
                    data.tagSize = aiData.size;
                    fieldsUpdated.push('Size: ' + aiData.size);
                    // Update UI
                    document.querySelectorAll('#tag-size-options .chip-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.textContent.trim() === aiData.size);
                    });
                }
                
                // Country
                if (aiData.country && !data.country) {
                    data.country = aiData.country;
                    fieldsUpdated.push('Country: ' + aiData.country);
                    // Update origin dropdown
                    const countrySelect = document.getElementById('country-select');
                    if (countrySelect) {
                        countrySelect.value = aiData.country;
                        // Trigger change event
                        countrySelect.dispatchEvent(new Event('change'));
                    }
                }
                
                // Materials
                if (aiData.materials && aiData.materials.length > 0 && data.materials.length === 0) {
                    const materialNames = aiData.materials.map(m => m.material);
                    data.materials = materialNames;
                    fieldsUpdated.push('Materials: ' + materialNames.join(', '));
                    // Update material chips
                    document.querySelectorAll('#material-options .chip-btn').forEach(btn => {
                        const mat = btn.textContent.trim();
                        if (materialNames.includes(mat)) {
                            btn.classList.add('active');
                        }
                    });
                }
                
                // Tag condition → tagStatus
                if (aiData.tagCondition) {
                    const conditionMap = {
                        'excellent': 'Present',
                        'good': 'Present',
                        'faded': 'Faded',
                        'damaged': 'Faded',
                        'partial': 'Faded'
                    };
                    const status = conditionMap[aiData.tagCondition] || 'Present';
                    if (!data.tagStatus) {
                        data.tagStatus = status;
                        fieldsUpdated.push('Tag: ' + status);
                        document.querySelectorAll('#tag-status-options .chip-btn').forEach(btn => {
                            btn.classList.toggle('active', btn.textContent.trim() === status);
                        });
                    }
                }
                
                // Vintage indicators → origin
                if (aiData.vintageIndicators && aiData.vintageIndicators.length > 0) {
                    const indicators = aiData.vintageIndicators.map(v => v.toLowerCase());
                    if (indicators.some(v => v.includes('union') || v.includes('made in usa') || v.includes('single stitch'))) {
                        if (!data.origin) {
                            data.origin = 'Vintage';
                            fieldsUpdated.push('Origin: Vintage');
                            document.querySelectorAll('#origin-options .chip-btn').forEach(btn => {
                                btn.classList.toggle('active', btn.textContent.trim() === 'Vintage');
                            });
                        }
                    }
                }
                
                // Estimated era - just log for now
                if (aiData.estimatedEra) {
                    console.log('🤖 AI estimated era:', aiData.estimatedEra);
                    fieldsUpdated.push('Era: ~' + aiData.estimatedEra);
                }
                
                // Brand - log for reference (not a form field currently)
                if (aiData.brand) {
                    console.log('🤖 AI detected brand:', aiData.brand);
                    fieldsUpdated.push('Brand: ' + aiData.brand);
                }
            }
            
            // Main photo analysis
            if (type === 'main') {
                // Category
                if (aiData.category && !data.category) {
                    data.category = aiData.category;
                    fieldsUpdated.push('Category: ' + aiData.category);
                    // Update category buttons
                    document.querySelectorAll('.cat-btn').forEach(btn => {
                        const btnText = btn.textContent.replace(/[^\w\s-]/g, '').trim();
                        if (btnText.toUpperCase() === aiData.category.toUpperCase()) {
                            btn.click(); // Trigger the setCategory function
                        }
                    });
                }
                
                // Super Category
                if (aiData.superCategory && !data.superCategory) {
                    data.superCategory = aiData.superCategory;
                    fieldsUpdated.push('SuperCategory: ' + aiData.superCategory);
                }
                
                // Colors
                if (aiData.colors && aiData.colors.length > 0 && data.colors.length === 0) {
                    data.colors = aiData.colors;
                    fieldsUpdated.push('Colors: ' + aiData.colors.join(', '));
                    // Update color chips
                    document.querySelectorAll('#color-options .chip-btn').forEach(btn => {
                        const colorText = btn.textContent.trim();
                        if (aiData.colors.includes(colorText)) {
                            btn.classList.add('active');
                        }
                    });
                }
                
                // Pattern
                if (aiData.pattern && !data.pattern) {
                    data.pattern = aiData.pattern;
                    fieldsUpdated.push('Pattern: ' + aiData.pattern);
                    document.querySelectorAll('.pattern-btn').forEach(btn => {
                        if (btn.textContent.trim() === aiData.pattern) {
                            btn.click();
                        }
                    });
                }
                
                // Fabric Type
                if (aiData.fabricType && !data.fabricType) {
                    data.fabricType = aiData.fabricType;
                    fieldsUpdated.push('Fabric: ' + aiData.fabricType);
                }
                
                // Sleeve Length
                if (aiData.sleeveLength && !data.sleeveLength) {
                    data.sleeveLength = aiData.sleeveLength;
                    fieldsUpdated.push('Sleeve: ' + aiData.sleeveLength);
                    document.querySelectorAll('.sleeve-btn').forEach(btn => {
                        if (btn.textContent.trim() === aiData.sleeveLength) {
                            btn.click();
                        }
                    });
                }
                
                // Sleeve Style
                if (aiData.sleeveStyle && !data.sleeveStyle) {
                    data.sleeveStyle = aiData.sleeveStyle;
                    fieldsUpdated.push('Sleeve Style: ' + aiData.sleeveStyle);
                }
                
                // Gender
                if (aiData.gender && !data.gender) {
                    const genderMap = { 'mens': 'Mens', 'womens': 'Womens', 'unisex': 'Unisex' };
                    data.gender = genderMap[aiData.gender] || aiData.gender;
                    fieldsUpdated.push('Gender: ' + data.gender);
                }
                
                // Print Type
                if (aiData.printType && !data.printType) {
                    data.printType = aiData.printType;
                    fieldsUpdated.push('Print: ' + aiData.printType);
                }
                
                // Graphic Category
                if (aiData.graphicCategory && !data.graphicCategory) {
                    data.graphicCategory = aiData.graphicCategory;
                    fieldsUpdated.push('Graphic: ' + aiData.graphicCategory);
                }
                
                // Visible Defects - just log for now
                if (aiData.visibleDefects && aiData.visibleDefects.length > 0) {
                    console.log('🤖 AI detected potential defects:', aiData.visibleDefects);
                    fieldsUpdated.push('Defects detected: ' + aiData.visibleDefects.join(', '));
                }
            }
            
            // Log what was updated
            if (fieldsUpdated.length > 0) {
                console.log('🤖 Fields auto-filled:', fieldsUpdated);
            }
            
            updateValidation();
        }
        
        // Resize image for AI analysis (keeps full res for S3)
        async function resizeImageForAI(imageBlob, maxDimension = 1024, quality = 0.7) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    let { width, height } = img;
                    
                    // Calculate new dimensions maintaining aspect ratio
                    if (width > height && width > maxDimension) {
                        height = Math.round((height * maxDimension) / width);
                        width = maxDimension;
                    } else if (height > maxDimension) {
                        width = Math.round((width * maxDimension) / height);
                        height = maxDimension;
                    }
                    
                    // Create canvas and resize
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to base64
                    const base64 = canvas.toDataURL('image/jpeg', quality).split(',')[1];
                    console.log(`🤖 Resized image for AI: ${img.width}x${img.height} → ${width}x${height} (${Math.round(base64.length/1024)}KB)`);
                    resolve(base64);
                };
                img.onerror = reject;
                img.src = URL.createObjectURL(imageBlob);
            });
        }
        
        // Compress image for memory storage (returns blob, not base64)
        // Full res goes to S3, compressed version stays in RAM
        async function compressImageForMemory(imageBlob, maxDimension = 2048, quality = 0.7) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    let { width, height } = img;
                    const originalWidth = width;
                    const originalHeight = height;
                    
                    // Calculate new dimensions maintaining aspect ratio
                    if (width > height && width > maxDimension) {
                        height = Math.round((height * maxDimension) / width);
                        width = maxDimension;
                    } else if (height > maxDimension) {
                        width = Math.round((width * maxDimension) / height);
                        height = maxDimension;
                    }
                    
                    // Create canvas and resize
                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to blob
                    canvas.toBlob(compressedBlob => {
                        const origSizeMB = (imageBlob.size / 1024 / 1024).toFixed(2);
                        const newSizeMB = (compressedBlob.size / 1024 / 1024).toFixed(2);
                        console.log(`💾 Memory optimization: ${originalWidth}x${originalHeight} (${origSizeMB}MB) → ${width}x${height} (${newSizeMB}MB)`);
                        resolve(compressedBlob);
                    }, 'image/jpeg', quality);
                };
                img.onerror = reject;
                img.src = URL.createObjectURL(imageBlob);
            });
        }
        
        // Upload single main photo to S3 immediately (background upload)
        async function uploadMainPhotoToS3Immediately(fullResBlob, filename) {
            if (!data.sku) {
                console.warn('⚠️ No SKU set, skipping immediate S3 upload');
                return null;
            }
            
            try {
                console.log(`⬆️ Immediate S3 upload: ${filename}`);
                
                // Get presigned URL for this single file
                const fileInfo = { name: filename, folder: 'main' };
                const presignResult = await getPresignedUrls(data.sku, [fileInfo]);
                
                if (!presignResult.urls) {
                    throw new Error('No presigned URL returned');
                }
                
                // Find the URL (key format: {sku}/main/{filename})
                const s3Key = `${data.sku}/main/${filename}`;
                const presignedUrl = presignResult.urls[s3Key];
                
                if (!presignedUrl) {
                    console.error('❌ No presigned URL for key:', s3Key);
                    console.error('Available keys:', Object.keys(presignResult.urls));
                    throw new Error('Presigned URL not found');
                }
                
                // Upload
                await uploadToS3(presignedUrl, fullResBlob, filename);
                console.log(`✅ Immediate S3 upload complete: ${filename}`);
                
                return s3Key;
            } catch (err) {
                console.error(`❌ Immediate S3 upload failed for ${filename}:`, err);
                showToast('warning', 'S3 Upload', 'Photo will be uploaded on submit', 2000);
                return null;
            }
        }
        
        async function analyzeMainPhotoWithAI(imageBlob) {
            if (aiAnalysisInProgress) return;
            aiAnalysisInProgress = true;
            
            console.log('🤖 Starting AI main photo analysis...');
            const aiToast = showToast('info', '🤖 AI Analyzing Photo...', 'Detecting category, colors, pattern...', 30000);
            
            try {
                // Resize image for faster AI analysis (full res still goes to S3)
                const base64 = await resizeImageForAI(imageBlob, 1024, 0.75);
                
                // Call Lambda vision endpoint
                const response = await fetch(LAMBDA_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'vision',
                        type: 'main',
                        image: base64
                    })
                });
                
                const result = await response.json();
                console.log('🤖 AI main photo response:', result);
                
                aiToast.remove();
                
                if (result.success && result.data) {
                    applyAISuggestions(result.data, 'main');
                    const provider = result.provider === 'gemini' ? '(Gemini)' : '(Claude)';
                    showToast('success', `🤖 AI Analysis Complete ${provider}`, 'Fields auto-filled from photo', 3000);
                } else if (result.flagForManualReview) {
                    console.warn('🤖 AI flagged for manual review:', result.details);
                    showToast('warning', '🤖 AI Unavailable', 'Please fill in fields manually', 3000);
                    data.flagged = true; // Flag item for review
                } else {
                    console.warn('🤖 AI main photo analysis failed:', result.error);
                    showToast('warning', '🤖 AI Analysis', 'Could not analyze photo clearly', 2500);
                }
            } catch (err) {
                console.error('🤖 AI main photo analysis error:', err);
                aiToast.remove();
                showToast('error', '🤖 AI Error', err.message, 2500);
            } finally {
                aiAnalysisInProgress = false;
            }
        }
        
        // Send audio to Whisper via Lambda proxy (keeps API key secure)
        async function transcribeWithWhisper(audioBlob) {
            console.log('🎤 Sending audio to Whisper via Lambda...', audioBlob.size, 'bytes, type:', audioBlob.type);
            
            // Determine file extension from MIME type
            let fileExt = 'webm';
            if(audioBlob.type.includes('mp4') || audioBlob.type.includes('m4a')) {
                fileExt = 'mp4';
            } else if(audioBlob.type.includes('ogg')) {
                fileExt = 'ogg';
            } else if(audioBlob.type.includes('wav')) {
                fileExt = 'wav';
            } else if(audioBlob.type.includes('mpeg') || audioBlob.type.includes('mp3')) {
                fileExt = 'mp3';
            }
            
            // Convert blob to base64
            const base64Audio = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    // Remove data URL prefix (e.g., "data:audio/webm;base64,")
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = reject;
                reader.readAsDataURL(audioBlob);
            });
            
            console.log('🎤 Audio converted to base64, length:', base64Audio.length);
            
            try {
                const response = await fetch(LAMBDA_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        action: 'whisper',
                        audio: base64Audio,
                        filename: `audio.${fileExt}`,
                        language: 'en'
                    })
                });
                
                console.log('🎤 Lambda response status:', response.status);
                
                if(!response.ok) {
                    const errorText = await response.text();
                    console.error('🎤 Lambda Whisper error:', response.status, errorText);
                    throw new Error(`Whisper error: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('🎤 Whisper transcript:', result.text);
                return result.text;
            } catch(err) {
                console.error('🎤 Whisper transcription failed:', err);
                throw err;
            }
        }
        
        function showTranscriptionResults(transcript, numbers, template) {
            const measureCount = Object.keys(parsedMeasurements).length;
            const expectedCount = template.length;
            const isComplete = measureCount >= expectedCount;
            
            // Update transcript display
            document.getElementById('voice-transcript').textContent = `"${transcript}"`;
            document.getElementById('voice-transcript').style.fontStyle = 'italic';
            document.getElementById('voice-status').style.color = isComplete ? '#22c55e' : '#f59e0b';
            
            // Update parsed list
            let parsedHTML = '';
            if(measureCount > 0) {
                parsedHTML = Object.entries(parsedMeasurements).map(([k, v]) => 
                    `<div style="display:flex;justify-content:space-between;padding:2px 0;border-bottom:1px dashed #bfdbfe;">
                        <span>✓ ${k}</span>
                        <span style="font-weight:700;">${v}"</span>
                    </div>`
                ).join('');
                
                if(!isComplete) {
                    const missing = template.slice(measureCount);
                    parsedHTML += `<div style="margin-top:6px;color:#f59e0b;font-size:10px;">⚠️ Missing: ${missing.join(', ')}</div>`;
                } else {
                    parsedHTML += `<div style="margin-top:6px;color:#22c55e;font-weight:600;">✓ All ${expectedCount} measurements captured!</div>`;
                }
            } else {
                parsedHTML = '<span style="color:#f59e0b;">No numbers detected in audio.</span>';
            }
            document.getElementById('parsed-list').innerHTML = parsedHTML;
            
            // After delay, show final result view
            setTimeout(() => {
                document.getElementById('voice-transcript-section').classList.add('hidden');
                document.getElementById('record-section').classList.add('hidden');
                document.getElementById('post-record-section').classList.remove('hidden');
                updatePostRecordDisplay(measureCount, expectedCount, transcript);
            }, 2500);
        }
        
        function updatePostRecordDisplay(measureCount, expectedCount, transcript) {
            const duration = data.audioDuration;
            const isComplete = measureCount >= expectedCount;
            const statusColor = isComplete ? '#16a34a' : '#f59e0b';
            const statusIcon = isComplete ? '✓' : '⚠️';
            
            let resultHTML = `<div style="color:#16a34a;font-weight:700;font-size:14px;">✓ RECORDED</div>
                <div style="color:#22c55e;font-family:monospace;font-size:18px;">${formatTime(duration)}</div>`;
            
            if(measureCount > 0) {
                resultHTML += `<div style="margin-top:8px;padding-top:8px;border-top:1px solid #86efac;">
                    <div style="font-size:11px;color:${statusColor};font-weight:600;">${statusIcon} ${measureCount}/${expectedCount} measurements:</div>
                    <div style="font-size:11px;color:#166534;font-family:monospace;margin-top:4px;line-height:1.5;">
                        ${Object.entries(parsedMeasurements).map(([k,v]) => `${k}: ${v}"`).join('<br>')}
                    </div>
                </div>`;
            } else {
                resultHTML += `<div style="margin-top:8px;font-size:11px;color:#94a3b8;">No measurements detected.<br>Audio saved for manual review.</div>`;
            }
            
            if(transcript && transcript !== '(transcription failed)') {
                // Show more of transcript (300 chars instead of 100)
                const displayTranscript = transcript.length > 300 ? transcript.substring(0, 300) + '...' : transcript;
                resultHTML += `<div style="margin-top:6px;font-size:9px;color:#94a3b8;font-style:italic;border-top:1px dashed #e2e8f0;padding-top:6px;max-height:60px;overflow-y:auto;">"${displayTranscript}"</div>`;
                console.log('📝 Full transcript length:', transcript.length, 'chars');
                console.log('📝 Full transcript:', transcript);
            }
            
            document.getElementById('post-record-section').querySelector('.nested-section').innerHTML = resultHTML;
        }
        
        async function toggleRecording() {
            if(mediaRecorder && mediaRecorder.state === 'recording') { 
                stopRecording(); 
                return; 
            }
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({audio: true});
                
                // Determine supported MIME type
                let mimeType = 'audio/webm';
                if(!MediaRecorder.isTypeSupported('audio/webm')) {
                    if(MediaRecorder.isTypeSupported('audio/mp4')) {
                        mimeType = 'audio/mp4';
                    } else if(MediaRecorder.isTypeSupported('audio/ogg')) {
                        mimeType = 'audio/ogg';
                    } else {
                        mimeType = ''; // Let browser choose default
                    }
                }
                console.log('🎤 Using MIME type:', mimeType || 'browser default');
                
                const options = mimeType ? { mimeType } : {};
                mediaRecorder = new MediaRecorder(stream, options);
                audioChunks = [];
                parsedMeasurements = {};
                measurementIndex = 0;
                
                mediaRecorder.ondataavailable = e => {
                    console.log('🎤 Audio chunk received:', e.data.size, 'bytes');
                    if(e.data.size > 0) {
                        audioChunks.push(e.data);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    console.log('🎤 Recording stopped, chunks:', audioChunks.length);
                    const actualMimeType = mediaRecorder.mimeType || 'audio/webm';
                    const blob = new Blob(audioChunks, {type: actualMimeType});
                    console.log('🎤 Audio blob created:', blob.size, 'bytes, type:', blob.type);
                    
                    data.audioMeasure = blob;
                    data.audioMimeType = actualMimeType; // Store MIME type for S3 upload
                    stream.getTracks().forEach(t => t.stop());
                    
                    // Show transcribing state
                    isTranscribing = true;
                    document.getElementById('voice-transcript-section').classList.remove('hidden');
                    document.getElementById('voice-transcript').textContent = '🔄 Transcribing with Whisper AI...';
                    document.getElementById('voice-status').style.color = '#f59e0b';
                    document.getElementById('parsed-list').innerHTML = '<span style="color:#94a3b8;">Processing audio...</span>';
                    
                    try {
                        // Send to Whisper
                        const transcript = await transcribeWithWhisper(blob);
                        
                        // Parse numbers from transcript
                        const numbers = parseNumbersFromTranscript(transcript);
                        console.log('🎤 Parsed numbers:', numbers);
                        
                        // Map numbers to measurement template
                        const template = getCurrentMeasurementTemplate();
                        numbers.forEach((num, idx) => {
                            if(idx < template.length) {
                                parsedMeasurements[template[idx]] = num;
                            }
                        });
                        
                        data.parsedMeasurements = {...parsedMeasurements};
                        data.audioTranscript = transcript;
                        
                        // Show results
                        showTranscriptionResults(transcript, numbers, template);
                        
                    } catch(err) {
                        console.error('🎤 Transcription failed:', err);
                        showToast('error', 'Transcription Failed', err.message, 3000);
                        
                        // Show error state but keep audio
                        document.getElementById('voice-transcript').textContent = '❌ Transcription failed - audio saved';
                        document.getElementById('voice-status').style.color = '#ef4444';
                        document.getElementById('parsed-list').innerHTML = '<span style="color:#ef4444;">Could not transcribe. Audio saved for manual review.</span>';
                        
                        setTimeout(() => {
                            document.getElementById('voice-transcript-section').classList.add('hidden');
                            document.getElementById('record-section').classList.add('hidden');
                            document.getElementById('post-record-section').classList.remove('hidden');
                            updatePostRecordDisplay(0, getCurrentMeasurementTemplate().length, '(transcription failed)');
                        }, 2000);
                    }
                    
                    isTranscribing = false;
                    updateValidation();
                };
                
                // Start with timeslice to ensure ondataavailable fires periodically
                mediaRecorder.start(1000); // Collect data every 1 second
                recordingStart = Date.now();
                trackAudioAttemptStart();
                
                // Show recording UI
                document.getElementById('voice-transcript-section').classList.remove('hidden');
                document.getElementById('voice-transcript').textContent = '🎤 Recording... speak your measurements';
                document.getElementById('voice-status').style.color = '#22c55e';
                const template = getCurrentMeasurementTemplate();
                document.getElementById('parsed-list').innerHTML = `<span style="color:#94a3b8;">Say ${template.length} numbers in order:<br><strong>${template.join(' → ')}</strong></span>`;
                
                document.getElementById('record-btn').innerHTML = '<span style="font-size:24px;">⏹️</span><span>RECORDING...</span>';
                document.getElementById('record-btn').style.background = '#dc2626';
                document.getElementById('record-btn').classList.add('recording');
                recordingInterval = setInterval(updateRecordingTime, 1000);
                trackClick('audio');
                
            } catch(e) { 
                console.error('🎤 Microphone error:', e);
                showToast('error', 'Microphone Error', 'Microphone access denied'); 
            }
        }
        
        function stopRecording() {
            if(mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                clearInterval(recordingInterval);
                
                const duration = Math.floor((Date.now() - recordingStart) / 1000);
                data.audioDuration = duration;
                trackAudioAttemptEnd('completed');
                
                // UI will be updated in mediaRecorder.onstop after Whisper processes
                document.getElementById('record-btn').innerHTML = '<span style="font-size:24px;">🔄</span><span>PROCESSING...</span>';
                document.getElementById('record-btn').style.background = '#f59e0b';
            }
        }
        function updateRecordingTime() {
            const elapsed = Math.floor((Date.now() - recordingStart) / 1000);
            document.getElementById('record-btn').querySelector('span:last-child').textContent = `RECORDING ${formatTime(elapsed)}`;
        }
        function reRecord() {
            // Track that the previous recording was discarded (not abandoned mid-recording)
            if(data.audioMeasure && metrics && metrics.audio.attempts.length > 0) {
                // Mark the last completed attempt as 'discarded'
                const lastAttempt = metrics.audio.attempts[metrics.audio.attempts.length - 1];
                if(lastAttempt.outcome === 'completed') {
                    lastAttempt.outcome = 'discarded';
                }
            }
            data.audioMeasure = null; 
            data.audioDuration = 0;
            data.parsedMeasurements = {};
            data.audioTranscript = '';
            parsedMeasurements = {};
            measurementIndex = 0;
            
            document.getElementById('record-section').classList.remove('hidden');
            document.getElementById('voice-transcript-section').classList.add('hidden');
            document.getElementById('post-record-section').classList.add('hidden');
            document.getElementById('record-btn').innerHTML = '<span style="font-size:24px;">🎤</span><span>TAP TO RECORD</span>';
            document.getElementById('record-btn').style.background = '#ef4444';
            document.getElementById('record-btn').classList.remove('recording');
            trackClick('audio'); // Track click
            updateValidation();
        }
        function formatTime(s) { return `${Math.floor(s/60)}:${(s%60).toString().padStart(2,'0')}`; }
        
        function renderFabricCards() { 
            const grid = document.getElementById('fabric-cards-grid'); 
            const fabrics = fabricDB[data.category] || fabricDB['default']; 
            grid.innerHTML = ''; 
            fabrics.forEach(fab=>{ 
                let dimmed = false; 
                if(fabricFilters.stretch && fab.traits.stretch !== fabricFilters.stretch) dimmed = true; 
                if(fabricFilters.surface && fab.traits.surface !== fabricFilters.surface) dimmed = true; 
                if(fabricFilters.interior && fab.traits.interior !== fabricFilters.interior) dimmed = true; 
                const card = document.createElement('div'); 
                // In tagCutMode, all cards are visually dimmed and not clickable
                const disabled = tagCutMode;
                // Only show priority-1 (default) styling if NO fabric is selected yet
                const showDefault = fab.default && !data.fabricType;
                card.className = `card ${showDefault?'priority-1':''} ${data.fabricType===fab.name?'selected':''} ${dimmed||disabled?'dimmed':''}`;
                card.innerHTML = `<button class="card-help" onclick="event.stopPropagation(); showFabricHelp('${fab.name}', '${fab.desc.replace(/'/g, "\\'")}');">?</button><div class="card-name">${fab.name}</div><div class="card-desc">${fab.desc}</div>`; 
                if(!dimmed && !disabled) card.onclick = ()=>{ 
                    data.fabricType = fab.name; 
                    document.getElementById('wash-section').classList.toggle('hidden', fab.name!=='Denim'); 
                    renderFabricCards(); 
                    updateValidation(); 
                }; 
                grid.appendChild(card); 
            }); 
        }
        function showFabricHelp(name, desc) {
            openRefModal(name, desc, 'fabric');
        }
        function openRefModal(name, desc, type) {
            document.getElementById('ref-modal-title').textContent = name;
            document.getElementById('ref-modal-desc').textContent = desc;
            
            // Build Google image search URL
            let query = `${name} fabric texture close up`;
            if (name === 'Knit') query = 'knit t-shirt fabric texture close up';
            if (name === 'Jersey') query = 'jersey knit fabric texture athletic';
            if (name === 'Fleece') query = 'fleece fabric fuzzy inside sweatshirt';
            if (name === 'French Terry') query = 'french terry fabric loops inside';
            if (name === 'Selvage') query = 'selvage denim red line cuff';
            if (name === 'Pique') query = 'pique polo shirt fabric texture';
            if (name === 'Flannel') query = 'flannel shirt fabric brushed soft';
            if (name === 'Denim') query = 'denim fabric diagonal weave';
            if (name === 'Corduroy') query = 'corduroy fabric ridges texture';
            if (name === 'Mesh') query = 'mesh athletic fabric see through';
            if (name === '50/50 Blend') query = '50 50 cotton polyester blend t-shirt';
            if (name === 'Tri-Blend') query = 'tri-blend t-shirt fabric soft';
            if (name === 'Cotton') query = 'cotton fabric texture matte';
            if (name === 'Polyester') query = 'polyester fabric sheen synthetic';
            if (name === 'Wool') query = 'wool fabric texture sweater';
            if (name === 'Cashmere') query = 'cashmere fabric soft luxury';
            if (name === 'Rayon') query = 'rayon fabric silky drapey';
            if (name === 'Nylon') query = 'nylon windbreaker fabric shiny';
            if (name === 'Leather') query = 'leather jacket texture patina';
            
            // Pattern queries
            if (name === 'Solid') query = 'solid color t-shirt plain blank';
            if (name === 'Graphic') query = 'graphic tee print band shirt logo';
            if (name === 'Striped') query = 'striped shirt pattern sailor stripe';
            if (name === 'Color Block') query = 'color block shirt 90s panel';
            if (name === 'Plaid') query = 'plaid flannel pattern tartan buffalo check';
            if (name === 'Tie Dye') query = 'tie dye shirt spiral pattern';
            if (name === 'Camo') query = 'camo camouflage pattern military';
            if (name === 'Embroidered') query = 'embroidered shirt logo stitched';
            if (name === 'Polka Dot') query = 'polka dot pattern shirt dress';
            if (name === 'Paisley') query = 'paisley pattern bandana western shirt';
            if (name === 'Floral') query = 'floral pattern hawaiian shirt roses';
            if (name === 'Animal') query = 'animal print leopard zebra tiger';
            if (name === 'Geometric') query = 'geometric pattern 80s aztec chevron';
            if (name === 'Checkered') query = 'checkered pattern checkerboard vans';
            if (name === 'Houndstooth') query = 'houndstooth pattern coat jacket';
            if (name === 'Herringbone') query = 'herringbone pattern tweed suit';
            if (name === 'Abstract') query = 'abstract pattern 80s splatter';
            
            document.getElementById('ref-modal-link').href = `https://www.google.com/search?tbm=isch&q=${encodeURIComponent(query)}`;
            document.getElementById('ref-modal-overlay').classList.add('visible');
        }
        function closeRefModal() {
            document.getElementById('ref-modal-overlay').classList.remove('visible');
        }
        function toggleFabricHelp() { document.getElementById('fabric-help-panel').classList.toggle('hidden'); }
        function toggleFabricFilter(type, value, btn) { 
            if(fabricFilters[type]===value){
                fabricFilters[type]=null;
                data.fabricTraits[type]='';
                btn.classList.remove('active');
            } 
            else{
                fabricFilters[type]=value;
                data.fabricTraits[type]=value;
                // Only deselect same-type buttons
                btn.parentElement.querySelectorAll('.filter-btn').forEach(b=>b.classList.remove('active'));
                btn.classList.add('active');
            } 
            renderFabricCards(); 
            updateFabricAdvice();
        }
        
        function updateFabricAdvice() {
            const helper = document.getElementById('fabric-helper');
            const helperTagcut = document.getElementById('fabric-helper-tagcut');
            const advice = getFabricAdvice();
            
            if(helper) {
                if(advice){helper.innerHTML=advice;helper.classList.remove('hidden');} 
                else helper.classList.add('hidden');
            }
            if(helperTagcut && tagCutMode) {
                helperTagcut.innerHTML = advice || '<span style="color:#6b7280;">Select traits above to see fabric matches</span>';
            }
        }
        
        // V99.45: TRULY DYNAMIC fabric advice based on actual fabricDB filtering
        function getFabricAdvice() {
            const cat = data.category || 'T-Shirt';
            const f = fabricFilters;
            const activeFilters = Object.values(f).filter(Boolean).length;
            
            if(activeFilters === 0) return '';
            
            // Get fabrics for this category
            const fabrics = fabricDB[cat] || fabricDB['default'];
            
            // TRULY DYNAMIC: Filter fabrics based on ALL selected traits
            const matches = fabrics.filter(fab => {
                if(f.stretch && fab.traits.stretch !== f.stretch) return false;
                if(f.surface && fab.traits.surface !== f.surface) return false;
                if(f.interior && fab.traits.interior !== f.interior) return false;
                return true;
            });
            
            // Build trait description for display
            const traitDesc = [];
            if(f.stretch) traitDesc.push(f.stretch === 'high' ? 'Stretchy' : 'Rigid');
            if(f.surface) traitDesc.push(f.surface === 'smooth' ? 'Smooth surface' : f.surface === 'diagonal' ? 'Diagonal weave' : f.surface === 'ridged' ? 'Ridged' : 'Textured');
            if(f.interior) traitDesc.push(f.interior === 'smooth' ? 'Smooth inside' : f.interior === 'fuzzy' ? 'Fuzzy inside' : 'Loops inside');
            
            // Build dynamic advice based on actual matches
            if(matches.length === 0) {
                // No matches - this combination is unusual for this category
                return `<div style="color:#b91c1c;"><strong>⚠️ Unusual combination for ${cat}!</strong></div>` +
                       `<div style="margin:4px 0;">${traitDesc.join(' + ')}</div>` +
                       `<div style="font-style:italic;font-size:10px;">This doesn't match any typical ${cat} fabrics. Double-check: Is this really a ${cat}?</div>`;
            } 
            else if(matches.length === 1) {
                // Perfect! One exact match
                const m = matches[0];
                return `<div style="color:#16a34a;"><strong>✅ That's ${m.name}!</strong></div>` +
                       `<div style="margin:4px 0;font-size:11px;">${m.desc}</div>`;
            } 
            else if(matches.length === 2) {
                // Two possibilities
                return `<div style="color:#2563eb;"><strong>💡 Could be one of these:</strong></div>` +
                       `<div style="margin:4px 0;font-size:11px;">` +
                       `<strong>${matches[0].name}</strong> – ${matches[0].desc}<br>` +
                       `<strong>${matches[1].name}</strong> – ${matches[1].desc}</div>` +
                       `<div style="font-style:italic;font-size:10px;">Add more traits to narrow down!</div>`;
            } 
            else {
                // Multiple matches - show them all
                let html = `<div style="color:#2563eb;"><strong>💡 ${matches.length} possible fabrics:</strong></div><div style="margin:4px 0;font-size:11px;">`;
                matches.forEach(m => {
                    html += `<strong>${m.name}</strong> – ${m.desc}<br>`;
                });
                html += `</div><div style="font-style:italic;font-size:10px;">Add more traits to narrow down!</div>`;
                return html;
            }
        }
        
        function renderMaterialCards() { 
            const grid = document.getElementById('material-cards-grid'); 
            const materials = materialDB[data.category] || materialDB['default']; 
            grid.innerHTML = ''; 
            materials.forEach(mat=>{ 
                let dimmed = false; 
                if(materialFilters.temp && mat.traits.temp !== materialFilters.temp) dimmed = true; 
                if(materialFilters.shine && mat.traits.shine !== materialFilters.shine) dimmed = true; 
                const card = document.createElement('div'); 
                // In tagCutMode, all cards are visually dimmed and not clickable
                const disabled = tagCutMode;
                // Only show priority-1 (default) styling if NO materials selected yet
                const showDefault = mat.default && data.materials.length === 0;
                const isSelected = data.materials.includes(mat.name);
                card.className = `card ${showDefault?'priority-1':''} ${isSelected?'selected':''} ${dimmed||disabled?'dimmed':''}`;
                card.innerHTML = `<button class="card-help" onclick="event.stopPropagation(); showMaterialHelp('${mat.name}', '${mat.desc.replace(/'/g, "\\'")}');">?</button><div class="card-name">${mat.name}</div><div class="card-desc">${mat.desc}</div>`; 
                if(!dimmed && !disabled) card.onclick = ()=>{ 
                    // Toggle selection (multi-select like colors)
                    const idx = data.materials.indexOf(mat.name);
                    if(idx > -1) {
                        data.materials.splice(idx, 1);
                    } else {
                        data.materials.push(mat.name);
                    }
                    document.getElementById('material-other-select').value=''; 
                    document.getElementById('material-custom-input').classList.add('hidden'); 
                    renderMaterialCards(); 
                    updateValidation(); 
                }; 
                grid.appendChild(card); 
            }); 
        }
        function showMaterialHelp(name, desc) {
            openRefModal(name, desc, 'material');
        }
        function onMaterialOtherChange() {
            const val = document.getElementById('material-other-select').value;
            if(!val) return;
            if(val === 'Custom') {
                document.getElementById('material-custom-input').classList.remove('hidden');
                document.getElementById('material-custom-input').focus();
            } else {
                document.getElementById('material-custom-input').classList.add('hidden');
                // Add to materials array if not already present
                if(!data.materials.includes(val)) {
                    data.materials.push(val);
                }
                renderMaterialCards();
                updateValidation();
            }
        }
        function onMaterialCustomInput() {
            const val = document.getElementById('material-custom-input').value.trim();
            if(val) {
                // Add custom material to array if not already present
                if(!data.materials.includes(val)) {
                    data.materials.push(val);
                }
                renderMaterialCards();
                updateValidation();
            }
        }
        
        // V99.45: Pattern Cards with ? help buttons
        function renderPatternCards() {
            const mainGrid = document.getElementById('pattern-cards-grid');
            const othersGrid = document.getElementById('pattern-cards-others');
            
            // Main patterns (priority 1-2)
            const mainPatterns = patternDB.filter(p => p.priority <= 2);
            // Other patterns (priority 3+)
            const otherPatterns = patternDB.filter(p => p.priority > 2);
            
            mainGrid.innerHTML = '';
            mainPatterns.forEach(pat => {
                const card = document.createElement('div');
                // Only show priority-1 (default) styling if NO pattern is selected yet
                const showDefault = pat.default && !data.pattern;
                card.className = `card ${showDefault?'priority-1':''} ${data.pattern===pat.name?'selected':''}`;
                card.innerHTML = `<button class="card-help" onclick="event.stopPropagation(); showPatternHelp('${pat.name}', '${pat.desc.replace(/'/g, "\\'")}', '${pat.examples.replace(/'/g, "\\'")}');">?</button><div class="card-name">${pat.name}</div><div class="card-desc">${pat.desc}</div>`;
                card.onclick = () => selectPattern(pat.name);
                mainGrid.appendChild(card);
            });
            
            othersGrid.innerHTML = '';
            otherPatterns.forEach(pat => {
                const card = document.createElement('div');
                card.className = `card ${data.pattern===pat.name?'selected':''}`;
                card.innerHTML = `<button class="card-help" onclick="event.stopPropagation(); showPatternHelp('${pat.name}', '${pat.desc.replace(/'/g, "\\'")}', '${pat.examples.replace(/'/g, "\\'")}');">?</button><div class="card-name">${pat.name}</div><div class="card-desc">${pat.desc}</div>`;
                card.onclick = () => selectPattern(pat.name);
                othersGrid.appendChild(card);
            });
        }
        
        function selectPattern(name) {
            data.pattern = name;
            renderPatternCards();
            
            // Show/hide print type and graphic category sections for Graphic
            const showGraphicOptions = (name === 'Graphic');
            document.getElementById('print-type-section').classList.toggle('hidden', !showGraphicOptions);
            document.getElementById('graphic-category-section').classList.toggle('hidden', !showGraphicOptions);
            // Clear print type and graphic category if not Graphic
            if(!showGraphicOptions) { 
                data.printType = ''; 
                data.graphicCategory = ''; 
                document.querySelectorAll('.print-btn, .graphic-cat-btn').forEach(b => b.classList.remove('selected','btn-hero')); 
            }
            
            updateValidation();
        }
        
        function showPatternHelp(name, desc, examples) {
            document.getElementById('ref-modal-title').textContent = name;
            document.getElementById('ref-modal-desc').textContent = desc + '\n\nExamples: ' + examples;
            
            // Build Google image search URL
            let query = name + ' pattern clothing';
            if (name === 'Solid') query = 'solid color t-shirt plain blank';
            if (name === 'Graphic') query = 'graphic tee print band shirt logo';
            if (name === 'Striped') query = 'striped shirt pattern sailor stripe';
            if (name === 'Color Block') query = 'color block shirt 90s panel';
            if (name === 'Plaid') query = 'plaid flannel pattern tartan buffalo check';
            if (name === 'Tie Dye') query = 'tie dye shirt spiral pattern';
            if (name === 'Camo') query = 'camo camouflage pattern military';
            if (name === 'Embroidered') query = 'embroidered shirt logo stitched';
            if (name === 'Polka Dot') query = 'polka dot pattern shirt dress';
            if (name === 'Paisley') query = 'paisley pattern bandana western shirt';
            if (name === 'Floral') query = 'floral pattern hawaiian shirt roses';
            if (name === 'Animal') query = 'animal print leopard zebra tiger';
            if (name === 'Geometric') query = 'geometric pattern 80s aztec chevron';
            if (name === 'Checkered') query = 'checkered pattern checkerboard vans';
            if (name === 'Houndstooth') query = 'houndstooth pattern coat jacket';
            if (name === 'Herringbone') query = 'herringbone pattern tweed suit';
            if (name === 'Abstract') query = 'abstract pattern 80s splatter';
            
            document.getElementById('ref-modal-link').href = `https://www.google.com/search?tbm=isch&q=${encodeURIComponent(query)}`;
            document.getElementById('ref-modal-overlay').classList.add('visible');
        }
        
        function onFabricOtherChange() {
            const val = document.getElementById('fabric-other-select').value;
            if(!val) return;
            if(val === 'Custom') {
                document.getElementById('fabric-custom-input').classList.remove('hidden');
                document.getElementById('fabric-custom-input').focus();
            } else {
                document.getElementById('fabric-custom-input').classList.add('hidden');
                data.fabricType = val;
                // Deselect cards
                document.querySelectorAll('#fabric-cards-grid .card').forEach(c => c.classList.remove('selected'));
                document.getElementById('wash-section').classList.add('hidden');
                updateValidation();
            }
        }
        function onFabricCustomInput() {
            const val = document.getElementById('fabric-custom-input').value.trim();
            if(val) {
                data.fabricType = val;
                document.querySelectorAll('#fabric-cards-grid .card').forEach(c => c.classList.remove('selected'));
                document.getElementById('wash-section').classList.add('hidden');
                updateValidation();
            }
        }
        function toggleMaterialHelp() { document.getElementById('material-help-panel').classList.toggle('hidden'); }
        function toggleMaterialFilter(type, value, btn) { 
            if(materialFilters[type]===value){
                materialFilters[type]=null;
                data.materialTraits[type]='';
                btn.classList.remove('active');
            } 
            else{
                materialFilters[type]=value;
                data.materialTraits[type]=value;
                btn.parentElement.querySelectorAll('.filter-btn').forEach(b=>b.classList.remove('active'));
                btn.classList.add('active');
            } 
            renderMaterialCards(); 
            updateMaterialAdvice();
        }
        
        function updateMaterialAdvice() {
            const helper = document.getElementById('material-helper');
            const helperTagcut = document.getElementById('material-helper-tagcut');
            const advice = getMaterialAdvice();
            
            if(helper) {
                if(advice){helper.innerHTML=advice;helper.classList.remove('hidden');} 
                else helper.classList.add('hidden');
            }
            if(helperTagcut && tagCutMode) {
                helperTagcut.innerHTML = advice || '<span style="color:#6b7280;">Select traits above to see material matches</span>';
            }
        }
        // V99.45: TRULY DYNAMIC material advice based on actual materialDB filtering
        function getMaterialAdvice() {
            const cat = data.category || 'T-Shirt';
            const m = materialFilters;
            const activeFilters = Object.values(m).filter(Boolean).length;
            
            if(activeFilters === 0) return '';
            
            // Get materials for this category
            const materials = materialDB[cat] || materialDB['default'];
            
            // TRULY DYNAMIC: Filter materials based on ALL selected traits
            const matches = materials.filter(mat => {
                if(m.temp && mat.traits.temp !== m.temp) return false;
                if(m.shine && mat.traits.shine !== m.shine) return false;
                return true;
            });
            
            // Build trait description for display
            const traitDesc = [];
            if(m.temp) traitDesc.push(m.temp === 'cool' ? 'Cool to touch' : 'Warm to touch');
            if(m.shine) traitDesc.push(m.shine === 'matte' ? 'Matte (no shine)' : 'Has sheen/shine');
            
            // Build dynamic advice based on actual matches
            if(matches.length === 0) {
                // No matches - this combination is unusual for this category
                return `<div style="color:#b91c1c;"><strong>⚠️ Unusual combination for ${cat}!</strong></div>` +
                       `<div style="margin:4px 0;">${traitDesc.join(' + ')}</div>` +
                       `<div style="font-style:italic;font-size:10px;">This doesn't match typical ${cat} materials. Check the "Other materials" dropdown.</div>`;
            } 
            else if(matches.length === 1) {
                // Perfect! One exact match
                const mat = matches[0];
                return `<div style="color:#16a34a;"><strong>✅ That's ${mat.name}!</strong></div>` +
                       `<div style="margin:4px 0;font-size:11px;">${mat.desc}</div>`;
            } 
            else if(matches.length === 2) {
                // Two possibilities
                return `<div style="color:#2563eb;"><strong>💡 Could be one of these:</strong></div>` +
                       `<div style="margin:4px 0;font-size:11px;">` +
                       `<strong>${matches[0].name}</strong> – ${matches[0].desc}<br>` +
                       `<strong>${matches[1].name}</strong> – ${matches[1].desc}</div>`;
            } 
            else {
                // Multiple matches - show them all
                let html = `<div style="color:#2563eb;"><strong>💡 ${matches.length} possible materials:</strong></div><div style="margin:4px 0;font-size:11px;">`;
                matches.forEach(mat => {
                    html += `<strong>${mat.name}</strong> – ${mat.desc}<br>`;
                });
                html += `</div>`;
                return html;
            }
        }
        
        // V99.45: Tag Location Helper Functions
        function toggleTagLocationHelp() { 
            const panel = document.getElementById('tag-location-panel');
            panel.classList.toggle('hidden');
            if(!panel.classList.contains('hidden')) {
                updateTagLocationHelp();
            }
        }
        
        function updateTagLocationHelp() {
            const cat = data.category || 'T-Shirt';
            const locations = tagLocationDB[cat] || tagLocationDB['default'];
            const content = document.getElementById('tag-location-content');
            
            let html = `<div style="font-weight:700;color:#92400e;margin-bottom:8px;font-size:13px;">🔍 Where to find tags on: ${cat}</div>`;
            
            // Primary location
            html += `<div style="background:white;border-radius:8px;padding:10px;margin-bottom:8px;border-left:4px solid #16a34a;">`;
            html += `<div style="font-weight:700;color:#16a34a;font-size:12px;">✅ CHECK FIRST: ${locations.primary.location}</div>`;
            html += `<div style="font-size:11px;color:#374151;">${locations.primary.desc}</div>`;
            html += `</div>`;
            
            // Secondary locations
            if(locations.secondary && locations.secondary.length > 0) {
                html += `<div style="font-weight:600;color:#92400e;font-size:11px;margin-bottom:6px;">Also check these spots:</div>`;
                locations.secondary.forEach(loc => {
                    const isImportant = loc.icon === '⭐';
                    html += `<div style="background:${isImportant?'#fef3c7':'white'};border-radius:6px;padding:8px;margin-bottom:6px;border-left:3px solid ${isImportant?'#f59e0b':'#d1d5db'};">`;
                    html += `<div style="font-weight:600;color:${isImportant?'#b45309':'#374151'};font-size:11px;">${loc.icon} ${loc.location}</div>`;
                    html += `<div style="font-size:10px;color:#6b7280;">${loc.desc}</div>`;
                    html += `</div>`;
                });
            }
            
            // Tips
            if(locations.tips) {
                html += `<div style="background:#dbeafe;border-radius:8px;padding:10px;margin-top:8px;">`;
                html += `<div style="font-weight:600;color:#1e40af;font-size:11px;">💡 Pro Tip:</div>`;
                html += `<div style="font-size:10px;color:#1e40af;">${locations.tips}</div>`;
                html += `</div>`;
            }
            
            content.innerHTML = html;
        }
        
        // V99.45: Pattern Helper Functions
        function togglePatternHelp() { 
            document.getElementById('pattern-help-panel').classList.toggle('hidden'); 
        }
        
        function togglePatternFilter(type, value, btn) { 
            if(patternFilters[type]===value){
                patternFilters[type]=null;
                data.patternTraits[type]='';
                btn.classList.remove('active');
            } 
            else{
                patternFilters[type]=value;
                data.patternTraits[type]=value;
                btn.parentElement.querySelectorAll('.filter-btn').forEach(b=>b.classList.remove('active'));
                btn.classList.add('active');
            } 
            updatePatternAdvice();
        }
        
        function updatePatternAdvice() {
            const helper = document.getElementById('pattern-helper');
            const advice = getPatternAdvice();
            
            if(helper) {
                if(advice){helper.innerHTML=advice;helper.classList.remove('hidden');} 
                else helper.classList.add('hidden');
            }
        }
        
        // V99.45: TRULY DYNAMIC pattern advice based on patternDB filtering
        function getPatternAdvice() {
            const p = patternFilters;
            const activeFilters = Object.values(p).filter(Boolean).length;
            
            if(activeFilters === 0) return '';
            
            // Filter patterns based on ALL selected traits
            const matches = patternDB.filter(pat => {
                // Handle "any" trait (matches everything)
                if(p.lines && pat.traits.lines !== 'any' && pat.traits.lines !== p.lines) return false;
                if(p.shapes && pat.traits.shapes !== 'any' && pat.traits.shapes !== p.shapes) return false;
                if(p.method && pat.traits.method !== 'any' && pat.traits.method !== p.method) return false;
                return true;
            }).filter(pat => pat.name !== 'Other'); // Exclude "Other" from suggestions
            
            // Build trait description for display
            const traitDesc = [];
            if(p.lines) traitDesc.push(p.lines === 'none' ? 'No lines' : p.lines === 'stripes' ? 'Parallel lines' : 'Crossing lines');
            if(p.shapes) traitDesc.push(p.shapes === 'none' ? 'No shapes' : p.shapes === 'dots' ? 'Dots/circles' : p.shapes === 'curved' ? 'Curved shapes' : p.shapes === 'geometric' ? 'Geometric shapes' : 'Irregular blobs');
            if(p.method) traitDesc.push(p.method === 'woven' ? 'Woven into fabric' : p.method === 'printed' ? 'Printed on surface' : 'Stitched on');
            
            // Build dynamic advice based on actual matches
            if(matches.length === 0) {
                return `<div style="color:#b91c1c;"><strong>⚠️ No common pattern matches!</strong></div>` +
                       `<div style="margin:4px 0;">${traitDesc.join(' + ')}</div>` +
                       `<div style="font-style:italic;font-size:10px;">Try selecting "Other" or adjust your selections.</div>`;
            } 
            else if(matches.length === 1) {
                const pat = matches[0];
                return `<div style="color:#16a34a;"><strong>✅ That's ${pat.name}!</strong></div>` +
                       `<div style="margin:4px 0;font-size:11px;">${pat.desc}</div>` +
                       `<div style="font-size:10px;color:#6b7280;"><em>Examples: ${pat.examples}</em></div>`;
            } 
            else if(matches.length === 2) {
                return `<div style="color:#2563eb;"><strong>💡 Could be one of these:</strong></div>` +
                       `<div style="margin:4px 0;font-size:11px;">` +
                       `<strong>${matches[0].name}</strong> – ${matches[0].desc}<br>` +
                       `<strong>${matches[1].name}</strong> – ${matches[1].desc}</div>` +
                       `<div style="font-style:italic;font-size:10px;">Add more traits to narrow down!</div>`;
            } 
            else {
                // Multiple matches - show them all
                let html = `<div style="color:#2563eb;"><strong>💡 ${matches.length} possible patterns:</strong></div><div style="margin:4px 0;font-size:11px;">`;
                matches.slice(0, 5).forEach(pat => {
                    html += `<strong>${pat.name}</strong> – ${pat.desc}<br>`;
                });
                if(matches.length > 5) html += `<em>...and ${matches.length - 5} more</em><br>`;
                html += `</div><div style="font-style:italic;font-size:10px;">Add more traits to narrow down!</div>`;
                return html;
            }
        }
        
        function updateValidation() { 
            // Construction check depends on superCategory: bottoms need legStyle, tops/outer need sleeveLength
            const constructionOk = data.superCategory === 'bottoms' ? !!data.legStyle : !!data.sleeveLength;
            const checks = { category:!!data.category, tag:!!data.tagStatus, color:data.colors.length>0, fade:!!data.fade, pattern:!!data.pattern, 'fabric-type':!!data.fabricType, material:data.materials.length>0, construction:constructionOk, feel:!!data.thickness&&!!data.layers, condition:data.hasDefects!==null, weight:data.weightLb>0||data.weightOz>0, audio:!!data.audioMeasure, sku:!!data.sku }; 
            Object.entries(checks).forEach(([key,ok])=>{ const el = document.getElementById(`check-${key}`); if(el){el.innerHTML=ok?'✓':'○';el.classList.toggle('complete',ok);} }); 
            const allRequired = checks.category&&checks.tag&&checks.color&&checks.fade&&checks.pattern&&checks['fabric-type']&&checks.material&&checks.construction&&checks.feel&&checks.condition&&checks.weight&&checks.audio&&checks.sku; 
            const hasPhotos = data.mainPhotos.length>0; 
            document.getElementById('submit-btn').disabled = !(allRequired&&hasPhotos);
            if(currentStep===4) updateReviewCards();
            
            // Auto-save draft on any data change
            saveDraft();
        }
        
        async function submitItem() { 
            const missingFields = [];
            if(!data.sku) missingFields.push('sku');
            if(data.mainPhotos.length===0) missingFields.push('mainPhotos');
            if(data.weightLb===0 && data.weightOz===0) missingFields.push('weight');
            if(!data.audioMeasure) missingFields.push('audio');
            
            if(missingFields.length > 0) {
                trackValidationBlock(missingFields);
                if(!data.sku) { showToast('error', 'Missing SKU', 'Enter or scan a SKU number'); return; }
                if(data.mainPhotos.length===0) { showToast('error', 'Missing Photo', 'Add at least one main photo'); return; }
                if(data.weightLb===0 && data.weightOz===0) { showToast('error', 'Missing Weight', 'Enter the item weight'); return; }
                if(!data.audioMeasure) { showToast('error', 'Missing Measurements', 'Record voice measurements'); return; }
            }
            
            // CRITICAL: Store SKU before any async operations
            const submittedSku = data.sku;
            
            // Disable submit button during upload to prevent data corruption
            const submitBtn = document.getElementById('submit-btn');
            submitBtn.disabled = true;
            submitBtn.textContent = 'UPLOADING...';
            
            // Show uploading toast
            const uploadToast = showToast('info', '⬆️ Uploading to S3...', 'Starting upload', 120000);
            
            try {
                // Step 1: Upload all files to S3
                const uploadResult = await uploadAllToS3((uploaded, total, filename) => {
                    // Update progress toast (with safety check)
                    const msgEl = uploadToast.querySelector('.toast-message');
                    if (msgEl) msgEl.textContent = `${uploaded}/${total}: ${filename}`;
                });
                
                if (!uploadResult.success && uploadResult.failed > 0) {
                    console.warn(`⚠️ ${uploadResult.failed} files failed to upload`);
                }
                
                // Remove upload toast
                uploadToast.remove();
                
                // Step 2: Send metadata only to n8n (no binary files!)
                const metadata = {
                    sku: data.sku,
                    timestamp: new Date().toISOString(),
                    category: data.category,
                    superCategory: data.superCategory,
                    tagStatus: data.tagStatus,
                    tagSize: data.tagSize,
                    origin: data.origin,
                    country: data.country,
                    gender: data.gender,
                    colors: data.colors,
                    fade: data.fade,
                    pattern: data.pattern,
                    patternTraits: data.patternTraits,
                    printType: data.printType,
                    graphicCategory: data.graphicCategory,
                    fabricType: data.fabricType,
                    fabricTraits: data.fabricTraits,
                    wash: data.wash,
                    materials: data.materials,
                    materialTraits: data.materialTraits,
                    sleeveLength: data.sleeveLength,
                    sleeveStyle: data.sleeveStyle,
                    cutoffType: data.cutoffType,
                    stitch: data.stitch,
                    bodyConstruction: data.bodyConstruction,
                    legStyle: data.legStyle,
                    rise: data.rise,
                    thickness: data.thickness,
                    layers: data.layers,
                    hasDefects: data.hasDefects,
                    defectTypes: data.defectTypes,
                    flagged: data.flagged,
                    elasticCheck: data.elasticCheck,
                    weightLb: data.weightLb,
                    weightOz: data.weightOz,
                    photographer: data.photographer,
                    audioDuration: data.audioDuration,
                    audioTranscript: data.audioTranscript || '',
                    parsedMeasurements: data.parsedMeasurements || {},
                    
                    // Photo counts
                    mainPhotoCount: data.mainPhotos.length,
                    tagPhotoCount: data.tagPhotos.length,
                    defectPhotoCount: data.defectPhotos.length,
                    defectCloseupPhotoCount: data.defectCloseupPhotos.length,
                    featurePhotoCount: data.featuresPhotos.length,
                    
                    // S3 file manifest (paths only, no binary data)
                    s3: buildS3FileManifest(),
                    
                    // Main photo details with shot IDs and defect data
                    mainPhotos: data.mainPhotos.map((p, i) => ({
                        index: i,
                        shotId: p.shotId || `main_${String(i+1).padStart(2,'0')}`,
                        width: p.width,
                        height: p.height,
                        isPortrait: p.isPortrait || false,
                        defects: p.defects || [],
                        defectSide: p.defectSide || null
                    })),
                    
                    // Defect marker summary
                    defectMarkers: data.mainPhotos.flatMap((p, photoIdx) => 
                        (p.defects || []).map(d => ({
                            photoIndex: photoIdx,
                            type: d.type,
                            x: d.x,
                            y: d.y,
                            side: p.defectSide || null
                        }))
                    ),
                    
                    // Defect closeup linkage
                    defectCloseups: data.defectCloseupPhotos.map((p, i) => ({
                        index: i,
                        linkedDefect: p.linkedDefect || null
                    })),
                    
                    // Feature photo types
                    features: data.featuresPhotos.map((p, i) => ({
                        index: i,
                        featureType: p.featureType || null
                    })),
                    
                    // Metrics
                    metrics: buildMetricsPayload()
                };
                
                console.log('📤 Sending metadata to n8n (no binary files):', metadata);
                
                // Metrics
                const metricsPayload = buildMetricsPayload();
                
                // Build n8n payload (will be forwarded through Lambda)
                const n8nPayload = {
                    sku: data.sku,
                    category: data.category,
                    superCategory: data.superCategory,
                    tagStatus: data.tagStatus,
                    tagSize: data.tagSize,
                    origin: data.origin,
                    country: data.country,
                    gender: data.gender,
                    colors: data.colors,
                    fade: data.fade,
                    pattern: data.pattern,
                    patternTraits: data.patternTraits,
                    printType: data.printType,
                    graphicCategory: data.graphicCategory,
                    fabricType: data.fabricType,
                    fabricTraits: data.fabricTraits,
                    wash: data.wash,
                    materials: data.materials,
                    materialTraits: data.materialTraits,
                    sleeveLength: data.sleeveLength,
                    sleeveStyle: data.sleeveStyle,
                    cutoffType: data.cutoffType,
                    stitch: data.stitch,
                    bodyConstruction: data.bodyConstruction,
                    legStyle: data.legStyle,
                    rise: data.rise,
                    thickness: data.thickness,
                    layers: data.layers,
                    hasDefects: data.hasDefects,
                    defectTypes: data.defectTypes,
                    flagged: data.flagged,
                    elasticCheck: data.elasticCheck,
                    weightLb: data.weightLb,
                    weightOz: data.weightOz,
                    photographer: data.photographer,
                    audioDuration: data.audioDuration,
                    audioTranscript: data.audioTranscript || '',
                    parsedMeasurements: data.parsedMeasurements || {},
                    mainPhotoCount: data.mainPhotos.length,
                    tagPhotoCount: data.tagPhotos.length,
                    defectPhotoCount: data.defectPhotos.length,
                    defectCloseupPhotoCount: data.defectCloseupPhotos.length,
                    featurePhotoCount: data.featuresPhotos.length,
                    s3Files: buildS3FileManifest(),
                    metrics: metricsPayload
                };
                
                // Send to n8n through Lambda proxy
                console.log('📤 Sending to n8n via Lambda proxy:', n8nPayload.sku);
                
                try {
                    const n8nResponse = await fetch(LAMBDA_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            action: 'n8n',
                            formData: n8nPayload
                        })
                    });
                    
                    const n8nResult = await n8nResponse.json();
                    
                    if(n8nResult.success) {
                        console.log('✅ Submitted to n8n via Lambda');
                        showToast('success', 'Item Submitted!', `SKU ${submittedSku} uploaded to S3 & n8n`);
                    } else {
                        console.warn('⚠️ n8n response not OK:', n8nResult);
                        showToast('warning', 'Partial Success', 'S3 uploaded, n8n may have issues');
                    }
                } catch(n8nErr) {
                    console.error('n8n proxy error:', n8nErr);
                    showToast('warning', 'S3 OK, n8n Error', 'Files in S3, check n8n connection');
                }
                
            } catch (err) {
                console.error('❌ Submit error:', err);
                // Safely remove upload toast if it still exists
                if (uploadToast && uploadToast.parentNode) {
                    uploadToast.remove();
                }
                showToast('error', 'Upload Failed', err.message);
                
                // Re-enable submit button
                submitBtn.disabled = false;
                submitBtn.textContent = 'SUBMIT ✓';
                
                // Fall back to local save only
                if(saveDirectoryHandle) {
                    showToast('info', 'Saving Locally', 'Files saved to local folder');
                }
                return; // Don't reset if upload failed
            }
            
            recordItemTime(); stats.today++; stats.total++; saveStats(); updateStatsDisplay(); 
            
            // Save JSON file to folder if directory is selected (don't await - let it run in background)
            if(saveDirectoryHandle) {
                saveJsonToFolder().catch(e => console.error('JSON save error:', e));
            }
            
            console.log('✅ Submitted:', submittedSku); 
            
            // Always reset and show SKU gate after submit
            console.log('📋 submitItem calling resetForm(false)...');
            try {
                resetForm(false);
                console.log('📋 resetForm completed');
            } catch(e) {
                console.error('❌ resetForm error:', e);
                // Force show SKU gate even if resetForm fails
                showSkuGate();
            }
            
            console.log('📋 submitItem complete');
        }
        
        // Save JSON data file to selected folder
        async function saveJsonToFolder() {
            if(!saveDirectoryHandle) return;
            
            try {
                // Build metrics for JSON
                const metricsPayload = buildMetricsPayload();
                
                const jsonData = {
                    sku: data.sku,
                    timestamp: new Date().toISOString(),
                    category: data.category,
                    superCategory: data.superCategory,
                    tagStatus: data.tagStatus,
                    tagSize: data.tagSize,
                    origin: data.origin,
                    country: data.country,
                    gender: data.gender,
                    colors: data.colors,
                    fade: data.fade,
                    pattern: data.pattern,
                    patternTraits: data.patternTraits,
                    printType: data.printType,
                    graphicCategory: data.graphicCategory,
                    fabricType: data.fabricType,
                    fabricTraits: data.fabricTraits,
                    wash: data.wash,
                    materials: data.materials,
                    materialTraits: data.materialTraits,
                    sleeveLength: data.sleeveLength,
                    sleeveStyle: data.sleeveStyle,
                    cutoffType: data.cutoffType,
                    stitch: data.stitch,
                    bodyConstruction: data.bodyConstruction,
                    legStyle: data.legStyle,
                    rise: data.rise,
                    thickness: data.thickness,
                    layers: data.layers,
                    hasDefects: data.hasDefects,
                    defectTypes: data.defectTypes,
                    weightLb: data.weightLb,
                    weightOz: data.weightOz,
                    flagged: data.flagged,
                    elasticCheck: data.elasticCheck,
                    audioDuration: data.audioDuration,
                    mainPhotoCount: data.mainPhotos.length,
                    tagPhotoCount: data.tagPhotos.length,
                    defectPhotoCount: data.defectPhotos.length,
                    defectCloseupPhotoCount: data.defectCloseupPhotos.length,
                    featurePhotoCount: data.featuresPhotos.length,
                    // Include defect markers from main photos
                    defectMarkers: data.mainPhotos.flatMap((p, photoIdx) => 
                        (p.defects || []).map(d => ({
                            photoIndex: photoIdx,
                            type: d.type,
                            x: d.x,
                            y: d.y,
                            side: p.defectSide || null
                        }))
                    ),
                    // Include metrics
                    metrics: metricsPayload
                };
                
                const filename = `${data.sku}_data.json`;
                const fileHandle = await saveDirectoryHandle.getFileHandle(filename, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(JSON.stringify(jsonData, null, 2));
                await writable.close();
                
                console.log(`💾 Saved JSON: ${filename}`);
            } catch(e) {
                console.error('Failed to save JSON:', e);
            }
        }
        function resetForm(keepSku = false) { 
            // Clear saved draft since we're starting fresh
            clearDraft();
            
            // Store SKU if we want to keep it
            const preservedSku = keepSku ? data.sku : '';
            const wasSkuLocked = keepSku ? skuLocked : false;
            
            debugLog(`resetForm - keepSku: ${keepSku}`, 'info');
            
            // Track reset type for metrics
            if(keepSku && metrics) {
                trackSoftReset();
                // For soft reset: reset tracking arrays but keep workflow metadata
                resetMetricsForSoftReset();
            } else if(!keepSku && metrics && data.sku) {
                // Full reset with data - send abandoned item event
                sendAbandonedItemEvent('full_reset');
            }
            
            // Increment item sequence for next item
            if(!keepSku) {
                itemSequenceToday++;
            }
            
            // Revoke all photo URLs
            data.mainPhotos.forEach(p=>URL.revokeObjectURL(p.url)); 
            data.detailPhotos.forEach(p=>URL.revokeObjectURL(p.url)); 
            data.tagPhotos.forEach(p=>URL.revokeObjectURL(p.url)); 
            data.defectPhotos.forEach(p=>URL.revokeObjectURL(p.url)); 
            data.defectCloseupPhotos.forEach(p=>URL.revokeObjectURL(p.url)); 
            data.featuresPhotos.forEach(p=>URL.revokeObjectURL(p.url)); 
            
            // Reset selection states
            selectedDetailType = null;
            selectedFeatureType = null; 
            
            // Reset metrics if full reset
            if(!keepSku) {
                metrics = null;
            }
            
            // Reset shot sequence for new item
            resetShotSequence();
            
            // Reset data object
            data = {
                superCategory:'tops',
                category:'',
                tagStatus:'',
                tagSize:'',
                origin:'',
                country:'',
                gender:'',
                colors:[],
                fade:'',
                pattern:'',
                patternTraits:{lines:'',shapes:'',method:''},
                printType:'',
                graphicCategory:'',
                fabricType:'',
                fabricTraits:{stretch:'',surface:'',interior:''},
                wash:'',
                materials:[],
                materialTraits:{temp:'',shine:''},
                sleeveLength:'',
                sleeveStyle:'',
                cutoffType:'',
                stitch:'',
                bodyConstruction:'',
                legStyle:'',
                rise:'',
                thickness:'',
                layers:'',
                hasDefects:null,
                defectTypes:[],
                weightLb:0,
                weightOz:0,
                sku: preservedSku,
                photographer:data.photographer,
                audioMeasure:null,
                audioDuration:0,
                audioMimeType:'audio/webm',
                audioTranscript:'',
                parsedMeasurements:{},
                mainPhotos:[],
                detailPhotos:[],
                tagPhotos:[],
                defectPhotos:[],
                defectCloseupPhotos:[],
                featuresPhotos:[],
                flagged:false,
                elasticCheck:''
            }; 
            
            // Reset state variables
            tagCutMode = false; 
            skuLocked = wasSkuLocked; 
            selectedDefectLink = null; 
            selectedDefectForCloseup = null;
            selectedFeatureType = null;
            parsedMeasurements = {};
            measurementIndex = 0;
            fabricFilters = {stretch:null, surface:null, interior:null}; 
            materialFilters = {temp:null, shine:null}; 
            patternFilters = {lines:null, shapes:null, method:null};
            
            // === RESET ALL BUTTON SELECTIONS ===
            document.querySelectorAll('.selected').forEach(b => b.classList.remove('selected')); 
            document.querySelectorAll('.btn-hero').forEach(b => {
                if(!b.classList.contains('super-btn')) {
                    b.classList.remove('btn-hero');
                    b.classList.add('btn-secondary');
                }
            });
            
            // Reset super category buttons (Tops selected by default)
            document.querySelectorAll('.super-btn').forEach((b,i) => {
                if(i === 0) {
                    b.classList.add('selected', 'btn-hero');
                    b.classList.remove('btn-secondary');
                } else {
                    b.classList.remove('selected', 'btn-hero');
                    b.classList.add('btn-secondary');
                }
            });
            
            // Reset all other button types
            document.querySelectorAll('.cat-btn, .size-btn, .country-btn, .gender-btn, .tag-status-btn, .fade-btn, .pattern-btn, .defect-btn, .elastic-btn, .leg-btn, .rise-btn, .sleeve-btn, .stitch-btn, .body-btn').forEach(b => {
                b.classList.remove('selected', 'btn-hero');
                b.classList.add('btn-secondary');
            });
            
            // Reset color buttons
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('selected'));
            
            // Reset filter buttons
            document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
            
            // === RESET INPUT FIELDS ===
            document.getElementById('sku-input').value = preservedSku;
            document.getElementById('weight-lb').value = '0';
            document.getElementById('weight-oz').value = '0';
            document.getElementById('tag-size-input').value = '';
            document.getElementById('country-other-input').value = '';
            document.getElementById('material-other-select').value = '';
            document.getElementById('material-custom-input').value = '';
            document.getElementById('fabric-other-select').value = '';
            document.getElementById('fabric-custom-input').value = '';
            
            // === HIDE SECTIONS ===
            ['tag-details', 'country-section', 'country-other-input', 'wash-section', 'print-type-section', 
             'graphic-category-section', 'pattern-others', 'cutoff-section', 'elastic-section', 
             'sleeve-measurement-notice', 'material-custom-input', 'fabric-custom-input', 'fabric-helper', 
             'material-helper', 'pattern-helper', 'pattern-help-panel', 'tag-location-panel', 
             'fabric-tag-cut-section', 'material-tag-cut-section', 'leg-style-help', 'flag-status',
             'bottoms-construction', 'measure-hint-button-shirt', 'measure-hint-bottoms', 'measure-hint-outer'
            ].forEach(id => document.getElementById(id)?.classList.add('hidden'));
            
            // === SHOW SECTIONS ===
            ['tops-construction', 'measure-hint-tops', 'fabric-help-btn', 'material-help-btn', 'record-section'
            ].forEach(id => document.getElementById(id)?.classList.remove('hidden'));
            
            document.getElementById('post-record-section').classList.add('hidden');
            document.getElementById('voice-transcript-section').classList.add('hidden');
            
            // === RESET UI ELEMENTS ===
            document.getElementById('other-patterns-toggle').textContent = '+ More patterns';
            document.getElementById('category-label').textContent = '';
            updateMeasurementHintsForSleeveStyle('Standard', '');
            
            // Reset audio recording
            document.getElementById('record-btn').innerHTML = '<span style="font-size:24px;">🎤</span><span>TAP TO RECORD</span>';
            document.getElementById('record-btn').style.background = '#ef4444';
            
            // Reset flag button
            document.getElementById('flag-btn').classList.remove('flagged');
            document.getElementById('flag-btn').querySelector('span:first-child').textContent = '🤔';
            document.getElementById('flag-btn').querySelector('span:last-of-type').textContent = 'FLAG AS UNUSUAL';
            
            // === HANDLE SKU STATE ===
            const skuInput = document.getElementById('sku-input');
            const step3Display = document.getElementById('sku-display-step3');
            
            if(keepSku && preservedSku) {
                document.getElementById('sku-locked-badge').classList.remove('hidden');
                document.getElementById('sku-locked-value').textContent = preservedSku;
                if(skuInput) {
                    skuInput.value = preservedSku;
                    skuInput.style.borderColor = 'var(--color-success)';
                    skuInput.style.background = '#f0fdf4';
                }
                if(step3Display) step3Display.textContent = preservedSku;
                document.getElementById('check-sku').innerHTML = '✓';
                document.getElementById('check-sku').classList.add('complete');
                document.getElementById('sku-status').textContent = '✓ SKU set: ' + preservedSku;
                document.getElementById('sku-status').style.color = 'var(--color-success)';
            } else {
                document.getElementById('sku-locked-badge').classList.add('hidden');
                document.getElementById('sku-locked-value').textContent = '';
                if(skuInput) {
                    skuInput.value = '';
                    skuInput.style.borderColor = 'var(--color-border)';
                    skuInput.style.background = '';
                }
                if(step3Display) step3Display.textContent = '—';
                document.getElementById('check-sku').innerHTML = '○';
                document.getElementById('check-sku').classList.remove('complete');
                document.getElementById('sku-status').textContent = '';
            }
            
            // === RENDER/UPDATE ===
            renderSubCategories('tops'); 
            clearDefectMarkers(); 
            renderFabricCards(); 
            renderMaterialCards(); 
            renderPatternCards(); 
            updatePhotoGrids(); 
            updateValidation(); 
            
            // === NAVIGATION ===
            goToStep(1); 
            setPhotoMode('main'); 
            resetZoom(); 
            
            // Reset portrait mode to landscape
            if(mainPhotoPortrait) {
                mainPhotoPortrait = false;
                const btn = document.getElementById('rotate-btn');
                if(btn) {
                    btn.textContent = '🔄 LANDSCAPE';
                    btn.style.background = '#8b5cf6';
                }
                // Reset video transform
                const video = document.getElementById('camera-video');
                if(video) {
                    video.style.transform = '';
                    video.style.maxWidth = '';
                    video.style.maxHeight = '';
                }
                // Reset defect layer transform
                const defectLayer = document.getElementById('defect-markers-layer');
                if(defectLayer) {
                    defectLayer.style.transform = '';
                }
            }
            
            // Focus SKU input after reset (unless keeping SKU)
            if(!keepSku || !preservedSku) {
                setTimeout(() => {
                    const skuInput = document.getElementById('sku-input');
                    if(skuInput) skuInput.focus();
                }, 100);
            }
        }
        
        function loadStats() { try{ const saved = JSON.parse(localStorage.getItem(`vl_stats_${VERSION}`)||'{}'); if(saved.date!==new Date().toDateString()){saved.today=0;} stats = {today:saved.today||0,total:saved.total||0}; itemTimes = saved.itemTimes||[]; updateStatsDisplay(); if(itemTimes.length>0){ const avg = Math.floor(itemTimes.reduce((a,b)=>a+b,0)/itemTimes.length); document.getElementById('timer-avg').textContent = `${Math.floor(avg/60)}:${(avg%60).toString().padStart(2,'0')}`; } }catch(e){} }
        function saveStats() { try{localStorage.setItem(`vl_stats_${VERSION}`,JSON.stringify({...stats,date:new Date().toDateString(),itemTimes:itemTimes.slice(-50)}));}catch(e){} }
        function updateStatsDisplay() { document.getElementById('stat-today').textContent = stats.today; document.getElementById('stat-total').textContent = stats.total; }
    </script>
    
    <!-- Draft Restored Indicator -->
    <div class="draft-indicator" id="draft-indicator">📋 Draft restored - continue where you left off</div>
    
    <!-- Debug Panel -->
    <button class="debug-toggle" id="debug-toggle" onclick="toggleDebugPanel()" title="Toggle Debug Panel">🔧</button>
    <div class="debug-panel" id="debug-panel">
        <div class="debug-header">
            <span>🔧 DEBUG CONSOLE</span>
            <button class="debug-close" onclick="toggleDebugPanel()">×</button>
        </div>
        <div class="debug-content" id="debug-content"></div>
    </div>
    
    <!-- Feature Type Panel - at body level to avoid overflow:hidden issues -->
    <div class="feature-type-panel" id="feature-type-panel" style="display:none;position:fixed;bottom:120px;left:50%;transform:translateX(-50%);z-index:999999;background:rgba(124,58,237,0.98);padding:16px 24px;border-radius:16px;border:3px solid rgba(255,255,255,0.5);box-shadow:0 10px 40px rgba(0,0,0,0.6);">
        <span style="font-weight:700;font-size:14px;color:white;">✨ Select Feature Type:</span>
        <div class="feature-type-buttons" style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;">
            <button onclick="selectFeatureType('Label')" class="feature-type-btn" style="padding:8px 14px;background:rgba(255,255,255,0.2);border:none;border-radius:8px;color:white;font-size:12px;font-weight:600;cursor:pointer;">Label</button>
            <button onclick="selectFeatureType('Copyright')" class="feature-type-btn" style="padding:8px 14px;background:rgba(255,255,255,0.2);border:none;border-radius:8px;color:white;font-size:12px;font-weight:600;cursor:pointer;">Copyright</button>
            <button onclick="selectFeatureType('Zipper')" class="feature-type-btn" style="padding:8px 14px;background:rgba(255,255,255,0.2);border:none;border-radius:8px;color:white;font-size:12px;font-weight:600;cursor:pointer;">Zipper</button>
            <button onclick="selectFeatureType('Buttons')" class="feature-type-btn" style="padding:8px 14px;background:rgba(255,255,255,0.2);border:none;border-radius:8px;color:white;font-size:12px;font-weight:600;cursor:pointer;">Buttons</button>
            <button onclick="selectFeatureType('Pockets')" class="feature-type-btn" style="padding:8px 14px;background:rgba(255,255,255,0.2);border:none;border-radius:8px;color:white;font-size:12px;font-weight:600;cursor:pointer;">Pockets</button>
            <button onclick="selectFeatureType('Cuffs')" class="feature-type-btn" style="padding:8px 14px;background:rgba(255,255,255,0.2);border:none;border-radius:8px;color:white;font-size:12px;font-weight:600;cursor:pointer;">Cuffs</button>
            <button onclick="selectFeatureType('Drawstring')" class="feature-type-btn" style="padding:8px 14px;background:rgba(255,255,255,0.2);border:none;border-radius:8px;color:white;font-size:12px;font-weight:600;cursor:pointer;">Drawstring</button>
            <button onclick="selectFeatureType('Stitch')" class="feature-type-btn" style="padding:8px 14px;background:rgba(255,255,255,0.2);border:none;border-radius:8px;color:white;font-size:12px;font-weight:600;cursor:pointer;">Stitch</button>
            <button onclick="selectFeatureType('Hardware')" class="feature-type-btn" style="padding:8px 14px;background:rgba(255,255,255,0.2);border:none;border-radius:8px;color:white;font-size:12px;font-weight:600;cursor:pointer;">Hardware</button>
            <button onclick="selectFeatureType('Print')" class="feature-type-btn" style="padding:8px 14px;background:rgba(255,255,255,0.2);border:none;border-radius:8px;color:white;font-size:12px;font-weight:600;cursor:pointer;">Print</button>
            <button onclick="selectFeatureType('Other')" class="feature-type-btn" style="padding:8px 14px;background:rgba(255,255,255,0.2);border:none;border-radius:8px;color:white;font-size:12px;font-weight:600;cursor:pointer;">Other</button>
        </div>
        <button onclick="selectedFeatureType=null;const p=document.getElementById('feature-type-panel');if(p)p.style.display='none';showToast('info','Cleared','Feature type cleared',1000)" class="feature-type-clear" style="padding:8px 14px;background:rgba(255,255,255,0.1);border:1px dashed rgba(255,255,255,0.4);border-radius:8px;color:rgba(255,255,255,0.8);font-size:12px;cursor:pointer;margin-top:8px;">Clear & Close</button>
    </div>
    
</body>
</html>

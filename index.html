<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VintageLister v2.9.5 ASYNC</title>
    <style>
        /* =====================================================================
           VintageLister v2.9.5 ASYNC - Zero Wait Time Architecture
           
           MAJOR CHANGE: All AI processing moved to Lambda (async)
           - Photographer clicks COMPLETE ‚Üí UI resets in < 1 second
           - No more 10-30 second waits
           - AI runs in background via Lambda after S3 upload
           
           What's removed from browser:
           - OCR calls (moved to Lambda)
           - Image Processing calls (moved to Lambda)
           - Photo Routing calls (moved to Lambda)
           - Full Pipeline calls (moved to Lambda)
           
           What's added:
           - Trigger file upload to signal Lambda to process
           - Status field in JSON for tracking processing state
           ===================================================================== */
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e; 
            color: #eee;
            min-height: 100vh;
        }
        
        .header {
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #0f3460;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header h1 {
            font-size: 1.4rem;
            background: linear-gradient(90deg, #e94560, #0f3460);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .version-badge {
            background: #e94560;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 300px 1fr 320px;
            gap: 15px;
            padding: 15px;
            max-width: 1800px;
            margin: 0 auto;
        }
        
        .panel {
            background: #16213e;
            border-radius: 12px;
            padding: 15px;
            border: 1px solid #0f3460;
        }
        
        .panel-title {
            font-size: 0.85rem;
            color: #e94560;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Camera & Preview */
        .camera-container {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 4/3;
        }
        
        #camera-preview {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .camera-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }
        
        .camera-badge {
            background: rgba(0,0,0,0.7);
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
        }
        
        /* Photo Grid */
        .photo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 8px;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .photo-thumb {
            aspect-ratio: 1;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .photo-thumb:hover {
            border-color: #e94560;
            transform: scale(1.05);
        }
        
        .photo-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .photo-thumb .label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.8);
            padding: 2px 4px;
            font-size: 0.65rem;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* SKU Input */
        .sku-section {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .sku-input {
            flex: 1;
            background: #0f3460;
            border: 2px solid #e94560;
            color: #fff;
            padding: 12px 15px;
            border-radius: 8px;
            font-size: 1.2rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .sku-input:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(233, 69, 96, 0.3);
        }
        
        /* Buttons */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #e94560, #c73e54);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(233, 69, 96, 0.4);
        }
        
        .btn-secondary {
            background: #0f3460;
            color: #eee;
            border: 1px solid #e94560;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            color: white;
            font-size: 1.1rem;
            padding: 15px 30px;
        }
        
        .btn-lg {
            padding: 15px 30px;
            font-size: 1rem;
        }
        
        /* Category Selection */
        .category-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        
        .category-btn {
            padding: 10px;
            background: #0f3460;
            border: 2px solid transparent;
            border-radius: 8px;
            color: #eee;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
        }
        
        .category-btn:hover {
            border-color: #e94560;
        }
        
        .category-btn.active {
            background: #e94560;
            border-color: #e94560;
        }
        
        /* Measurement Display */
        .measurement-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }
        
        .measurement-item {
            background: #0f3460;
            padding: 10px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .measurement-item.completed {
            border-left: 3px solid #2ecc71;
        }
        
        .measurement-label {
            font-size: 0.8rem;
            color: #aaa;
        }
        
        .measurement-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: #2ecc71;
        }
        
        /* Tag Data Display */
        .tag-grid {
            display: none;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
            padding: 10px;
            background: #0f3460;
            border-radius: 8px;
        }
        
        .tag-item {
            display: flex;
            flex-direction: column;
        }
        
        .tag-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }
        
        .tag-value {
            font-size: 0.9rem;
            font-weight: 600;
            color: #e94560;
        }
        
        /* Timer */
        .timer {
            font-size: 2rem;
            font-weight: 700;
            text-align: center;
            padding: 15px;
            background: #0f3460;
            border-radius: 8px;
            font-family: 'Monaco', monospace;
        }
        
        .timer.warning { color: #f39c12; }
        .timer.danger { color: #e74c3c; }
        
        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 10px;
        }
        
        .stat-item {
            text-align: center;
            padding: 10px;
            background: #0f3460;
            border-radius: 6px;
        }
        
        .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #e94560;
        }
        
        .stat-label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }
        
        /* Weight Display */
        .weight-display {
            background: #0f3460;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .weight-value {
            font-size: 2rem;
            font-weight: 700;
            color: #3498db;
        }
        
        .weight-status {
            font-size: 0.75rem;
            color: #888;
        }
        
        /* Recording indicator */
        .recording-indicator {
            display: none;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: rgba(231, 76, 60, 0.2);
            border: 1px solid #e74c3c;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .recording-indicator.active {
            display: flex;
        }
        
        .recording-dot {
            width: 12px;
            height: 12px;
            background: #e74c3c;
            border-radius: 50%;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        /* Toast notifications */
        .toast-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .toast {
            padding: 12px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            animation: slideIn 0.3s ease;
            max-width: 350px;
        }
        
        .toast.success { background: #2ecc71; }
        .toast.warning { background: #f39c12; }
        .toast.error { background: #e74c3c; }
        .toast.info { background: #3498db; }
        
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        /* Retry badge */
        .retry-badge {
            display: none;
            background: #f39c12;
            color: #000;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            cursor: pointer;
        }
        
        .retry-badge.visible { display: block; }
        
        /* Action buttons row */
        .action-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .action-row .btn {
            flex: 1;
        }
        
        /* Phase indicator */
        .phase-indicator {
            display: flex;
            gap: 5px;
            margin: 15px 0;
        }
        
        .phase {
            flex: 1;
            padding: 8px;
            text-align: center;
            background: #0f3460;
            border-radius: 4px;
            font-size: 0.75rem;
            opacity: 0.5;
            transition: all 0.3s;
        }
        
        .phase.active {
            opacity: 1;
            background: #e94560;
        }
        
        .phase.complete {
            opacity: 1;
            background: #2ecc71;
        }
        
        /* Async processing badge - NEW for v2.9.5 */
        .async-badge {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            color: white;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.7rem;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }
        
        .async-badge::before {
            content: '‚ö°';
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>VintageLister</h1>
        <div style="display: flex; align-items: center; gap: 15px;">
            <span class="async-badge">ZERO WAIT MODE</span>
            <span class="version-badge">v2.9.5 ASYNC</span>
            <span id="retry-badge" class="retry-badge" onclick="processRetryQueue()"></span>
        </div>
    </div>
    
    <div class="main-grid">
        <!-- LEFT PANEL: Camera & Photos -->
        <div class="panel">
            <div class="panel-title">üì∑ Camera</div>
            
            <div class="camera-container">
                <video id="camera-preview" autoplay playsinline></video>
                <div class="camera-overlay">
                    <span class="camera-badge" id="camera-name">No Camera</span>
                    <span class="camera-badge" id="photo-count">0 photos</span>
                </div>
            </div>
            
            <div class="action-row">
                <button class="btn btn-primary" onclick="capturePhoto()">üì∏ Capture</button>
                <button class="btn btn-secondary" onclick="switchCamera()">üîÑ Switch</button>
            </div>
            
            <div class="panel-title" style="margin-top: 15px;">üìÅ Photos</div>
            <div class="photo-grid" id="photo-grid"></div>
        </div>
        
        <!-- CENTER PANEL: Main Controls -->
        <div style="display: flex; flex-direction: column; gap: 15px;">
            <!-- SKU & Category -->
            <div class="panel">
                <div class="sku-section">
                    <input type="text" class="sku-input" id="sku-input" placeholder="SCAN SKU..." autofocus>
                    <button class="btn btn-secondary" onclick="resetItem()">üîÑ Reset</button>
                </div>
                
                <div class="panel-title">üìÇ Category</div>
                <div class="category-grid" id="category-grid"></div>
            </div>
            
            <!-- Phase Indicator -->
            <div class="panel">
                <div class="panel-title">üìç Workflow Phase</div>
                <div class="phase-indicator">
                    <div class="phase" id="phase-main">Main Photos</div>
                    <div class="phase" id="phase-closeup">Closeups</div>
                    <div class="phase" id="phase-measure">Measurements</div>
                    <div class="phase" id="phase-complete">Complete</div>
                </div>
                
                <div class="timer" id="timer">00:00</div>
                
                <div class="recording-indicator" id="recording-indicator">
                    <div class="recording-dot"></div>
                    <span>Recording measurements...</span>
                </div>
            </div>
            
            <!-- Measurements -->
            <div class="panel">
                <div class="panel-title">üìè Measurements</div>
                <div class="measurement-grid" id="measurement-grid"></div>
            </div>
            
            <!-- Complete Button -->
            <button class="btn btn-success btn-lg" onclick="completeItem()" style="width: 100%;">
                ‚úÖ COMPLETE - INSTANT SUBMIT
            </button>
        </div>
        
        <!-- RIGHT PANEL: Data & Stats -->
        <div style="display: flex; flex-direction: column; gap: 15px;">
            <!-- Weight -->
            <div class="panel">
                <div class="panel-title">‚öñÔ∏è Weight</div>
                <div class="weight-display">
                    <div class="weight-value" id="weight-value">--</div>
                    <div class="weight-status" id="weight-status">Waiting for scale...</div>
                </div>
            </div>
            
            <!-- Tag Data (populated by Lambda async) -->
            <div class="panel">
                <div class="panel-title">üè∑Ô∏è Tag Data <span style="font-size: 0.65rem; color: #888;">(processed async)</span></div>
                <div class="tag-grid" id="tag-grid">
                    <div class="tag-item">
                        <span class="tag-label">Brand</span>
                        <span class="tag-value" id="tag-brand">-</span>
                    </div>
                    <div class="tag-item">
                        <span class="tag-label">Size</span>
                        <span class="tag-value" id="tag-size">-</span>
                    </div>
                    <div class="tag-item">
                        <span class="tag-label">Materials</span>
                        <span class="tag-value" id="tag-materials">-</span>
                    </div>
                    <div class="tag-item">
                        <span class="tag-label">Country</span>
                        <span class="tag-value" id="tag-country">-</span>
                    </div>
                </div>
                <div style="text-align: center; padding: 10px; color: #666; font-size: 0.75rem;">
                    AI processing happens after upload
                </div>
            </div>
            
            <!-- Session Stats -->
            <div class="panel">
                <div class="panel-title">üìä Session Stats</div>
                <div class="stats-grid">
                    <div class="stat-item">
                        <div class="stat-value" id="stat-completed">0</div>
                        <div class="stat-label">Completed</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stat-avg-time">0:00</div>
                        <div class="stat-label">Avg Time</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stat-per-hour">0</div>
                        <div class="stat-label">Per Hour</div>
                    </div>
                </div>
            </div>
            
            <!-- Folder Selection -->
            <div class="panel">
                <div class="panel-title">üíæ Save Location</div>
                <button class="btn btn-secondary" onclick="selectSaveFolder()" style="width: 100%;">
                    üìÅ Select Folder
                </button>
                <div id="folder-path" style="margin-top: 8px; font-size: 0.75rem; color: #888; word-break: break-all;"></div>
            </div>
        </div>
    </div>
    
    <div class="toast-container" id="toast-container"></div>
    
    <script>
        // =====================================================================
        // VintageLister v2.9.5 ASYNC
        // 
        // ARCHITECTURE CHANGE:
        // - All AI processing (OCR, Image Processing, Photo Routing, Pipeline)
        //   now happens ASYNCHRONOUSLY in Lambda AFTER S3 upload
        // - Photographer sees INSTANT UI reset (< 1 second)
        // - No more 10-30 second waits
        //
        // Flow:
        // 1. Photographer captures photos, records measurements
        // 2. Clicks COMPLETE
        // 3. Data captured, UI resets IMMEDIATELY
        // 4. Background: uploads to S3, triggers Lambda
        // 5. Lambda processes AI async, updates JSON in S3
        // 6. n8n gets final processed data
        // =====================================================================
        
        const VERSION = '2.9.5-ASYNC';
        const LAMBDA_URL = localStorage.getItem('lambdaUrl') || 'https://xxxxxxx.lambda-url.us-east-1.on.aws/';
        const MAX_RETRIES = 3;
        const RETRY_DELAY = 5000;
        
        // Categories
        const CATEGORIES = {
            'tops': { label: 'üëï Tops', icon: 'üëï' },
            'bottoms': { label: 'üëñ Bottoms', icon: 'üëñ' },
            'outerwear': { label: 'üß• Outerwear', icon: 'üß•' },
            'dresses': { label: 'üëó Dresses', icon: 'üëó' },
            'suits': { label: 'ü§µ Suits', icon: 'ü§µ' },
            'accessories': { label: 'üëú Accessories', icon: 'üëú' },
            'footwear': { label: 'üëü Footwear', icon: 'üëü' },
            'other': { label: 'üì¶ Other', icon: 'üì¶' }
        };
        
        // State
        const state = {
            currentSKU: null,
            classification: null,
            templateKey: null,
            template: null,
            photos: { main: [], closeup: [], handheld: [] },
            measurements: {},
            rawTranscript: null,
            audioBlob: null,
            discardedRecordings: [],
            lastRecordingDuration: 0,
            weight: null,
            timerStart: null,
            timerInterval: null,
            phase: 'main', // main, closeup, measurements
            timing: {},
            
            // Camera
            cameras: [],
            currentCameraIndex: 0,
            stream: null,
            
            // Recording
            mediaRecorder: null,
            audioChunks: [],
            isRecording: false,
            
            // Save
            saveDirectoryHandle: null,
            
            // Session stats
            completedItems: parseInt(localStorage.getItem('completedItems') || '0'),
            totalTime: parseInt(localStorage.getItem('totalTime') || '0'),
            sessionStart: Date.now(),
            
            // Retry queue
            retryQueue: JSON.parse(localStorage.getItem('retryQueue') || '[]'),
            
            // Templates (loaded from Lambda)
            templates: {}
        };
        
        // =====================================================================
        // INITIALIZATION
        // =====================================================================
        
        async function init() {
            console.log(`üöÄ VintageLister ${VERSION} initializing...`);
            
            // Build UI
            buildCategoryGrid();
            
            // Initialize camera
            await initCamera();
            
            // Load templates from Lambda
            await loadTemplates();
            
            // Initialize Dymo scale
            initDymoScale();
            
            // Set up keyboard shortcuts
            setupKeyboardShortcuts();
            
            // Update stats display
            updateStats();
            updateRetryBadge();
            
            // Check for saved folder
            const savedFolderName = localStorage.getItem('saveFolderName');
            if (savedFolderName) {
                document.getElementById('folder-path').textContent = `üìÅ ${savedFolderName}`;
            }
            
            showToast('success', `VintageLister ${VERSION} ready!`);
            console.log('‚úÖ Initialization complete');
        }
        
        // =====================================================================
        // CAMERA
        // =====================================================================
        
        async function initCamera() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                state.cameras = devices.filter(d => d.kind === 'videoinput');
                
                if (state.cameras.length === 0) {
                    showToast('error', 'No cameras found');
                    return;
                }
                
                await startCamera(state.currentCameraIndex);
            } catch (e) {
                console.error('Camera init failed:', e);
                showToast('error', 'Camera access denied');
            }
        }
        
        async function startCamera(index) {
            if (state.stream) {
                state.stream.getTracks().forEach(t => t.stop());
            }
            
            const camera = state.cameras[index];
            const constraints = {
                video: {
                    deviceId: { exact: camera.deviceId },
                    width: { ideal: 4000 },
                    height: { ideal: 3000 }
                }
            };
            
            try {
                state.stream = await navigator.mediaDevices.getUserMedia(constraints);
                document.getElementById('camera-preview').srcObject = state.stream;
                document.getElementById('camera-name').textContent = camera.label.split('(')[0].trim() || `Camera ${index + 1}`;
            } catch (e) {
                console.error('Failed to start camera:', e);
            }
        }
        
        function switchCamera() {
            state.currentCameraIndex = (state.currentCameraIndex + 1) % state.cameras.length;
            startCamera(state.currentCameraIndex);
        }
        
        async function capturePhoto() {
            if (!state.currentSKU) {
                showToast('warning', 'Enter SKU first');
                document.getElementById('sku-input').focus();
                return;
            }
            
            const video = document.getElementById('camera-preview');
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            canvas.getContext('2d').drawImage(video, 0, 0);
            
            const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.92));
            
            // Determine photo type based on phase
            const photoType = state.phase === 'main' ? 'main' : 
                             state.phase === 'closeup' ? 'closeup' : 'handheld';
            
            const photoIndex = state.photos[photoType].length + 1;
            const label = `${photoType}_${String(photoIndex).padStart(2, '0')}`;
            
            state.photos[photoType].push({
                blob: blob,
                label: label,
                timestamp: Date.now()
            });
            
            updatePhotoGrid();
            updatePhotoCount();
            
            // Auto-advance phase
            if (state.phase === 'main' && state.photos.main.length >= 4) {
                advancePhase('closeup');
            }
        }
        
        function updatePhotoGrid() {
            const grid = document.getElementById('photo-grid');
            grid.innerHTML = '';
            
            const allPhotos = [
                ...state.photos.main.map(p => ({ ...p, type: 'main' })),
                ...state.photos.closeup.map(p => ({ ...p, type: 'closeup' })),
                ...state.photos.handheld.map(p => ({ ...p, type: 'handheld' }))
            ];
            
            allPhotos.forEach((photo, i) => {
                const thumb = document.createElement('div');
                thumb.className = 'photo-thumb';
                thumb.innerHTML = `
                    <img src="${URL.createObjectURL(photo.blob)}" alt="${photo.label}">
                    <div class="label">${photo.label}</div>
                `;
                thumb.onclick = () => deletePhoto(photo.type, state.photos[photo.type].indexOf(photo));
                grid.appendChild(thumb);
            });
        }
        
        function deletePhoto(type, index) {
            if (confirm('Delete this photo?')) {
                state.photos[type].splice(index, 1);
                updatePhotoGrid();
                updatePhotoCount();
            }
        }
        
        function updatePhotoCount() {
            const total = state.photos.main.length + state.photos.closeup.length + state.photos.handheld.length;
            document.getElementById('photo-count').textContent = `${total} photos`;
        }
        
        // =====================================================================
        // CATEGORY & TEMPLATE
        // =====================================================================
        
        function buildCategoryGrid() {
            const grid = document.getElementById('category-grid');
            grid.innerHTML = '';
            
            Object.entries(CATEGORIES).forEach(([key, cat]) => {
                const btn = document.createElement('button');
                btn.className = 'category-btn';
                btn.textContent = cat.label;
                btn.onclick = () => selectCategory(key);
                btn.dataset.category = key;
                grid.appendChild(btn);
            });
        }
        
        function selectCategory(category) {
            state.classification = category;
            
            // Update UI
            document.querySelectorAll('.category-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.category === category);
            });
            
            // Load default template for category
            const templateKey = getDefaultTemplateForCategory(category);
            loadTemplate(templateKey);
            
            showToast('info', `Category: ${CATEGORIES[category].label}`);
        }
        
        function getDefaultTemplateForCategory(category) {
            const defaults = {
                'tops': 'tshirt',
                'bottoms': 'jeans',
                'outerwear': 'jacket',
                'dresses': 'dress',
                'suits': 'suit_jacket',
                'accessories': 'hat',
                'footwear': 'sneakers',
                'other': 'generic'
            };
            return defaults[category] || 'generic';
        }
        
        async function loadTemplates() {
            try {
                const result = await callLambda('templates', {});
                if (result.success && result.templates) {
                    state.templates = result.templates;
                    console.log(`üìã Loaded ${Object.keys(state.templates).length} templates`);
                }
            } catch (e) {
                console.warn('Failed to load templates:', e);
            }
        }
        
        function loadTemplate(templateKey) {
            state.templateKey = templateKey;
            state.template = state.templates[templateKey] || { measurements: ['length', 'width'] };
            
            // Build measurement grid
            const grid = document.getElementById('measurement-grid');
            grid.innerHTML = '';
            
            if (state.template.measurements) {
                state.template.measurements.forEach((m, i) => {
                    const item = document.createElement('div');
                    item.className = 'measurement-item';
                    item.innerHTML = `
                        <span class="measurement-label">${formatMeasurementName(m)}</span>
                        <span class="measurement-value" id="mv-${i}">--</span>
                    `;
                    grid.appendChild(item);
                });
            }
        }
        
        function formatMeasurementName(name) {
            return name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
        }
        
        // =====================================================================
        // RECORDING (Measurements)
        // =====================================================================
        
        async function startRecording() {
            if (state.isRecording) return;
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                state.mediaRecorder = new MediaRecorder(stream);
                state.audioChunks = [];
                
                state.mediaRecorder.ondataavailable = e => {
                    if (e.data.size > 0) state.audioChunks.push(e.data);
                };
                
                state.mediaRecorder.onstop = async () => {
                    const blob = new Blob(state.audioChunks, { type: 'audio/webm' });
                    state.audioBlob = blob;
                    
                    // Transcribe
                    await transcribeAudio(blob);
                    
                    stream.getTracks().forEach(t => t.stop());
                };
                
                state.mediaRecorder.start();
                state.isRecording = true;
                state.recordingStart = Date.now();
                document.getElementById('recording-indicator').classList.add('active');
                
            } catch (e) {
                console.error('Recording failed:', e);
                showToast('error', 'Microphone access denied');
            }
        }
        
        function stopRecording() {
            if (!state.isRecording) return;
            
            state.lastRecordingDuration = Math.round((Date.now() - state.recordingStart) / 1000);
            state.mediaRecorder.stop();
            state.isRecording = false;
            document.getElementById('recording-indicator').classList.remove('active');
        }
        
        async function transcribeAudio(blob) {
            try {
                const base64 = await blobToBase64(blob);
                const result = await callLambda('whisper', { audio: base64.split(',')[1] });
                
                if (result.success && result.transcript) {
                    state.rawTranscript = result.transcript;
                    
                    // Simple parsing (full parsing happens async in Lambda)
                    const parsed = parseTranscriptSimple(result.transcript);
                    state.measurements = parsed;
                    updateMeasurementDisplay();
                    
                    showToast('success', 'Measurements recorded');
                }
            } catch (e) {
                console.error('Transcription failed:', e);
                showToast('error', 'Transcription failed');
            }
        }
        
        function parseTranscriptSimple(transcript) {
            // Basic parsing - just extract numbers
            // Full semantic matching happens in Lambda async
            const measurements = {};
            const pattern = /(\w+[\w\s]*?)\s*[:\-]?\s*(\d+(?:\.\d+)?)/gi;
            let match;
            
            while ((match = pattern.exec(transcript)) !== null) {
                const name = match[1].toLowerCase().trim();
                const value = parseFloat(match[2]);
                measurements[name] = value;
            }
            
            return measurements;
        }
        
        function updateMeasurementDisplay() {
            if (!state.template?.measurements) return;
            
            state.template.measurements.forEach((m, i) => {
                const el = document.getElementById(`mv-${i}`);
                if (el) {
                    const value = state.measurements[m] || state.measurements[m.toLowerCase()];
                    if (value !== undefined) {
                        el.textContent = `${value}"`;
                        el.closest('.measurement-item').classList.add('completed');
                    }
                }
            });
        }
        
        // =====================================================================
        // PHASE MANAGEMENT
        // =====================================================================
        
        function advancePhase(phase) {
            state.phase = phase;
            state.timing[`${phase}Start`] = Date.now();
            
            // Update phase indicators
            document.querySelectorAll('.phase').forEach(p => {
                p.classList.remove('active', 'complete');
            });
            
            const phases = ['main', 'closeup', 'measure', 'complete'];
            const currentIndex = phases.indexOf(phase);
            
            phases.forEach((p, i) => {
                const el = document.getElementById(`phase-${p}`);
                if (i < currentIndex) el.classList.add('complete');
                if (i === currentIndex) el.classList.add('active');
            });
            
            // Auto-start recording for measurements phase
            if (phase === 'measurements') {
                startRecording();
            }
            
            showToast('info', `Phase: ${phase.charAt(0).toUpperCase() + phase.slice(1)}`);
        }
        
        // =====================================================================
        // TIMER
        // =====================================================================
        
        function startTimer() {
            state.timerStart = Date.now();
            state.timerInterval = setInterval(updateTimer, 1000);
            advancePhase('main');
        }
        
        function stopTimer() {
            if (state.timerInterval) {
                clearInterval(state.timerInterval);
                state.timerInterval = null;
            }
        }
        
        function updateTimer() {
            if (!state.timerStart) return;
            
            const elapsed = Math.floor((Date.now() - state.timerStart) / 1000);
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;
            
            const timerEl = document.getElementById('timer');
            timerEl.textContent = `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
            
            // Color coding
            timerEl.classList.remove('warning', 'danger');
            if (elapsed > 120) timerEl.classList.add('danger');
            else if (elapsed > 90) timerEl.classList.add('warning');
        }
        
        // =====================================================================
        // WEIGHT (Dymo Scale)
        // =====================================================================
        
        function initDymoScale() {
            // Try to connect to Dymo scale via WebHID
            if ('hid' in navigator) {
                navigator.hid.getDevices().then(devices => {
                    const dymo = devices.find(d => d.vendorId === 0x0922);
                    if (dymo) connectDymoScale(dymo);
                });
            }
            
            // Fallback: manual weight entry
            document.getElementById('weight-value').onclick = () => {
                const weight = prompt('Enter weight (oz):');
                if (weight) {
                    const oz = parseFloat(weight);
                    state.weight = {
                        pounds: oz / 16,
                        display: `${oz.toFixed(1)} oz`
                    };
                    document.getElementById('weight-value').textContent = state.weight.display;
                    document.getElementById('weight-status').textContent = 'Manual entry';
                }
            };
        }
        
        async function connectDymoScale(device) {
            try {
                await device.open();
                device.addEventListener('inputreport', handleDymoData);
                document.getElementById('weight-status').textContent = 'Dymo connected';
            } catch (e) {
                console.warn('Dymo connection failed:', e);
            }
        }
        
        function handleDymoData(event) {
            const data = new Uint8Array(event.data.buffer);
            // Dymo M10 protocol: bytes 4-5 are weight in 0.1oz units
            if (data.length >= 6) {
                const rawWeight = (data[5] << 8) | data[4];
                const oz = rawWeight / 10;
                
                if (oz > 0) {
                    state.weight = {
                        pounds: oz / 16,
                        display: `${oz.toFixed(1)} oz`
                    };
                    document.getElementById('weight-value').textContent = state.weight.display;
                    document.getElementById('weight-status').textContent = 'Live from Dymo';
                }
            }
        }
        
        function getCurrentWeight() {
            return state.weight || { pounds: null, display: 'N/A' };
        }
        
        // =====================================================================
        // COMPLETE ITEM - v2.9.5 ASYNC (ZERO WAIT!)
        // =====================================================================
        
        async function completeItem() {
            if (!state.currentSKU) {
                showToast('warning', 'No SKU');
                return;
            }
            
            // Stop recording if active
            if (state.isRecording) {
                stopRecording();
                // Give a moment for transcription
                await new Promise(r => setTimeout(r, 500));
            }
            
            // ===== NO AI PROCESSING HERE! =====
            // All AI runs async in Lambda after S3 upload
            
            const now = Date.now();
            const totalDuration = Math.round((now - state.timerStart) / 1000);
            const mainDuration = state.timing.closeupStart ? Math.round((state.timing.closeupStart - state.timerStart) / 1000) : totalDuration;
            const closeupDuration = state.timing.measurementsStart && state.timing.closeupStart ? Math.round((state.timing.measurementsStart - state.timing.closeupStart) / 1000) : 0;
            const measurementsDuration = state.timing.measurementsStart ? Math.round((now - state.timing.measurementsStart) / 1000) : 0;
            
            const weightData = getCurrentWeight();
            const recordingDuration = state.lastRecordingDuration || 0;
            const recordingRating = recordingDuration <= 30 ? 'excellent' : recordingDuration <= 60 ? 'good' : 'needs_improvement';
            
            // Build item data - NO AI results yet, just raw data
            const itemData = {
                sku: state.currentSKU,
                category: state.classification,
                templateKey: state.templateKey,
                template: state.template,
                tagData: null, // Will be populated by Lambda async
                measurements: state.measurements, // Simple parsed, Lambda will do semantic matching
                rawTranscript: state.rawTranscript,
                audioBlob: state.audioBlob,
                discardedRecordings: state.discardedRecordings,
                weight: weightData,
                photos: {
                    main: state.photos.main.map(p => ({ blob: p.blob, label: p.label })),
                    closeup: state.photos.closeup.map(p => ({ blob: p.blob, label: p.label })),
                    handheld: state.photos.handheld.map(p => ({ blob: p.blob, label: p.label }))
                },
                timing: {
                    mainPhotosDuration: mainDuration,
                    closeupDuration: closeupDuration,
                    measurementsDuration: measurementsDuration,
                    totalDuration: totalDuration
                },
                jsonData: {
                    sku: state.currentSKU,
                    timestamp: new Date().toISOString(),
                    version: VERSION,
                    
                    // Raw classification (Lambda may update)
                    category: state.classification,
                    templateKey: state.templateKey,
                    
                    // Placeholder - Lambda will populate via OCR
                    tagData: null,
                    
                    // Simple parsed measurements - Lambda will do semantic matching
                    measurements: state.measurements,
                    rawTranscript: state.rawTranscript,
                    
                    weight: weightData,
                    
                    // Processing status - Lambda will update
                    processingStatus: 'pending',
                    aiProcessing: {
                        ocr: { status: 'pending' },
                        imageProcessing: { status: 'pending' },
                        photoRouting: { status: 'pending' },
                        pipeline: { status: 'pending' }
                    },
                    
                    // Lambda will populate these
                    pipelineResults: null,
                    eraEstimation: null,
                    tagSizeAnalysis: null,
                    imageProcessing: null,
                    photoRouting: null,
                    qcFlags: null,
                    
                    audioRecordings: {
                        final: {
                            duration: recordingDuration,
                            timestamp: new Date().toISOString()
                        },
                        discarded: state.discardedRecordings.map((d, i) => ({
                            index: i + 1,
                            duration: d.duration,
                            timestamp: d.timestamp
                        })),
                        totalAttempts: state.discardedRecordings.length + 1,
                        kpiTargets: {
                            targetDuration: 60,
                            excellentDuration: 30,
                            actualDuration: recordingDuration,
                            rating: recordingRating
                        }
                    },
                    timing: {
                        mainPhotosDuration: mainDuration,
                        closeupDuration: closeupDuration,
                        measurementsDuration: measurementsDuration,
                        totalDuration: totalDuration,
                        browserProcessingTime: 0 // No AI processing in browser anymore!
                    },
                    photoCount: {
                        main: state.photos.main.length,
                        closeup: state.photos.closeup.length,
                        handheld: state.photos.handheld.length
                    },
                    photographerId: localStorage.getItem('photographerId') || 'unknown',
                    flags: {},
                    confidence: {}
                }
            };
            
            // Update stats
            state.completedItems++;
            state.totalTime += totalDuration;
            localStorage.setItem('completedItems', state.completedItems);
            localStorage.setItem('totalTime', state.totalTime);
            updateStats();
            
            // ===== INSTANT UI RESET =====
            showToast('success', `‚úÖ ${state.currentSKU} submitted!`);
            stopTimer();
            resetItem();
            
            // Process in background (upload to S3, send to n8n)
            processItemInBackground(itemData);
        }
        
        // =====================================================================
        // BACKGROUND PROCESSING
        // =====================================================================
        
        async function processItemInBackground(itemData, retryCount = 0) {
            const sku = itemData.sku;
            console.log(`üîÑ [${sku}] Starting background upload...`);
            
            try {
                // STEP 1: Save to local folder (if selected)
                if (state.saveDirectoryHandle) {
                    console.log(`üíæ [${sku}] Saving to local folder...`);
                    await saveToLocalFolder(itemData);
                }
                
                // STEP 2: Upload to S3
                console.log(`‚òÅÔ∏è [${sku}] Uploading to S3...`);
                await uploadToS3(itemData);
                console.log(`‚úÖ [${sku}] Uploaded to S3`);
                
                // STEP 3: Trigger async processing
                // This tells Lambda to process this item
                console.log(`üöÄ [${sku}] Triggering async processing...`);
                await callLambda('triggerAsyncProcessing', {
                    sku: sku,
                    bucket: 'your-bucket-name', // Configure this
                    category: itemData.category,
                    templateKey: itemData.templateKey
                });
                
                // STEP 4: Send to n8n (with pending status)
                console.log(`üì§ [${sku}] Sending to n8n...`);
                await callLambda('n8n', { formData: itemData.jsonData });
                
                console.log(`üéâ [${sku}] Background processing triggered!`);
                
            } catch (err) {
                console.error(`‚ùå [${sku}] Background process failed:`, err);
                
                if (retryCount < MAX_RETRIES) {
                    console.log(`‚Üª [${sku}] Retry ${retryCount + 1}/${MAX_RETRIES} in ${RETRY_DELAY/1000}s...`);
                    setTimeout(() => processItemInBackground(itemData, retryCount + 1), RETRY_DELAY);
                } else {
                    showToast('warning', `‚ö†Ô∏è ${sku} upload incomplete - queued for retry`);
                    addToRetryQueue(itemData);
                }
            }
        }
        
        // =====================================================================
        // S3 UPLOAD
        // =====================================================================
        
        async function uploadToS3(itemData) {
            const sku = itemData.sku;
            const files = [];
            
            // Main photos ‚Üí main/raw/
            for (let i = 0; i < itemData.photos.main.length; i++) {
                const p = itemData.photos.main[i];
                files.push({
                    name: `main/raw/${sku}_main_${String(i + 1).padStart(2, '0')}.jpg`,
                    contentType: 'image/jpeg',
                    blob: p.blob
                });
            }
            
            // Closeup photos ‚Üí tag/ (Lambda will route to correct folders)
            for (let i = 0; i < itemData.photos.closeup.length; i++) {
                const p = itemData.photos.closeup[i];
                files.push({
                    name: `tag/${sku}_closeup_${String(i + 1).padStart(2, '0')}.jpg`,
                    contentType: 'image/jpeg',
                    blob: p.blob
                });
            }
            
            // Handheld photos
            for (let i = 0; i < itemData.photos.handheld.length; i++) {
                const p = itemData.photos.handheld[i];
                files.push({
                    name: `handheld/${sku}_handheld_${String(i + 1).padStart(2, '0')}.jpg`,
                    contentType: 'image/jpeg',
                    blob: p.blob
                });
            }
            
            // Weight
            if (itemData.weight && itemData.weight.pounds !== null) {
                const weightContent = `${sku}\nWeight: ${itemData.weight.display}\nDecimal Pounds: ${itemData.weight.pounds.toFixed(4)}\nSource: Dymo M10\nTimestamp: ${new Date().toISOString()}`;
                files.push({ name: `weight/${sku}_weight.txt`, contentType: 'text/plain', blob: new Blob([weightContent]) });
            }
            
            // Audio
            if (itemData.audioBlob) {
                files.push({ name: `measurements/${sku}_audio_final.webm`, contentType: 'audio/webm', blob: itemData.audioBlob });
            }
            
            // Transcript
            if (itemData.rawTranscript) {
                files.push({ name: `measurements/${sku}_transcript_raw.txt`, contentType: 'text/plain', blob: new Blob([itemData.rawTranscript]) });
            }
            
            // Master JSON (with pending status)
            files.push({
                name: `data/${sku}_data.json`,
                contentType: 'application/json',
                blob: new Blob([JSON.stringify(itemData.jsonData, null, 2)])
            });
            
            // Get presigned URLs
            const presign = await callLambda('presign', {
                sku: sku,
                files: files.map(f => ({ name: f.name, contentType: f.contentType }))
            });
            
            if (!presign.success) throw new Error(presign.error || 'Presign failed');
            
            // Upload all files
            const uploadPromises = files.map(f => {
                const url = presign.urls[f.name];
                if (url) {
                    return fetch(url, {
                        method: 'PUT',
                        body: f.blob,
                        headers: { 'Content-Type': f.contentType }
                    });
                }
                return Promise.resolve();
            });
            
            await Promise.all(uploadPromises);
        }
        
        // =====================================================================
        // LOCAL FOLDER SAVE
        // =====================================================================
        
        async function selectSaveFolder() {
            try {
                state.saveDirectoryHandle = await window.showDirectoryPicker();
                localStorage.setItem('saveFolderName', state.saveDirectoryHandle.name);
                document.getElementById('folder-path').textContent = `üìÅ ${state.saveDirectoryHandle.name}`;
                showToast('success', 'Save folder selected');
            } catch (e) {
                console.warn('Folder selection cancelled');
            }
        }
        
        async function saveToLocalFolder(itemData) {
            if (!state.saveDirectoryHandle) return;
            
            const sku = itemData.sku;
            
            try {
                // Create SKU folder
                const skuFolder = await state.saveDirectoryHandle.getDirectoryHandle(sku, { create: true });
                
                // Create subfolders
                const mainFolder = await skuFolder.getDirectoryHandle('main', { create: true });
                const rawFolder = await mainFolder.getDirectoryHandle('raw', { create: true });
                const tagFolder = await skuFolder.getDirectoryHandle('tag', { create: true });
                const dataFolder = await skuFolder.getDirectoryHandle('data', { create: true });
                
                // Save main photos
                for (let i = 0; i < itemData.photos.main.length; i++) {
                    const p = itemData.photos.main[i];
                    const file = await rawFolder.getFileHandle(`${sku}_main_${String(i + 1).padStart(2, '0')}.jpg`, { create: true });
                    const writable = await file.createWritable();
                    await writable.write(p.blob);
                    await writable.close();
                }
                
                // Save closeup photos
                for (let i = 0; i < itemData.photos.closeup.length; i++) {
                    const p = itemData.photos.closeup[i];
                    const file = await tagFolder.getFileHandle(`${sku}_closeup_${String(i + 1).padStart(2, '0')}.jpg`, { create: true });
                    const writable = await file.createWritable();
                    await writable.write(p.blob);
                    await writable.close();
                }
                
                // Save JSON
                const jsonFile = await dataFolder.getFileHandle(`${sku}_data.json`, { create: true });
                const jsonWritable = await jsonFile.createWritable();
                await jsonWritable.write(JSON.stringify(itemData.jsonData, null, 2));
                await jsonWritable.close();
                
            } catch (e) {
                console.error('Local save failed:', e);
            }
        }
        
        // =====================================================================
        // RETRY QUEUE
        // =====================================================================
        
        function addToRetryQueue(itemData) {
            const queueItem = {
                sku: itemData.sku,
                jsonData: itemData.jsonData,
                timestamp: Date.now()
            };
            state.retryQueue.push(queueItem);
            localStorage.setItem('retryQueue', JSON.stringify(state.retryQueue));
            updateRetryBadge();
        }
        
        function updateRetryBadge() {
            const badge = document.getElementById('retry-badge');
            if (state.retryQueue.length > 0) {
                badge.textContent = `‚ö†Ô∏è ${state.retryQueue.length} pending`;
                badge.classList.add('visible');
            } else {
                badge.classList.remove('visible');
            }
        }
        
        async function processRetryQueue() {
            if (state.retryQueue.length === 0) return;
            
            showToast('info', `Retrying ${state.retryQueue.length} items...`);
            
            const toRetry = [...state.retryQueue];
            state.retryQueue = [];
            
            for (const item of toRetry) {
                try {
                    await callLambda('n8n', { formData: item.jsonData });
                    console.log(`‚úÖ Retry success: ${item.sku}`);
                } catch (e) {
                    state.retryQueue.push(item);
                }
            }
            
            localStorage.setItem('retryQueue', JSON.stringify(state.retryQueue));
            updateRetryBadge();
            
            if (state.retryQueue.length === 0) {
                showToast('success', 'All retries successful!');
            } else {
                showToast('warning', `${state.retryQueue.length} items still pending`);
            }
        }
        
        // =====================================================================
        // RESET
        // =====================================================================
        
        function resetItem() {
            state.currentSKU = null;
            state.classification = null;
            state.templateKey = null;
            state.template = null;
            state.photos = { main: [], closeup: [], handheld: [] };
            state.measurements = {};
            state.rawTranscript = null;
            state.audioBlob = null;
            state.discardedRecordings = [];
            state.lastRecordingDuration = 0;
            state.weight = null;
            state.timerStart = null;
            state.phase = 'main';
            state.timing = {};
            
            // Reset UI
            document.getElementById('sku-input').value = '';
            document.getElementById('sku-input').focus();
            document.getElementById('timer').textContent = '00:00';
            document.getElementById('timer').classList.remove('warning', 'danger');
            document.getElementById('photo-count').textContent = '0 photos';
            document.getElementById('photo-grid').innerHTML = '';
            document.getElementById('measurement-grid').innerHTML = '';
            document.getElementById('weight-value').textContent = '--';
            document.getElementById('tag-grid').style.display = 'none';
            
            document.querySelectorAll('.category-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.phase').forEach(p => p.classList.remove('active', 'complete'));
        }
        
        // =====================================================================
        // STATS
        // =====================================================================
        
        function updateStats() {
            document.getElementById('stat-completed').textContent = state.completedItems;
            
            if (state.completedItems > 0) {
                const avgTime = Math.round(state.totalTime / state.completedItems);
                const mins = Math.floor(avgTime / 60);
                const secs = avgTime % 60;
                document.getElementById('stat-avg-time').textContent = `${mins}:${String(secs).padStart(2, '0')}`;
                
                const sessionHours = (Date.now() - state.sessionStart) / 3600000;
                const perHour = sessionHours > 0 ? Math.round(state.completedItems / sessionHours) : 0;
                document.getElementById('stat-per-hour').textContent = perHour;
            }
        }
        
        // =====================================================================
        // UTILITIES
        // =====================================================================
        
        async function callLambda(action, data) {
            const response = await fetch(LAMBDA_URL, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action, ...data })
            });
            return response.json();
        }
        
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }
        
        function showToast(type, message) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            container.appendChild(toast);
            
            setTimeout(() => toast.remove(), 4000);
        }
        
        // =====================================================================
        // KEYBOARD SHORTCUTS
        // =====================================================================
        
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                // Space = capture photo
                if (e.code === 'Space' && document.activeElement.tagName !== 'INPUT') {
                    e.preventDefault();
                    capturePhoto();
                }
                
                // Enter in SKU field = start timer
                if (e.code === 'Enter' && document.activeElement.id === 'sku-input') {
                    const sku = document.getElementById('sku-input').value.trim().toUpperCase();
                    if (sku) {
                        state.currentSKU = sku;
                        startTimer();
                        showToast('info', `SKU: ${sku}`);
                    }
                }
                
                // R = start/stop recording
                if (e.code === 'KeyR' && e.ctrlKey) {
                    e.preventDefault();
                    if (state.isRecording) {
                        stopRecording();
                    } else {
                        advancePhase('measurements');
                    }
                }
                
                // C = complete
                if (e.code === 'KeyC' && e.ctrlKey && e.shiftKey) {
                    e.preventDefault();
                    completeItem();
                }
                
                // 1-8 = select category
                if (e.code.startsWith('Digit') && document.activeElement.tagName !== 'INPUT') {
                    const num = parseInt(e.code.slice(5));
                    const categories = Object.keys(CATEGORIES);
                    if (num >= 1 && num <= categories.length) {
                        selectCategory(categories[num - 1]);
                    }
                }
            });
        }
        
        // =====================================================================
        // INIT
        // =====================================================================
        
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>

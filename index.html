<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VintageLister v2.9.4</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/quagga/0.12.1/quagga.min.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --accent-blue: #3b82f6;
            --accent-green: #22c55e;
            --accent-yellow: #eab308;
            --accent-orange: #f97316;
            --accent-red: #ef4444;
            --accent-purple: #a855f7;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --border-color: #475569;
            --radius: 8px;
        }
        
        html, body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }
        
        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            height: 100vh;
            overflow: hidden;
        }
        
        @media (max-width: 1200px) {
            .app-container { grid-template-columns: 260px 1fr 260px; }
        }
        
        .panel {
            background: var(--bg-primary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .panel-right { border-right: none; border-left: 1px solid var(--border-color); }
        
        .panel-scroll {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        
        /* Header */
        .header-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 16px;
            background: linear-gradient(135deg, var(--accent-blue), #2563eb);
            flex-shrink: 0;
        }
        
        .timer-section { text-align: left; }
        .timer { font-size: 28px; font-weight: 700; font-family: 'Courier New', monospace; color: white; }
        .timer-label { font-size: 9px; color: rgba(255,255,255,0.7); text-transform: uppercase; }
        
        .stats-section { text-align: center; }
        .stats-row { display: flex; gap: 12px; }
        .stat-item { text-align: center; }
        .stat-value { font-size: 16px; font-weight: 700; color: white; }
        .stat-label { font-size: 8px; color: rgba(255,255,255,0.7); text-transform: uppercase; }
        
        .version-info { text-align: right; }
        .version-badge { font-size: 10px; color: rgba(255,255,255,0.9); background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px; display: block; margin-bottom: 4px; }
        .retry-badge { font-size: 9px; color: var(--accent-yellow); display: none; }
        .retry-badge.visible { display: block; }
        
        /* Section Cards */
        .section-card {
            background: var(--bg-secondary);
            border-radius: var(--radius);
            padding: 12px;
            margin-bottom: 10px;
        }
        
        .section-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        
        /* SKU Input - Fixed Layout */
        .sku-row {
            display: flex;
            gap: 6px;
            margin-bottom: 8px;
            flex-wrap: nowrap;
        }
        
        .sku-input {
            flex: 1;
            min-width: 0;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 600;
        }
        
        .sku-input:focus { outline: none; border-color: var(--accent-blue); }
        
        .sku-btn {
            padding: 10px 12px;
            border: none;
            border-radius: var(--radius);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .sku-btn-scan { background: var(--accent-purple); color: white; }
        .sku-btn-start { background: var(--accent-green); color: white; font-weight: 600; }
        .sku-btn:hover { filter: brightness(1.1); }
        
        .sku-display {
            display: none;
            padding: 12px;
            background: var(--accent-green);
            border-radius: var(--radius);
            font-size: 18px;
            font-weight: 700;
            text-align: center;
            cursor: pointer;
        }
        
        .sku-display.visible { display: block; }
        .sku-display:hover { background: #16a34a; }
        
        /* Classification */
        .classification-box {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            padding: 12px;
        }
        
        .classification-box.ready { border-color: var(--accent-green); }
        .classification-category { font-size: 18px; font-weight: 700; color: var(--accent-yellow); }
        .classification-template { font-size: 12px; color: var(--text-secondary); margin-top: 4px; }
        .classification-template span { color: var(--accent-blue); font-weight: 600; }
        
        /* Tag Data */
        .tag-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 10px;
        }
        
        .tag-item {
            background: var(--bg-secondary);
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 11px;
        }
        
        .tag-label { color: var(--text-secondary); font-size: 9px; text-transform: uppercase; }
        .tag-value { font-weight: 600; margin-top: 2px; }
        
        /* Folder Display */
        .folder-display {
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 11px;
            margin-bottom: 8px;
            color: var(--text-secondary);
            cursor: pointer;
        }
        
        .folder-display.set { color: var(--accent-green); }
        
        /* Photo Grid */
        .photo-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
        
        .photo-thumb {
            position: relative;
            aspect-ratio: 1;
            border-radius: 6px;
            overflow: hidden;
            background: var(--bg-tertiary);
        }
        
        .photo-thumb img { width: 100%; height: 100%; object-fit: cover; }
        
        .photo-thumb-label {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.8);
            padding: 3px;
            font-size: 8px;
            text-align: center;
            color: var(--accent-yellow);
        }
        
        .photo-thumb-delete {
            position: absolute;
            top: 2px; right: 2px;
            width: 18px; height: 18px;
            border-radius: 50%;
            border: none;
            background: var(--accent-red);
            color: white;
            font-size: 10px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        .photo-thumb:hover .photo-thumb-delete { opacity: 1; }
        
        /* Camera Panel */
        .camera-panel {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: #000;
        }
        
        .camera-tabs {
            display: flex;
            gap: 4px;
            padding: 8px;
            background: var(--bg-secondary);
            flex-shrink: 0;
        }
        
        .camera-tab {
            flex: 1;
            padding: 12px 8px;
            border: none;
            border-radius: var(--radius);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .camera-tab:hover { background: var(--bg-primary); color: var(--text-primary); }
        .camera-tab.active { background: var(--accent-blue); color: white; }
        .camera-tab.closeup.active { background: var(--accent-orange); }
        .camera-tab.handheld.active { background: var(--accent-purple); }
        
        /* Camera Info */
        .camera-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 12px;
            background: rgba(0,0,0,0.5);
            font-size: 11px;
            color: var(--text-secondary);
            flex-shrink: 0;
        }
        
        .camera-name { font-weight: 600; color: var(--text-primary); }
        .resolution-badge { background: var(--bg-secondary); padding: 3px 8px; border-radius: 4px; }
        .photo-count-badge { background: var(--accent-green); color: white; padding: 3px 10px; border-radius: 4px; font-weight: 600; }
        
        /* Video */
        .video-container {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 0;
        }
        
        .video-container video { width: 100%; height: 100%; object-fit: contain; }
        .video-placeholder { color: var(--text-secondary); text-align: center; padding: 40px; }
        
        .capture-flash {
            position: absolute;
            inset: 0;
            background: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s;
        }
        
        .capture-flash.active { opacity: 0.7; }
        
        /* Capture Area - Complete Button */
        .capture-area {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            padding: 16px;
            background: var(--bg-secondary);
            flex-shrink: 0;
        }
        
        .capture-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 4px solid var(--text-primary);
            background: transparent;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }
        
        .capture-btn::after {
            content: '';
            position: absolute;
            inset: 5px;
            border-radius: 50%;
            background: var(--text-primary);
            transition: all 0.2s;
        }
        
        .capture-btn:hover::after { background: var(--accent-blue); }
        .capture-btn:active { transform: scale(0.95); }
        
        .complete-btn-camera {
            padding: 14px 24px;
            border: none;
            border-radius: var(--radius);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            background: var(--accent-green);
            color: white;
            transition: all 0.2s;
        }
        
        .complete-btn-camera:hover { filter: brightness(1.1); }
        .complete-btn-camera:disabled { opacity: 0.5; cursor: not-allowed; }
        
        /* AI Overlay */
        .ai-overlay {
            position: absolute;
            inset: 0;
            background: rgba(15, 23, 42, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 12px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        
        .ai-overlay.active { opacity: 1; visibility: visible; }
        .spinner { width: 36px; height: 36px; border: 3px solid var(--bg-tertiary); border-top-color: var(--accent-blue); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* Measurements */
        .measurement-list { display: flex; flex-direction: column; gap: 6px; }
        
        .measurement-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 12px;
        }
        
        .measurement-item.completed {
            background: linear-gradient(90deg, rgba(34,197,94,0.2), transparent);
            border-left: 3px solid var(--accent-green);
        }
        
        .measurement-num {
            width: 22px; height: 22px;
            border-radius: 50%;
            background: var(--bg-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            margin-right: 8px;
            flex-shrink: 0;
        }
        
        .measurement-name { flex: 1; }
        .measurement-value { font-weight: 600; color: var(--accent-green); }
        
        /* Transcript Display */
        .transcript-box {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 10px;
            margin-top: 10px;
            font-size: 11px;
            color: var(--text-secondary);
            display: none;
        }
        
        .transcript-box.visible { display: block; }
        .transcript-label { font-weight: 600; color: var(--text-primary); margin-bottom: 4px; }
        .transcript-text { font-style: italic; }
        
        /* Buttons */
        .btn {
            padding: 12px 16px;
            border: none;
            border-radius: var(--radius);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
            margin-bottom: 8px;
        }
        
        .btn-primary { background: var(--accent-green); color: white; }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); }
        .btn-record { background: var(--accent-red); color: white; }
        .btn-stop { background: #dc2626; color: white; animation: pulse-stop 1s infinite; }
        .btn:hover { filter: brightness(1.1); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        @keyframes pulse-stop { 
            0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7); } 
            50% { opacity: 0.9; box-shadow: 0 0 0 10px rgba(220, 38, 38, 0); } 
        }
        
        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }
        
        .modal-overlay.active { opacity: 1; visibility: visible; }
        
        .modal {
            background: var(--bg-secondary);
            border-radius: var(--radius);
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .modal-title { font-size: 16px; font-weight: 600; }
        
        .modal-close {
            width: 30px; height: 30px;
            border: none;
            border-radius: 50%;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 16px;
            cursor: pointer;
        }
        
        .modal-body { padding: 16px; }
        .form-group { margin-bottom: 14px; }
        .form-label { display: block; font-size: 11px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase; }
        
        .form-select, .form-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 13px;
        }
        
        .form-select:focus, .form-input:focus { outline: none; border-color: var(--accent-blue); }
        
        /* Barcode Scanner */
        .barcode-container {
            position: relative;
            background: #000;
            aspect-ratio: 4/3;
            border-radius: var(--radius);
            overflow: hidden;
        }
        
        .barcode-container video, .barcode-container canvas { width: 100%; height: 100%; object-fit: cover; }
        
        .barcode-target {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 200px; height: 80px;
            border: 3px solid var(--accent-yellow);
            border-radius: 8px;
        }
        
        .barcode-status {
            position: absolute;
            bottom: 10px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
        }
        
        .barcode-status.success { background: var(--accent-green); }
        
        /* Toast */
        .toast-container {
            position: fixed;
            top: 20px; right: 20px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .toast {
            padding: 10px 16px;
            border-radius: var(--radius);
            font-size: 13px;
            font-weight: 500;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        
        .toast.success { background: var(--accent-green); color: white; }
        .toast.error { background: var(--accent-red); color: white; }
        .toast.warning { background: var(--accent-yellow); color: black; }
        .toast.info { background: var(--accent-blue); color: white; }
        
        /* Dymo Scale */
        .scale-display {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: var(--radius);
            margin-bottom: 8px;
        }
        
        .scale-display.connected { border: 1px solid var(--accent-green); }
        .scale-display.disconnected { border: 1px dashed var(--border-color); }
        
        .scale-weight {
            font-size: 24px;
            font-weight: 700;
            font-family: 'Courier New', monospace;
            color: var(--accent-green);
            flex: 1;
        }
        
        .scale-weight.waiting { color: var(--text-secondary); font-size: 14px; }
        
        .scale-unit {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .scale-status {
            font-size: 10px;
            padding: 3px 8px;
            border-radius: 4px;
            text-transform: uppercase;
        }
        
        .scale-status.connected { background: var(--accent-green); color: white; }
        .scale-status.disconnected { background: var(--bg-secondary); color: var(--text-secondary); }
        .scale-status.reading { background: var(--accent-blue); color: white; }
        
        .scale-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            cursor: pointer;
            background: var(--accent-purple);
            color: white;
        }
        
        .scale-btn:hover { filter: brightness(1.1); }
        .scale-btn.disconnect { background: var(--accent-red); }
    </style>
</head>
<body>
    <div class="toast-container" id="toast-container"></div>
    
    <div class="app-container">
        <!-- Left Panel -->
        <div class="panel panel-left">
            <div class="header-bar">
                <div class="timer-section">
                    <div class="timer" id="timer">0:00</div>
                    <div class="timer-label">Item Time</div>
                </div>
                <div class="stats-section">
                    <div class="stats-row">
                        <div class="stat-item">
                            <div class="stat-value" id="item-count">0</div>
                            <div class="stat-label">Items</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="avg-time">0:00</div>
                            <div class="stat-label">Avg</div>
                        </div>
                    </div>
                </div>
                <div class="version-info">
                    <span class="version-badge" id="version-badge">v2.9.4</span>
                    <span class="retry-badge" id="retry-badge">‚ö†Ô∏è 0 pending</span>
                </div>
            </div>
            
            <div class="panel-scroll">
                <!-- SKU - Fixed Layout -->
                <div class="section-card">
                    <div class="section-title">üè∑Ô∏è Item SKU</div>
                    <div class="sku-row" id="sku-row">
                        <input type="text" class="sku-input" id="sku-input" placeholder="Scan or type SKU...">
                        <button class="sku-btn sku-btn-scan" onclick="openBarcodeScanner()">üì∑</button>
                        <button class="sku-btn sku-btn-start" onclick="startNewItem()">START</button>
                    </div>
                    <div class="sku-display" id="sku-display" onclick="cancelItem()"></div>
                </div>
                
                <!-- Classification -->
                <div class="section-card">
                    <div class="section-title">ü§ñ AI Classification</div>
                    <div class="classification-box" id="classification-box">
                        <div class="classification-category" id="classification-category">Waiting...</div>
                        <div class="classification-template">Template: <span id="classification-template">-</span></div>
                    </div>
                    <div class="tag-grid" id="tag-grid" style="display: none;">
                        <div class="tag-item"><div class="tag-label">Brand</div><div class="tag-value" id="tag-brand">-</div></div>
                        <div class="tag-item"><div class="tag-label">Size</div><div class="tag-value" id="tag-size">-</div></div>
                        <div class="tag-item"><div class="tag-label">Materials</div><div class="tag-value" id="tag-materials">-</div></div>
                        <div class="tag-item"><div class="tag-label">Country</div><div class="tag-value" id="tag-country">-</div></div>
                    </div>
                </div>
                
                <!-- Save Location -->
                <div class="section-card">
                    <div class="section-title">üíæ Save Location</div>
                    <div class="folder-display" id="folder-display" onclick="chooseSaveFolder()">üìÅ Click to choose folder</div>
                </div>
                
                <!-- Dymo USB Scale -->
                <div class="section-card">
                    <div class="section-title">‚öñÔ∏è USB Scale</div>
                    <div class="scale-display disconnected" id="scale-display">
                        <div class="scale-weight waiting" id="scale-weight">Not connected</div>
                        <span class="scale-unit" id="scale-unit"></span>
                        <button class="scale-btn" id="scale-btn" onclick="toggleScale()">Connect</button>
                    </div>
                    <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">
                        Dymo M10 scale (lb:oz format)
                    </div>
                </div>
                
                <!-- Photos -->
                <div class="section-card">
                    <div class="section-title">üì∏ Photos (<span id="photo-count">0</span>)</div>
                    <div class="photo-grid" id="photo-grid"></div>
                </div>
                
                <button class="btn btn-secondary" onclick="openSettings()">‚öôÔ∏è Settings</button>
            </div>
        </div>
        
        <!-- Camera Panel -->
        <div class="panel camera-panel">
            <div class="camera-tabs">
                <button class="camera-tab active" data-mode="main" onclick="switchCameraMode('main')">üì∑ MAIN</button>
                <button class="camera-tab closeup" data-mode="closeup" onclick="switchCameraMode('closeup')">üîç CLOSEUP</button>
                <button class="camera-tab handheld" data-mode="handheld" onclick="switchCameraMode('handheld')">üì± HANDHELD</button>
            </div>
            
            <div class="camera-info">
                <span class="camera-name" id="camera-name">No camera</span>
                <span class="resolution-badge" id="resolution-badge">-</span>
                <span class="photo-count-badge"><span id="mode-photo-count">0</span> photos</span>
            </div>
            
            <div class="video-container">
                <video id="video-preview" autoplay playsinline muted></video>
                <div class="video-placeholder" id="video-placeholder">üì∑ Select a camera in Settings</div>
                <div class="capture-flash" id="capture-flash"></div>
                <div class="ai-overlay" id="ai-overlay">
                    <div class="spinner"></div>
                    <div style="font-size: 13px; color: var(--text-secondary);">AI analyzing photos...</div>
                </div>
            </div>
            
            <div class="capture-area">
                <button class="capture-btn" id="capture-btn" onclick="capturePhoto()"></button>
                <button class="complete-btn-camera" id="complete-btn-camera" onclick="completeItem()" disabled>‚úÖ COMPLETE</button>
            </div>
        </div>
        
        <!-- Right Panel - REMOVED COMPLETE & SAVE BUTTON -->
        <div class="panel panel-right">
            <div class="panel-scroll">
                <div class="section-card">
                    <div class="section-title">üìè Measurements</div>
                    <div class="measurement-list" id="measurement-list">
                        <div style="color: var(--text-secondary); font-size: 12px; text-align: center; padding: 16px;">
                            Classify item first
                        </div>
                    </div>
                    <div class="transcript-box" id="transcript-box">
                        <div class="transcript-label">üìù Transcript:</div>
                        <div class="transcript-text" id="transcript-text"></div>
                    </div>
                </div>
                
                <!-- Recording button - Changes to TAP TO STOP when recording -->
                <button class="btn btn-record" id="record-btn" onclick="toggleRecording()">üé§ TAP TO RECORD</button>
                
                <!-- NOTE: "COMPLETE & SAVE" button REMOVED from here per user request -->
                <!-- The COMPLETE button in the camera capture area is the only submit option -->
            </div>
        </div>
    </div>
    
    <!-- Barcode Modal -->
    <div class="modal-overlay" id="barcode-modal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">üì∑ Scan Barcode</div>
                <button class="modal-close" onclick="closeBarcodeScanner()">√ó</button>
            </div>
            <div class="modal-body" style="padding: 0;">
                <div class="barcode-container" id="barcode-container">
                    <div class="barcode-target"></div>
                    <div class="barcode-status" id="barcode-status">Starting scanner...</div>
                </div>
                <div style="padding: 12px; text-align: center;">
                    <button class="btn btn-secondary" onclick="closeBarcodeScanner()">Cancel</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div class="modal-overlay" id="settings-modal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">‚öôÔ∏è Settings</div>
                <button class="modal-close" onclick="closeSettings()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Main Camera</label>
                    <select class="form-select" id="camera-main"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Closeup Camera</label>
                    <select class="form-select" id="camera-closeup"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Handheld Camera</label>
                    <select class="form-select" id="camera-handheld"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Barcode Scanner Camera</label>
                    <select class="form-select" id="camera-barcode"></select>
                </div>
                <hr style="border-color: var(--border-color); margin: 16px 0;">
                <div class="form-group">
                    <label class="form-label">Lambda URL</label>
                    <input type="text" class="form-input" id="lambda-url" placeholder="https://...">
                </div>
                <button class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
            </div>
        </div>
    </div>
    
    <canvas id="capture-canvas" style="display: none;"></canvas>
    <canvas id="resize-canvas" style="display: none;"></canvas>
    
    <script>
        // =============================================================================
        // VINTAGELISTER v2.9.4
        // 
        // CHANGES FROM v2.9.3:
        // 1. Fixed Dymo M10 scale lb:oz parsing (was showing 1e+35)
        // 2. Removed "COMPLETE & SAVE" button from right panel
        // 3. Recording button now shows "üõë TAP TO STOP" when active (clear, unmistakable)
        // 4. Support for discarded recordings (saved for QC)
        // 5. Background processing calls new fullPipeline agent
        // 6. File storage structure: main/raw/ and main/final/ subfolders
        // 7. Recording duration KPI tracking
        // =============================================================================
        
        const VERSION = '2.9.4';
        const DEFAULT_LAMBDA_URL = 'https://6t5wk2ae23foojyfwmddauorey0pjqji.lambda-url.us-east-2.on.aws/';
        const AI_IMAGE_MAX_SIZE = 1024;
        const MAX_RETRIES = 3;
        const RETRY_DELAY = 5000;
        
        const state = {
            lambdaUrl: localStorage.getItem('lambdaUrl') || DEFAULT_LAMBDA_URL,
            lambdaVersion: null,
            currentSKU: '',
            currentMode: 'main',
            currentStream: null,
            cameras: {
                main: { deviceId: localStorage.getItem('camera-main') || null },
                closeup: { deviceId: localStorage.getItem('camera-closeup') || null },
                handheld: { deviceId: localStorage.getItem('camera-handheld') || null },
                barcode: { deviceId: localStorage.getItem('camera-barcode') || null }
            },
            availableCameras: [],
            photos: { main: [], closeup: [], handheld: [] },
            classification: null,
            templateKey: null,
            template: null,
            tagData: null,
            measurements: {},
            rawTranscript: '',
            audioBlob: null,
            saveDirectoryHandle: null,
            timerStart: null,
            timerInterval: null,
            isRecording: false,
            mediaRecorder: null,
            audioChunks: [],
            aiTriggered: false,
            // Section timing
            timing: { mainStart: null, closeupStart: null, measurementsStart: null },
            // Stats
            completedItems: parseInt(localStorage.getItem('completedItems') || '0'),
            totalTime: parseInt(localStorage.getItem('totalTime') || '0'),
            // Retry queue
            retryQueue: JSON.parse(localStorage.getItem('retryQueue') || '[]'),
            // Dymo USB Scale - v2.9.4 FIXED for M10 lb:oz format
            scaleDevice: null,
            scaleWeight: null,      // Decimal pounds (for storage)
            scaleWeightDisplay: '', // Display format "1 lb 13 oz"
            scaleUnit: 'lb',
            scaleStatus: 'disconnected',
            // v2.9.4 - Discarded recordings for QC
            discardedRecordings: [],
            recordingStartTime: null,
            // v2.9.4 - Photographer ID placeholder
            photographerId: null
        };
        
        // =====================================================================
        // INIT
        // =====================================================================
        async function init() {
            console.log(`%c VintageLister v${VERSION} `, 'background: #3b82f6; color: white; font-size: 14px;');
            document.getElementById('lambda-url').value = state.lambdaUrl;
            updateStats();
            updateRetryBadge();
            await checkLambda();
            await enumerateCameras();
            if (state.cameras.main.deviceId) await startCamera('main');
            
            // SPACE key for pedal capture
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && !e.target.matches('input, textarea')) {
                    e.preventDefault();
                    capturePhoto();
                }
            });
            
            // Process retry queue
            processRetryQueue();
            
            console.log('‚úÖ Init complete - SPACE key enabled, scale fix applied');
        }
        
        // =====================================================================
        // LAMBDA
        // =====================================================================
        async function checkLambda() {
            try {
                const res = await fetch(state.lambdaUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'diagnostics' })
                });
                const data = await res.json();
                if (data.success) {
                    state.lambdaVersion = data.version;
                    document.getElementById('version-badge').textContent = `v${VERSION} | Œª${data.version}`;
                    console.log(`‚úÖ Lambda v${data.version} healthy`);
                    showToast('success', `Connected to Lambda v${data.version}`);
                }
            } catch (err) {
                console.error('Lambda check failed:', err);
                showToast('error', 'Lambda connection failed');
            }
        }
        
        async function callLambda(action, body = {}) {
            const res = await fetch(state.lambdaUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ action, ...body })
            });
            return res.json();
        }
        
        // =====================================================================
        // CAMERA
        // =====================================================================
        async function enumerateCameras() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                stream.getTracks().forEach(t => t.stop());
                const devices = await navigator.mediaDevices.enumerateDevices();
                state.availableCameras = devices.filter(d => d.kind === 'videoinput');
                console.log(`üìπ Found ${state.availableCameras.length} cameras`);
                populateCameraSelects();
            } catch (err) {
                console.error('Camera enum failed:', err);
            }
        }
        
        function populateCameraSelects() {
            ['main', 'closeup', 'handheld', 'barcode'].forEach(mode => {
                const sel = document.getElementById(`camera-${mode}`);
                sel.innerHTML = '<option value="">Select camera...</option>';
                state.availableCameras.forEach((cam, i) => {
                    const opt = document.createElement('option');
                    opt.value = cam.deviceId;
                    opt.textContent = cam.label || `Camera ${i + 1}`;
                    if (cam.deviceId === state.cameras[mode].deviceId) opt.selected = true;
                    sel.appendChild(opt);
                });
            });
        }
        
        async function startCamera(mode) {
            const deviceId = state.cameras[mode].deviceId;
            if (!deviceId) {
                document.getElementById('video-placeholder').style.display = 'block';
                return;
            }
            if (state.currentStream) state.currentStream.getTracks().forEach(t => t.stop());
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { deviceId: { exact: deviceId }, width: { ideal: 4096 }, height: { ideal: 2160 } }
                });
                state.currentStream = stream;
                document.getElementById('video-preview').srcObject = stream;
                document.getElementById('video-placeholder').style.display = 'none';
                const settings = stream.getVideoTracks()[0].getSettings();
                document.getElementById('resolution-badge').textContent = `${settings.width}√ó${settings.height}`;
                const cam = state.availableCameras.find(c => c.deviceId === deviceId);
                document.getElementById('camera-name').textContent = cam?.label || 'Camera';
                console.log(`üìπ Started ${mode}: ${settings.width}√ó${settings.height}`);
            } catch (err) {
                console.error('Start camera failed:', err);
            }
        }
        
        function switchCameraMode(mode) {
            const prevMode = state.currentMode;
            state.currentMode = mode;
            document.querySelectorAll('.camera-tab').forEach(t => t.classList.toggle('active', t.dataset.mode === mode));
            startCamera(mode);
            updatePhotoCount();
            
            // Track timing
            if (mode === 'closeup' && prevMode === 'main' && state.currentSKU) {
                state.timing.closeupStart = Date.now();
            }
            
            // Trigger AI when switching to closeup (after taking main photos)
            if (prevMode === 'main' && mode === 'closeup' && !state.aiTriggered && state.photos.main.length > 0) {
                triggerAI();
            }
        }
        
        // =====================================================================
        // PHOTO CAPTURE
        // =====================================================================
        function capturePhoto() {
            if (!state.currentStream) {
                showToast('warning', 'No camera active');
                return;
            }
            if (!state.currentSKU) {
                showToast('warning', 'Start an item first');
                return;
            }
            
            const video = document.getElementById('video-preview');
            const canvas = document.getElementById('capture-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0);
            
            const flash = document.getElementById('capture-flash');
            flash.classList.add('active');
            setTimeout(() => flash.classList.remove('active'), 100);
            
            canvas.toBlob(blob => {
                const photo = { blob, mode: state.currentMode, timestamp: Date.now() };
                state.photos[state.currentMode].push(photo);
                updatePhotoGrid();
                updatePhotoCount();
                console.log(`üì∑ Captured ${state.currentMode} #${state.photos[state.currentMode].length}`);
                showToast('success', 'Photo captured');
            }, 'image/jpeg', 0.92);
        }
        
        function updatePhotoCount() {
            const total = state.photos.main.length + state.photos.closeup.length + state.photos.handheld.length;
            document.getElementById('photo-count').textContent = total;
            document.getElementById('mode-photo-count').textContent = state.photos[state.currentMode].length;
        }
        
        function updatePhotoGrid() {
            const grid = document.getElementById('photo-grid');
            const all = [...state.photos.main, ...state.photos.closeup, ...state.photos.handheld];
            grid.innerHTML = all.map((p, i) => `
                <div class="photo-thumb">
                    <img src="${URL.createObjectURL(p.blob)}">
                    <div class="photo-thumb-label">${p.label || p.mode}</div>
                    <button class="photo-thumb-delete" onclick="deletePhoto(${i})">√ó</button>
                </div>
            `).join('');
        }
        
        function deletePhoto(idx) {
            let count = 0;
            for (const mode of ['main', 'closeup', 'handheld']) {
                if (idx < count + state.photos[mode].length) {
                    state.photos[mode].splice(idx - count, 1);
                    break;
                }
                count += state.photos[mode].length;
            }
            updatePhotoGrid();
            updatePhotoCount();
        }
        
        // =====================================================================
        // AI CLASSIFICATION
        // =====================================================================
        async function triggerAI() {
            if (state.photos.main.length === 0) return;
            state.aiTriggered = true;
            document.getElementById('ai-overlay').classList.add('active');
            
            try {
                console.log(`ü§ñ AI: ${state.photos.main.length} photos`);
                const mainPhotos = await Promise.all(state.photos.main.slice(0, 4).map(p => resizeImageForAI(p.blob)));
                let tagPhoto = null;
                if (state.photos.closeup.length > 0) tagPhoto = await resizeImageForAI(state.photos.closeup[0].blob);
                
                const result = await callLambda('classify', { mainPhotos, tagPhoto });
                if (result.success) {
                    state.classification = result.category;
                    state.templateKey = result.templateKey;
                    state.template = result.template;
                    state.tagData = result.tagData;
                    
                    // Update photo labels from AI
                    if (result.photoLabels) {
                        state.photos.main.forEach((p, i) => {
                            if (result.photoLabels[i]) p.label = result.photoLabels[i];
                        });
                    }
                    
                    updateClassificationDisplay();
                    updatePhotoGrid();
                    updateMeasurementList();
                    console.log(`‚úÖ Classified: ${result.category}`);
                    showToast('success', `Classified: ${result.category}`);
                } else {
                    throw new Error(result.error || 'Classification failed');
                }
            } catch (err) {
                console.error('AI error:', err);
                showToast('error', 'AI failed: ' + err.message);
            } finally {
                document.getElementById('ai-overlay').classList.remove('active');
            }
        }
        
        async function resizeImageForAI(blob) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.getElementById('resize-canvas');
                    const ctx = canvas.getContext('2d');
                    let w = img.width, h = img.height;
                    if (w > AI_IMAGE_MAX_SIZE || h > AI_IMAGE_MAX_SIZE) {
                        if (w > h) { h = Math.round(h * AI_IMAGE_MAX_SIZE / w); w = AI_IMAGE_MAX_SIZE; }
                        else { w = Math.round(w * AI_IMAGE_MAX_SIZE / h); h = AI_IMAGE_MAX_SIZE; }
                    }
                    canvas.width = w;
                    canvas.height = h;
                    ctx.drawImage(img, 0, 0, w, h);
                    resolve(canvas.toDataURL('image/jpeg', 0.8).split(',')[1]);
                };
                img.src = URL.createObjectURL(blob);
            });
        }
        
        function updateClassificationDisplay() {
            document.getElementById('classification-box').classList.add('ready');
            document.getElementById('classification-category').textContent = state.classification || 'Unknown';
            document.getElementById('classification-template').textContent = `${state.template?.name || '-'} (${state.template?.count || 0})`;
            if (state.tagData && !state.tagData.error) {
                document.getElementById('tag-grid').style.display = 'grid';
                document.getElementById('tag-brand').textContent = state.tagData.brand || '-';
                document.getElementById('tag-size').textContent = state.tagData.size || '-';
                document.getElementById('tag-materials').textContent = state.tagData.materials || '-';
                document.getElementById('tag-country').textContent = state.tagData.country || '-';
            }
        }
        
        function updateMeasurementList() {
            const list = document.getElementById('measurement-list');
            if (!state.template?.measurements) {
                list.innerHTML = '<div style="color: var(--text-secondary); font-size: 12px; text-align: center;">Classify first</div>';
                return;
            }
            list.innerHTML = state.template.measurements.map((m, i) => `
                <div class="measurement-item" data-idx="${i}">
                    <span class="measurement-num">${i + 1}</span>
                    <span class="measurement-name">${m}</span>
                    <span class="measurement-value" id="mv-${i}">-</span>
                </div>
            `).join('');
            document.getElementById('complete-btn-camera').disabled = false;
            
            // Track measurements start time
            state.timing.measurementsStart = Date.now();
        }
        
        // =====================================================================
        // VOICE RECORDING - v2.9.4 UPDATED
        // - Button now shows "üõë TAP TO STOP" when recording (clear and unmistakable)
        // - Discarded recordings are saved for QC
        // - Recording duration tracked for KPIs
        // =====================================================================
        async function toggleRecording() {
            if (state.isRecording) stopRecording();
            else startRecording();
        }
        
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                state.mediaRecorder = new MediaRecorder(stream);
                state.audioChunks = [];
                state.recordingStartTime = Date.now(); // Track duration
                
                state.mediaRecorder.ondataavailable = e => state.audioChunks.push(e.data);
                state.mediaRecorder.onstop = async () => {
                    const recordingDuration = (Date.now() - state.recordingStartTime) / 1000;
                    const blob = new Blob(state.audioChunks, { type: 'audio/webm' });
                    
                    // If there was a previous recording, save it as discarded
                    if (state.audioBlob) {
                        state.discardedRecordings.push({
                            blob: state.audioBlob,
                            duration: state.lastRecordingDuration || 0,
                            timestamp: new Date().toISOString()
                        });
                        console.log(`üìº Previous recording saved as discarded (${state.discardedRecordings.length} total)`);
                    }
                    
                    state.audioBlob = blob;
                    state.lastRecordingDuration = recordingDuration;
                    stream.getTracks().forEach(t => t.stop());
                    await transcribeAudio(blob);
                };
                
                state.mediaRecorder.start();
                state.isRecording = true;
                
                // v2.9.4: Clear button text change to "TAP TO STOP"
                const btn = document.getElementById('record-btn');
                btn.classList.remove('btn-record');
                btn.classList.add('btn-stop');
                btn.textContent = 'üõë TAP TO STOP';
                
            } catch (err) {
                showToast('error', 'Mic access denied');
            }
        }
        
        function stopRecording() {
            if (state.mediaRecorder && state.isRecording) {
                state.mediaRecorder.stop();
                state.isRecording = false;
                
                // v2.9.4: Reset button to "TAP TO RECORD"
                const btn = document.getElementById('record-btn');
                btn.classList.remove('btn-stop');
                btn.classList.add('btn-record');
                btn.textContent = 'üé§ TAP TO RECORD';
            }
        }
        
        async function transcribeAudio(blob) {
            try {
                showToast('info', 'Transcribing...');
                const reader = new FileReader();
                reader.readAsDataURL(blob);
                reader.onloadend = async () => {
                    const base64 = reader.result.split(',')[1];
                    const result = await callLambda('whisper', { audio: base64, filename: 'audio.webm' });
                    if (result.success && result.text) {
                        state.rawTranscript = result.text;
                        console.log('üìù Transcribed:', result.text);
                        
                        // Show transcript
                        document.getElementById('transcript-text').textContent = result.text;
                        document.getElementById('transcript-box').classList.add('visible');
                        
                        parseMeasurements(result.text);
                        showToast('success', 'Transcription done');
                    }
                };
            } catch (err) {
                showToast('error', 'Transcription failed');
            }
        }
        
        function parseMeasurements(text) {
            const regex = /(\d+(?:\.\d+)?)\s*(?:and\s+(?:a\s+)?(?:half|quarter|three[- ]?quarter)s?)?(?:\s*inches?|\s*in|\s*")?/gi;
            const matches = [...text.matchAll(regex)];
            if (!state.template) return;
            
            matches.forEach((m, i) => {
                if (i < state.template.measurements.length) {
                    let val = parseFloat(m[1]);
                    // Handle "and a half", "and a quarter", etc.
                    const fullMatch = m[0].toLowerCase();
                    if (fullMatch.includes('half')) val += 0.5;
                    else if (fullMatch.includes('quarter') && !fullMatch.includes('three')) val += 0.25;
                    else if (fullMatch.includes('three') && fullMatch.includes('quarter')) val += 0.75;
                    
                    const name = state.template.measurements[i];
                    state.measurements[name] = val;
                    const el = document.getElementById(`mv-${i}`);
                    if (el) {
                        el.textContent = `${val}"`;
                        el.closest('.measurement-item').classList.add('completed');
                    }
                }
            });
        }
        
        // =====================================================================
        // FOLDER SAVE - v2.9.4 UPDATED for raw/final structure
        // =====================================================================
        async function chooseSaveFolder() {
            try {
                state.saveDirectoryHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                const display = document.getElementById('folder-display');
                display.textContent = `üìÅ ${state.saveDirectoryHandle.name}`;
                display.classList.add('set');
                showToast('success', `Folder: ${state.saveDirectoryHandle.name}`);
            } catch (err) {
                if (err.name !== 'AbortError') showToast('error', 'Folder selection failed');
            }
        }
        
        async function saveToLocalFolder(itemData) {
            if (!state.saveDirectoryHandle || !itemData.sku) return false;
            try {
                const skuFolder = await state.saveDirectoryHandle.getDirectoryHandle(itemData.sku, { create: true });
                
                // Create ALL folders including new raw/final structure
                const mainFolder = await skuFolder.getDirectoryHandle('main', { create: true });
                const rawFolder = await mainFolder.getDirectoryHandle('raw', { create: true });
                const finalFolder = await mainFolder.getDirectoryHandle('final', { create: true });
                
                // Other folders
                const folders = ['tag', 'defects', 'features', 'weight', 'measurements', 'data'];
                for (const f of folders) {
                    await skuFolder.getDirectoryHandle(f, { create: true });
                }
                
                // Save main photos to raw folder (final folder will be populated by backend processing)
                if (itemData.photos.main.length > 0) {
                    for (let i = 0; i < itemData.photos.main.length; i++) {
                        const photo = itemData.photos.main[i];
                        const filename = `${itemData.sku}_${photo.label || 'main'}_${String(i + 1).padStart(2, '0')}.jpg`;
                        
                        // Save to raw folder
                        const rawHandle = await rawFolder.getFileHandle(filename, { create: true });
                        const rawWritable = await rawHandle.createWritable();
                        await rawWritable.write(photo.blob);
                        await rawWritable.close();
                        
                        // Also save to final for now (backend will replace with processed version)
                        const finalHandle = await finalFolder.getFileHandle(filename, { create: true });
                        const finalWritable = await finalHandle.createWritable();
                        await finalWritable.write(photo.blob);
                        await finalWritable.close();
                    }
                } else {
                    await createNAFile(rawFolder, null, itemData.sku);
                    await createNAFile(finalFolder, null, itemData.sku);
                }
                
                // Save tag photos
                if (itemData.photos.closeup.length > 0) {
                    const tagFolder = await skuFolder.getDirectoryHandle('tag', { create: true });
                    for (let i = 0; i < itemData.photos.closeup.length; i++) {
                        const photo = itemData.photos.closeup[i];
                        const filename = `${itemData.sku}_tag_${String(i + 1).padStart(2, '0')}.jpg`;
                        const fileHandle = await tagFolder.getFileHandle(filename, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(photo.blob);
                        await writable.close();
                    }
                } else {
                    await createNAFile(skuFolder, 'tag', itemData.sku);
                }
                
                // Defects, features - NA for now
                await createNAFile(skuFolder, 'defects', itemData.sku);
                await createNAFile(skuFolder, 'features', itemData.sku);
                
                // Weight from Dymo scale - v2.9.4 UPDATED format
                const weightFolder = await skuFolder.getDirectoryHandle('weight', { create: true });
                if (itemData.weight && itemData.weight.pounds !== null) {
                    const weightContent = `${itemData.sku}\nWeight: ${itemData.weight.display}\nDecimal Pounds: ${itemData.weight.pounds.toFixed(4)}\nSource: Dymo M10 USB Scale\nTimestamp: ${new Date().toISOString()}`;
                    const weightHandle = await weightFolder.getFileHandle(`${itemData.sku}_weight.txt`, { create: true });
                    const weightWritable = await weightHandle.createWritable();
                    await weightWritable.write(weightContent);
                    await weightWritable.close();
                } else {
                    await createNAFile(skuFolder, 'weight', itemData.sku);
                }
                
                // Save measurements folder contents
                const measurementsFolder = await skuFolder.getDirectoryHandle('measurements', { create: true });
                
                // Final audio
                if (itemData.audioBlob) {
                    const audioHandle = await measurementsFolder.getFileHandle(`${itemData.sku}_audio_final.webm`, { create: true });
                    const audioWritable = await audioHandle.createWritable();
                    await audioWritable.write(itemData.audioBlob);
                    await audioWritable.close();
                }
                
                // Discarded recordings - v2.9.4 NEW
                if (itemData.discardedRecordings && itemData.discardedRecordings.length > 0) {
                    for (let i = 0; i < itemData.discardedRecordings.length; i++) {
                        const discarded = itemData.discardedRecordings[i];
                        const discardHandle = await measurementsFolder.getFileHandle(`${itemData.sku}_audio_discard_${String(i + 1).padStart(2, '0')}.webm`, { create: true });
                        const discardWritable = await discardHandle.createWritable();
                        await discardWritable.write(discarded.blob);
                        await discardWritable.close();
                    }
                }
                
                // Raw transcript
                if (itemData.rawTranscript) {
                    const transcriptHandle = await measurementsFolder.getFileHandle(`${itemData.sku}_transcript_raw.txt`, { create: true });
                    const transcriptWritable = await transcriptHandle.createWritable();
                    await transcriptWritable.write(itemData.rawTranscript);
                    await transcriptWritable.close();
                }
                
                // Parsed measurements (clean format for listings)
                if (Object.keys(itemData.measurements).length > 0) {
                    const parsedContent = generateParsedMeasurements(itemData);
                    const parsedHandle = await measurementsFolder.getFileHandle(`${itemData.sku}_measurements_parsed.txt`, { create: true });
                    const parsedWritable = await parsedHandle.createWritable();
                    await parsedWritable.write(parsedContent);
                    await parsedWritable.close();
                }
                
                // Master JSON
                const dataFolder = await skuFolder.getDirectoryHandle('data', { create: true });
                const dataHandle = await dataFolder.getFileHandle(`${itemData.sku}_data.json`, { create: true });
                const dataWritable = await dataHandle.createWritable();
                await dataWritable.write(JSON.stringify(itemData.jsonData, null, 2));
                await dataWritable.close();
                
                return true;
            } catch (err) {
                console.error('Local save error:', err);
                return false;
            }
        }
        
        async function createNAFile(parentFolderOrNull, folderName, sku) {
            let folder;
            if (folderName) {
                folder = await parentFolderOrNull.getDirectoryHandle(folderName, { create: true });
            } else {
                folder = parentFolderOrNull; // Already the folder
            }
            const fileHandle = await folder.getFileHandle(`${sku}_NA.txt`, { create: true });
            const writable = await fileHandle.createWritable();
            await writable.write(`No data for ${sku}`);
            await writable.close();
        }
        
        function generateParsedMeasurements(itemData) {
            let content = `MEASUREMENTS - ${itemData.sku}\n`;
            content += `Category: ${itemData.category || 'Unknown'}\n`;
            content += `Template: ${itemData.template?.name || 'Unknown'}\n`;
            content += `Note: All measurements are FLAT LAY (multiply by 2 for circumference)\n\n`;
            
            for (const [name, value] of Object.entries(itemData.measurements)) {
                content += `‚Ä¢ ${name}: ${value}"\n`;
            }
            
            return content;
        }
        
        // =====================================================================
        // S3 UPLOAD - v2.9.4 UPDATED for raw/final structure
        // =====================================================================
        async function uploadToS3(itemData) {
            const files = [];
            const sku = itemData.sku;
            
            // Main photos - save to both raw and final folders
            for (let i = 0; i < itemData.photos.main.length; i++) {
                const p = itemData.photos.main[i];
                const filename = `${sku}_${p.label || 'main'}_${String(i + 1).padStart(2, '0')}.jpg`;
                
                // Raw folder
                files.push({
                    name: `main/raw/${filename}`,
                    contentType: 'image/jpeg',
                    blob: p.blob
                });
                
                // Final folder (same for now, backend will process)
                files.push({
                    name: `main/final/${filename}`,
                    contentType: 'image/jpeg',
                    blob: p.blob
                });
            }
            if (itemData.photos.main.length === 0) {
                files.push({ name: `main/raw/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No data for ${sku}`]) });
                files.push({ name: `main/final/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No data for ${sku}`]) });
            }
            
            // Tag photos
            for (let i = 0; i < itemData.photos.closeup.length; i++) {
                const p = itemData.photos.closeup[i];
                files.push({
                    name: `tag/${sku}_tag_${String(i + 1).padStart(2, '0')}.jpg`,
                    contentType: 'image/jpeg',
                    blob: p.blob
                });
            }
            if (itemData.photos.closeup.length === 0) {
                files.push({ name: `tag/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No data for ${sku}`]) });
            }
            
            // Defects, features - NA placeholders
            files.push({ name: `defects/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No data for ${sku}`]) });
            files.push({ name: `features/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No data for ${sku}`]) });
            
            // Weight from Dymo scale - v2.9.4 UPDATED format
            if (itemData.weight && itemData.weight.pounds !== null) {
                const weightContent = `${sku}\nWeight: ${itemData.weight.display}\nDecimal Pounds: ${itemData.weight.pounds.toFixed(4)}\nSource: Dymo M10 USB Scale\nTimestamp: ${new Date().toISOString()}`;
                files.push({ name: `weight/${sku}_weight.txt`, contentType: 'text/plain', blob: new Blob([weightContent]) });
            } else {
                files.push({ name: `weight/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No data for ${sku}`]) });
            }
            
            // Measurements folder
            if (itemData.audioBlob) {
                files.push({ name: `measurements/${sku}_audio_final.webm`, contentType: 'audio/webm', blob: itemData.audioBlob });
            }
            
            // Discarded recordings - v2.9.4 NEW
            if (itemData.discardedRecordings && itemData.discardedRecordings.length > 0) {
                for (let i = 0; i < itemData.discardedRecordings.length; i++) {
                    const discarded = itemData.discardedRecordings[i];
                    files.push({
                        name: `measurements/${sku}_audio_discard_${String(i + 1).padStart(2, '0')}.webm`,
                        contentType: 'audio/webm',
                        blob: discarded.blob
                    });
                }
            }
            
            if (itemData.rawTranscript) {
                files.push({ name: `measurements/${sku}_transcript_raw.txt`, contentType: 'text/plain', blob: new Blob([itemData.rawTranscript]) });
            }
            if (Object.keys(itemData.measurements).length > 0) {
                const parsed = generateParsedMeasurements(itemData);
                files.push({ name: `measurements/${sku}_measurements_parsed.txt`, contentType: 'text/plain', blob: new Blob([parsed]) });
            }
            
            // Master JSON
            files.push({ name: `data/${sku}_data.json`, contentType: 'application/json', blob: new Blob([JSON.stringify(itemData.jsonData, null, 2)]) });
            
            // Get presigned URLs
            const presign = await callLambda('presign', {
                sku: sku,
                files: files.map(f => ({ name: f.name, contentType: f.contentType }))
            });
            
            if (!presign.success) throw new Error(presign.error || 'Presign failed');
            
            // Upload all files
            for (const f of files) {
                const url = presign.urls[f.name];
                if (url) {
                    await fetch(url, { method: 'PUT', body: f.blob, headers: { 'Content-Type': f.contentType } });
                }
            }
            
            return true;
        }
        
        // =====================================================================
        // COMPLETE ITEM (ASYNC BACKGROUND) - v2.9.4 UPDATED
        // =====================================================================
        async function completeItem() {
            if (!state.currentSKU) { showToast('warning', 'No SKU'); return; }
            
            // Calculate timing
            const now = Date.now();
            const totalDuration = Math.round((now - state.timerStart) / 1000);
            const mainDuration = state.timing.closeupStart ? Math.round((state.timing.closeupStart - state.timerStart) / 1000) : totalDuration;
            const closeupDuration = state.timing.measurementsStart && state.timing.closeupStart ? Math.round((state.timing.measurementsStart - state.timing.closeupStart) / 1000) : 0;
            const measurementsDuration = state.timing.measurementsStart ? Math.round((now - state.timing.measurementsStart) / 1000) : 0;
            
            // Get weight from Dymo scale - v2.9.4 FIXED format
            const weightData = getCurrentWeight();
            
            // Recording KPI - v2.9.4 NEW
            const recordingDuration = state.lastRecordingDuration || 0;
            const recordingRating = recordingDuration <= 30 ? 'excellent' : recordingDuration <= 60 ? 'good' : 'needs_improvement';
            
            // Build complete item data
            const itemData = {
                sku: state.currentSKU,
                category: state.classification,
                templateKey: state.templateKey,
                template: state.template,
                tagData: state.tagData,
                measurements: state.measurements,
                rawTranscript: state.rawTranscript,
                audioBlob: state.audioBlob,
                discardedRecordings: state.discardedRecordings, // v2.9.4 NEW
                weight: weightData,
                photos: {
                    main: state.photos.main.map(p => ({ blob: p.blob, label: p.label })),
                    closeup: state.photos.closeup.map(p => ({ blob: p.blob, label: p.label })),
                    handheld: state.photos.handheld.map(p => ({ blob: p.blob, label: p.label }))
                },
                timing: {
                    mainPhotosDuration: mainDuration,
                    closeupDuration: closeupDuration,
                    measurementsDuration: measurementsDuration,
                    totalDuration: totalDuration
                },
                jsonData: {
                    sku: state.currentSKU,
                    timestamp: new Date().toISOString(),
                    version: VERSION,
                    category: state.classification,
                    templateKey: state.templateKey,
                    tagData: state.tagData || { brand: 'N/A', size: 'N/A', materials: 'N/A', country: 'N/A' },
                    measurements: state.measurements,
                    rawTranscript: state.rawTranscript,
                    weight: weightData || { pounds: null, display: 'N/A' },
                    // v2.9.4 - Audio recording metadata
                    audioRecordings: {
                        final: {
                            duration: recordingDuration,
                            timestamp: new Date().toISOString()
                        },
                        discarded: state.discardedRecordings.map((d, i) => ({
                            index: i + 1,
                            duration: d.duration,
                            timestamp: d.timestamp
                        })),
                        totalAttempts: state.discardedRecordings.length + 1,
                        kpiTargets: {
                            targetDuration: 60,
                            excellentDuration: 30,
                            actualDuration: recordingDuration,
                            rating: recordingRating
                        }
                    },
                    timing: {
                        mainPhotosDuration: mainDuration,
                        closeupDuration: closeupDuration,
                        measurementsDuration: measurementsDuration,
                        totalDuration: totalDuration
                    },
                    photoCount: {
                        main: state.photos.main.length,
                        tag: state.photos.closeup.length,
                        defects: 0,
                        features: 0,
                        weight: 0
                    },
                    photographerId: state.photographerId, // v2.9.4 placeholder
                    flags: {},
                    fitAnalysis: null,
                    confidence: {}
                }
            };
            
            // Update stats
            state.completedItems++;
            state.totalTime += totalDuration;
            localStorage.setItem('completedItems', state.completedItems);
            localStorage.setItem('totalTime', state.totalTime);
            updateStats();
            
            // IMMEDIATELY reset UI for next item
            showToast('success', `${state.currentSKU} submitted!`);
            stopTimer();
            resetItem();
            
            // Process in background with retry
            processItemInBackground(itemData);
        }
        
        async function processItemInBackground(itemData, retryCount = 0) {
            try {
                // 1. Save to local folder
                if (state.saveDirectoryHandle) {
                    await saveToLocalFolder(itemData);
                    console.log(`‚úÖ ${itemData.sku} saved to local folder`);
                }
                
                // 2. Upload to S3
                await uploadToS3(itemData);
                console.log(`‚úÖ ${itemData.sku} uploaded to S3`);
                
                // 3. Run full pipeline (v2.9.4 - calls new agent architecture)
                try {
                    // Prepare photos for AI
                    const mainPhotos = await Promise.all(
                        itemData.photos.main.slice(0, 2).map(async p => {
                            const reader = new FileReader();
                            return new Promise(resolve => {
                                reader.onload = () => resolve(reader.result.split(',')[1]);
                                reader.readAsDataURL(p.blob);
                            });
                        })
                    );
                    
                    const pipelineResult = await callLambda('fullPipeline', {
                        transcript: itemData.rawTranscript,
                        category: itemData.category,
                        templateKey: itemData.templateKey,
                        tagData: itemData.tagData,
                        weightData: itemData.weight,
                        photos: mainPhotos
                    });
                    
                    if (pipelineResult.success) {
                        // Update JSON with pipeline results
                        itemData.jsonData.pipelineResults = {
                            parser: pipelineResult.parser,
                            matcher: pipelineResult.matcher,
                            underwriter: pipelineResult.underwriter
                        };
                        itemData.jsonData.aiProviders = pipelineResult.aiProviders;
                        itemData.jsonData.processingTime = pipelineResult.processingTime;
                        
                        // If underwriter corrected classification, note it
                        if (pipelineResult.underwriter?.finalClassification?.wasChanged) {
                            itemData.jsonData.classification = {
                                final: pipelineResult.underwriter.finalClassification.category,
                                finalTemplate: pipelineResult.underwriter.finalClassification.templateKey,
                                original: itemData.category,
                                wasChanged: true,
                                changeReason: pipelineResult.underwriter.finalClassification.changeReason
                            };
                        }
                        
                        // Era estimation
                        if (pipelineResult.underwriter?.eraEstimation) {
                            itemData.jsonData.eraEstimation = pipelineResult.underwriter.eraEstimation;
                        }
                        
                        // QC flags
                        if (pipelineResult.underwriter?.qcFlags) {
                            itemData.jsonData.qcFlags = pipelineResult.underwriter.qcFlags;
                        }
                        
                        console.log(`‚úÖ ${itemData.sku} pipeline complete`);
                    }
                } catch (e) {
                    console.warn('Pipeline failed (non-fatal):', e.message);
                    // Add flag that pipeline failed
                    itemData.jsonData.qcFlags = itemData.jsonData.qcFlags || {};
                    itemData.jsonData.qcFlags.pipelineFailed = true;
                    itemData.jsonData.qcFlags.pipelineError = e.message;
                }
                
                // 4. Send to n8n
                await callLambda('n8n', { formData: itemData.jsonData });
                console.log(`‚úÖ ${itemData.sku} sent to n8n`);
                
            } catch (err) {
                console.error(`‚ùå Background process failed for ${itemData.sku}:`, err);
                
                if (retryCount < MAX_RETRIES) {
                    console.log(`‚Üª Retry ${retryCount + 1}/${MAX_RETRIES} in ${RETRY_DELAY/1000}s...`);
                    setTimeout(() => processItemInBackground(itemData, retryCount + 1), RETRY_DELAY);
                } else {
                    // Add to retry queue
                    showToast('warning', `‚ö†Ô∏è ${itemData.sku} upload incomplete - queued for retry`);
                    addToRetryQueue(itemData);
                }
            }
        }
        
        function addToRetryQueue(itemData) {
            // Store minimal data (can't store blobs in localStorage)
            const queueItem = {
                sku: itemData.sku,
                jsonData: itemData.jsonData,
                timestamp: Date.now()
            };
            state.retryQueue.push(queueItem);
            localStorage.setItem('retryQueue', JSON.stringify(state.retryQueue));
            updateRetryBadge();
        }
        
        function updateRetryBadge() {
            const badge = document.getElementById('retry-badge');
            if (state.retryQueue.length > 0) {
                badge.textContent = `‚ö†Ô∏è ${state.retryQueue.length} pending`;
                badge.classList.add('visible');
            } else {
                badge.classList.remove('visible');
            }
        }
        
        async function processRetryQueue() {
            if (state.retryQueue.length === 0) return;
            
            const toRetry = [...state.retryQueue];
            state.retryQueue = [];
            
            for (const item of toRetry) {
                try {
                    await callLambda('n8n', { formData: item.jsonData });
                    console.log(`‚úÖ Retry success: ${item.sku}`);
                } catch (e) {
                    state.retryQueue.push(item);
                }
            }
            
            localStorage.setItem('retryQueue', JSON.stringify(state.retryQueue));
            updateRetryBadge();
        }
        
        // =====================================================================
        // SKU & TIMER
        // =====================================================================
        function startNewItem() {
            const sku = document.getElementById('sku-input').value.trim().toUpperCase();
            if (!sku) { showToast('warning', 'Enter a SKU'); return; }
            
            state.currentSKU = sku;
            state.photos = { main: [], closeup: [], handheld: [] };
            state.classification = null;
            state.templateKey = null;
            state.template = null;
            state.tagData = null;
            state.measurements = {};
            state.rawTranscript = '';
            state.audioBlob = null;
            state.aiTriggered = false;
            state.timing = { mainStart: Date.now(), closeupStart: null, measurementsStart: null };
            state.discardedRecordings = []; // v2.9.4 reset
            state.lastRecordingDuration = 0;
            
            document.getElementById('sku-row').style.display = 'none';
            document.getElementById('sku-display').textContent = sku;
            document.getElementById('sku-display').classList.add('visible');
            
            document.getElementById('classification-box').classList.remove('ready');
            document.getElementById('classification-category').textContent = 'Waiting...';
            document.getElementById('classification-template').textContent = '-';
            document.getElementById('tag-grid').style.display = 'none';
            document.getElementById('measurement-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 12px; text-align: center;">Classify first</div>';
            document.getElementById('transcript-box').classList.remove('visible');
            document.getElementById('complete-btn-camera').disabled = true;
            
            updatePhotoGrid();
            updatePhotoCount();
            startTimer();
            switchCameraMode('main');
            showToast('success', `Started: ${sku}`);
        }
        
        function cancelItem() {
            if (!confirm(`Cancel item ${state.currentSKU}?`)) return;
            resetItem();
            showToast('info', 'Item cancelled');
        }
        
        function resetItem() {
            state.currentSKU = '';
            state.photos = { main: [], closeup: [], handheld: [] };
            state.classification = null;
            state.templateKey = null;
            state.template = null;
            state.tagData = null;
            state.measurements = {};
            state.rawTranscript = '';
            state.audioBlob = null;
            state.aiTriggered = false;
            state.timing = { mainStart: null, closeupStart: null, measurementsStart: null };
            state.discardedRecordings = []; // v2.9.4 reset
            state.lastRecordingDuration = 0;
            
            document.getElementById('sku-input').value = '';
            document.getElementById('sku-row').style.display = 'flex';
            document.getElementById('sku-display').classList.remove('visible');
            
            document.getElementById('classification-box').classList.remove('ready');
            document.getElementById('classification-category').textContent = 'Waiting...';
            document.getElementById('classification-template').textContent = '-';
            document.getElementById('tag-grid').style.display = 'none';
            document.getElementById('measurement-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 12px; text-align: center;">Classify first</div>';
            document.getElementById('transcript-box').classList.remove('visible');
            document.getElementById('complete-btn-camera').disabled = true;
            
            // Reset recording button state
            const btn = document.getElementById('record-btn');
            btn.classList.remove('btn-stop');
            btn.classList.add('btn-record');
            btn.textContent = 'üé§ TAP TO RECORD';
            
            updatePhotoGrid();
            updatePhotoCount();
            stopTimer();
            document.getElementById('timer').textContent = '0:00';
        }
        
        function startTimer() {
            stopTimer();
            state.timerStart = Date.now();
            state.timerInterval = setInterval(() => {
                const s = Math.floor((Date.now() - state.timerStart) / 1000);
                document.getElementById('timer').textContent = `${Math.floor(s / 60)}:${String(s % 60).padStart(2, '0')}`;
            }, 1000);
        }
        
        function stopTimer() {
            if (state.timerInterval) clearInterval(state.timerInterval);
        }
        
        function updateStats() {
            document.getElementById('item-count').textContent = state.completedItems;
            if (state.completedItems > 0) {
                const avg = Math.round(state.totalTime / state.completedItems);
                document.getElementById('avg-time').textContent = `${Math.floor(avg / 60)}:${String(avg % 60).padStart(2, '0')}`;
            }
        }
        
        // =====================================================================
        // BARCODE SCANNER (with debounce to prevent rapid-fire detection)
        // =====================================================================
        let barcodeDetected = false;
        
        function openBarcodeScanner() {
            barcodeDetected = false;
            document.getElementById('barcode-modal').classList.add('active');
            document.getElementById('barcode-status').textContent = 'Starting...';
            document.getElementById('barcode-status').classList.remove('success');
            
            const deviceId = state.cameras.barcode.deviceId || state.availableCameras[0]?.deviceId;
            
            Quagga.init({
                inputStream: {
                    type: 'LiveStream',
                    target: document.getElementById('barcode-container'),
                    constraints: { deviceId: deviceId ? { exact: deviceId } : undefined, facingMode: 'environment' },
                    willReadFrequently: true
                },
                decoder: { readers: ['code_128_reader', 'ean_reader', 'ean_8_reader', 'upc_reader', 'upc_e_reader'] },
                locate: true,
                frequency: 10
            }, err => {
                if (err) {
                    document.getElementById('barcode-status').textContent = 'Scanner error';
                    console.error('Quagga init error:', err);
                    return;
                }
                document.getElementById('barcode-status').textContent = 'Point at barcode...';
                Quagga.start();
                Quagga.onDetected(result => {
                    if (barcodeDetected) return;
                    barcodeDetected = true;
                    Quagga.stop();
                    
                    const code = result.codeResult.code;
                    console.log('üìä Barcode detected:', code);
                    document.getElementById('barcode-status').textContent = code;
                    document.getElementById('barcode-status').classList.add('success');
                    document.getElementById('sku-input').value = code;
                    
                    setTimeout(() => { 
                        closeBarcodeScanner(); 
                        showToast('success', `Scanned: ${code}`); 
                    }, 500);
                });
            });
        }
        
        function closeBarcodeScanner() {
            barcodeDetected = false;
            try { Quagga.stop(); Quagga.offDetected(); } catch {}
            document.getElementById('barcode-modal').classList.remove('active');
        }
        
        // =====================================================================
        // SETTINGS
        // =====================================================================
        function openSettings() { document.getElementById('settings-modal').classList.add('active'); }
        function closeSettings() { document.getElementById('settings-modal').classList.remove('active'); }
        
        function saveSettings() {
            ['main', 'closeup', 'handheld', 'barcode'].forEach(mode => {
                const sel = document.getElementById(`camera-${mode}`);
                state.cameras[mode].deviceId = sel.value;
                localStorage.setItem(`camera-${mode}`, sel.value);
            });
            const url = document.getElementById('lambda-url').value.trim();
            if (url) { state.lambdaUrl = url; localStorage.setItem('lambdaUrl', url); }
            closeSettings();
            showToast('success', 'Settings saved');
            startCamera(state.currentMode);
            checkLambda();
        }
        
        // =====================================================================
        // DYMO USB SCALE (WebHID) - v2.9.4 FIXED for M10 lb:oz format
        // 
        // The Dymo M10 displays weight as "1:13.0" meaning 1 lb 13 oz
        // Previous code was misinterpreting the byte format, leading to 1e+35 errors
        // This fix properly parses the compound lb:oz format
        // =====================================================================
        const DYMO_VENDOR_ID = 0x0922;
        
        async function toggleScale() {
            if (state.scaleDevice) {
                await disconnectScale();
            } else {
                await connectScale();
            }
        }
        
        async function connectScale() {
            if (!('hid' in navigator)) {
                showToast('error', 'WebHID not supported in this browser');
                return;
            }
            
            try {
                const devices = await navigator.hid.requestDevice({
                    filters: [{ vendorId: DYMO_VENDOR_ID }]
                });
                
                if (devices.length === 0) {
                    showToast('warning', 'No scale selected');
                    return;
                }
                
                state.scaleDevice = devices[0];
                
                if (!state.scaleDevice.opened) {
                    await state.scaleDevice.open();
                }
                
                console.log('‚öñÔ∏è Scale connected:', state.scaleDevice.productName);
                
                state.scaleDevice.addEventListener('inputreport', handleScaleReport);
                
                state.scaleStatus = 'connected';
                updateScaleUI();
                showToast('success', `Scale connected: ${state.scaleDevice.productName}`);
                
            } catch (err) {
                console.error('Scale connection error:', err);
                if (err.name !== 'NotFoundError') {
                    showToast('error', 'Scale connection failed: ' + err.message);
                }
            }
        }
        
        async function disconnectScale() {
            if (state.scaleDevice) {
                try {
                    state.scaleDevice.removeEventListener('inputreport', handleScaleReport);
                    await state.scaleDevice.close();
                } catch (e) {
                    console.warn('Scale disconnect warning:', e);
                }
                state.scaleDevice = null;
                state.scaleWeight = null;
                state.scaleWeightDisplay = '';
                state.scaleStatus = 'disconnected';
                updateScaleUI();
                showToast('info', 'Scale disconnected');
            }
        }
        
        // v2.9.4 FIXED - Proper parsing for Dymo M10 lb:oz format
        function handleScaleReport(event) {
            const data = new Uint8Array(event.data.buffer);
            
            // Dymo M10 HID report format:
            // Byte 0: Report ID
            // Byte 1: Status (2=stable, 4=in motion, 5=fault)
            // Byte 2: Unit (2=grams, 11=ounces, 12=pounds)
            // Byte 3: Scale factor (signed byte, power of 10)
            // Byte 4-5: Weight (little-endian 16-bit)
            
            const status = data[1];
            const unitCode = data[2];
            const scaleFactor = data[3] > 127 ? data[3] - 256 : data[3]; // Convert to signed
            const weightRaw = data[4] | (data[5] << 8); // Little-endian
            
            // Dymo M10 in lb:oz mode (unitCode 12):
            // It reports total ounces, and scaleFactor determines decimal position
            // Example: 1 lb 13 oz = 29 oz total
            // weightRaw might be 290 with scaleFactor = -1 ‚Üí 29.0 oz
            
            let decimalPounds = null;
            let displayWeight = '';
            let unit = 'lb';
            
            if (unitCode === 12) {
                // Pounds mode - but M10 actually reports in ounces internally
                // Check if the value seems like total ounces or decimal pounds
                
                // Apply scale factor to get raw value
                const rawValue = weightRaw * Math.pow(10, scaleFactor);
                
                // M10 in lb:oz display mode reports total ounces
                // A typical shirt weighs 0.5-3 lbs = 8-48 oz
                // If rawValue > 100 and < 500, it's probably total ounces (10ths)
                // If rawValue is huge (like 1e35), the scale factor is wrong
                
                if (rawValue > 1000 || rawValue < 0) {
                    // Invalid reading - scale factor interpretation error
                    // Try treating byte 4-5 differently
                    
                    // Alternative: M10 might report pounds in byte 4, ounces in byte 5
                    const pounds = data[4];
                    const ounces = data[5] / 10; // Tenths of ounces
                    
                    if (pounds < 20 && ounces < 16) {
                        // This looks like valid lb:oz format
                        decimalPounds = pounds + (ounces / 16);
                        displayWeight = `${pounds} lb ${ounces.toFixed(0)} oz`;
                    } else {
                        // Still invalid, try another interpretation
                        // Sometimes it's just tenths of ounces total
                        const totalOunces = weightRaw / 10;
                        if (totalOunces > 0 && totalOunces < 500) {
                            const lbs = Math.floor(totalOunces / 16);
                            const oz = totalOunces % 16;
                            decimalPounds = totalOunces / 16;
                            displayWeight = `${lbs} lb ${oz.toFixed(0)} oz`;
                        }
                    }
                } else {
                    // Raw value seems reasonable - treat as total ounces / 10
                    const totalOunces = rawValue;
                    if (totalOunces > 0 && totalOunces < 500) {
                        const lbs = Math.floor(totalOunces / 16);
                        const oz = totalOunces % 16;
                        decimalPounds = totalOunces / 16;
                        displayWeight = `${lbs} lb ${oz.toFixed(0)} oz`;
                    } else {
                        // Direct decimal pounds
                        decimalPounds = rawValue;
                        displayWeight = `${rawValue.toFixed(2)} lb`;
                    }
                }
                
                unit = 'lb';
                
            } else if (unitCode === 11) {
                // Pure ounces mode
                const ounces = weightRaw * Math.pow(10, scaleFactor);
                decimalPounds = ounces / 16;
                const lbs = Math.floor(decimalPounds);
                const remainingOz = ounces - (lbs * 16);
                displayWeight = `${lbs} lb ${remainingOz.toFixed(0)} oz`;
                unit = 'lb';
                
            } else if (unitCode === 2) {
                // Grams mode
                const grams = weightRaw * Math.pow(10, scaleFactor);
                decimalPounds = grams / 453.592;
                displayWeight = `${grams.toFixed(0)} g`;
                unit = 'g';
            }
            
            // Sanity check - reject obviously wrong values
            if (decimalPounds !== null && (decimalPounds < 0 || decimalPounds > 50)) {
                console.warn('‚öñÔ∏è Suspicious weight reading:', decimalPounds, 'raw:', data);
                // Try the simple interpretation: byte4 = lbs, byte5 = tenths of oz
                const simpleLbs = data[4];
                const simpleOz = data[5] / 10;
                if (simpleLbs >= 0 && simpleLbs < 20 && simpleOz >= 0 && simpleOz < 16) {
                    decimalPounds = simpleLbs + (simpleOz / 16);
                    displayWeight = `${simpleLbs} lb ${simpleOz.toFixed(0)} oz`;
                }
            }
            
            // Update state
            state.scaleWeight = decimalPounds;
            state.scaleWeightDisplay = displayWeight;
            state.scaleUnit = unit;
            
            // Status interpretation
            if (status === 2 || status === 0) {
                state.scaleStatus = 'stable';
            } else if (status === 4) {
                state.scaleStatus = 'reading';
            } else {
                state.scaleStatus = 'connected';
            }
            
            updateScaleUI();
        }
        
        function updateScaleUI() {
            const display = document.getElementById('scale-display');
            const weightEl = document.getElementById('scale-weight');
            const unitEl = document.getElementById('scale-unit');
            const btn = document.getElementById('scale-btn');
            
            if (state.scaleDevice) {
                display.classList.remove('disconnected');
                display.classList.add('connected');
                btn.textContent = 'Disconnect';
                btn.classList.add('disconnect');
                
                if (state.scaleWeightDisplay) {
                    // v2.9.4: Show formatted lb:oz display
                    weightEl.textContent = state.scaleWeightDisplay;
                    weightEl.classList.remove('waiting');
                    unitEl.textContent = ''; // Unit already in display
                } else if (state.scaleWeight !== null) {
                    weightEl.textContent = state.scaleWeight.toFixed(2);
                    weightEl.classList.remove('waiting');
                    unitEl.textContent = state.scaleUnit;
                } else {
                    weightEl.textContent = 'Waiting...';
                    weightEl.classList.add('waiting');
                    unitEl.textContent = '';
                }
            } else {
                display.classList.add('disconnected');
                display.classList.remove('connected');
                weightEl.textContent = 'Not connected';
                weightEl.classList.add('waiting');
                unitEl.textContent = '';
                btn.textContent = 'Connect';
                btn.classList.remove('disconnect');
            }
        }
        
        // v2.9.4: Returns weight in both formats
        function getCurrentWeight() {
            if (state.scaleWeight !== null && state.scaleDevice) {
                return {
                    pounds: state.scaleWeight,
                    display: state.scaleWeightDisplay || `${state.scaleWeight.toFixed(2)} lb`,
                    raw: {
                        value: state.scaleWeight,
                        unit: state.scaleUnit
                    },
                    source: 'Dymo M10 USB Scale'
                };
            }
            return null;
        }
        
        // =====================================================================
        // TOAST
        // =====================================================================
        function showToast(type, msg) {
            const c = document.getElementById('toast-container');
            const t = document.createElement('div');
            t.className = `toast ${type}`;
            t.textContent = msg;
            c.appendChild(t);
            setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 300); }, 3000);
        }
        
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>

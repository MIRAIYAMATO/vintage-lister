<!DOCTYPE html>
<!--
    VintageLister v2.9.13 - EBAY TAXONOMY LOOKUP
    
    CHANGELOG:
    v2.9.13 (2026-02-20):
    - IMPROVED: Classification display shows Type + Sleeve Length (e.g. "Hoodie ¬∑ Sleeveless")
    - IMPROVED: Photographer can visually confirm AI got garment type AND sleeve correct
    - ADDED: isCampCollar stored from classify response
    - ADDED: type, sleeveLength, isCampCollar included in jsonData output
    - REQUIRES: Lambda v106.1 with eBay taxonomy lookup (fixes sleeveless hoodie bug)
    
    v2.9.12 (2026-02-12):
    - SECURITY: Lambda requests now require API key (x-api-key header)
    - SECURITY: API key stored in localStorage only - NOT in source code
    - SECURITY: App blocks all operations if API key not configured
    - ADDED: API Key field in Settings modal
    - CHANGED: callLambda() sends x-api-key header with every request
    
    v2.9.11 (2026-02-12):
    - SAFETY: Cannot complete item without measurement recording
    - SAFETY: Cannot complete item without audio notes recording
    - SAFETY: Cannot complete item without weight photo
    - ADDED: Clear toast messages telling photographer exactly what's missing
    
    v2.9.10 (2026-02-12):
    - ADDED: Microphone selection dropdown in Settings modal
    - ADDED: Mic choice saved to localStorage (persists between sessions)
    - ADDED: Available mics enumerated alongside cameras on init
    - CHANGED: Both recorders (measurement + notes) use the selected mic
    
    v2.9.9 (2026-02-12):
    - ADDED: Notes audio recorder on right panel for photographer verbal notes
    - ADDED: notes/ folder in local save and S3 upload
    - ADDED: Notes audio metadata in JSON data (notesAudio object)
    - ADDED: Mutual exclusion - measurement and notes recorders cannot run simultaneously
    - ADDED: Override protection on BOTH recorders - confirm() dialog before re-recording
    - FILE: notes/{SKU}_audio_notes.webm (follows existing naming convention)
    
    v2.9.8 (2026-02-05):
    - SAFETY: Cannot start item without save folder selected
    - SAFETY: Cannot capture photos without save folder selected
    - ADDED: Visual warning when folder not set (red pulse animation)
    - ADDED: Clear error messages guiding user to select folder
    
    v2.9.7 (2026-02-04):
    - FIX: Barcode scanner now checks confidence - only accepts >80% confident scans
    - FIX: Shows confidence % during scanning so user knows scan quality
    - ADDED: Preview modal - double-click video to see full-size freeze frame
    - ADDED: Click any photo thumbnail to view larger in preview modal
    - ADDED: Barcode scanner shows "Low confidence - try again" for bad scans
    
    v2.9.6 (2026-01-30):
    - CRITICAL FIX: AI classification now triggers when entering closeup from ANY mode
    - HIGH FIX: resizeImageForAI() now has error handler
    - FIX: Weight photo status CSS class toggles properly
    - FIX: Object URL memory leak - old URLs now revoked
    - ADDED: Handheld timing tracking
    - ADDED: Full template object in jsonData
    - REMOVED: Dead code
    
    v2.9.5 (2026-01-29):
    - MAJOR: Async architecture - AI processing moved to n8n
    - Weight camera replaces USB scale
    - 4-camera workflow: MAIN, CLOSEUP, WEIGHT, HANDHELD
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VintageLister v2.9.13</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/quagga/0.12.1/quagga.min.js"></script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --accent-blue: #3b82f6;
            --accent-green: #22c55e;
            --accent-yellow: #eab308;
            --accent-orange: #f97316;
            --accent-red: #ef4444;
            --accent-purple: #a855f7;
            --text-primary: #f8fafc;
            --text-secondary: #94a3b8;
            --border-color: #475569;
            --radius: 8px;
        }
        
        html, body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }
        
        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            height: 100vh;
            overflow: hidden;
        }
        
        @media (max-width: 1200px) {
            .app-container { grid-template-columns: 260px 1fr 260px; }
        }
        
        .panel {
            background: var(--bg-primary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .panel-right { border-right: none; border-left: 1px solid var(--border-color); }
        
        .panel-scroll {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }
        
        .header-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 16px;
            background: linear-gradient(135deg, var(--accent-blue), #2563eb);
            flex-shrink: 0;
        }
        
        .timer-section { text-align: left; }
        .timer { font-size: 28px; font-weight: 700; font-family: 'Courier New', monospace; color: white; }
        .timer-label { font-size: 9px; color: rgba(255,255,255,0.7); text-transform: uppercase; }
        
        .stats-section { text-align: center; }
        .stats-row { display: flex; gap: 12px; }
        .stat-item { text-align: center; }
        .stat-value { font-size: 16px; font-weight: 700; color: white; }
        .stat-label { font-size: 8px; color: rgba(255,255,255,0.7); text-transform: uppercase; }
        
        .version-info { text-align: right; }
        .version-badge { font-size: 10px; color: rgba(255,255,255,0.9); background: rgba(0,0,0,0.3); padding: 4px 8px; border-radius: 4px; display: block; margin-bottom: 4px; }
        .retry-badge { font-size: 9px; color: var(--accent-yellow); display: none; }
        .retry-badge.visible { display: block; }
        
        .section-card {
            background: var(--bg-secondary);
            border-radius: var(--radius);
            padding: 12px;
            margin-bottom: 10px;
        }
        
        .section-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        
        .sku-row { display: flex; gap: 6px; margin-bottom: 8px; flex-wrap: nowrap; }
        
        .sku-input {
            flex: 1; min-width: 0; padding: 10px 12px;
            border: 1px solid var(--border-color); border-radius: var(--radius);
            background: var(--bg-tertiary); color: var(--text-primary);
            font-size: 14px; font-weight: 600;
        }
        
        .sku-input:focus { outline: none; border-color: var(--accent-blue); }
        
        .sku-btn {
            padding: 10px 12px; border: none; border-radius: var(--radius);
            font-size: 13px; cursor: pointer; transition: all 0.15s;
            white-space: nowrap; flex-shrink: 0;
        }
        
        .sku-btn-scan { background: var(--accent-purple); color: white; }
        .sku-btn-start { background: var(--accent-green); color: white; font-weight: 600; }
        .sku-btn:hover { filter: brightness(1.1); }
        
        .sku-display {
            display: none; padding: 12px; background: var(--accent-green);
            border-radius: var(--radius); font-size: 18px; font-weight: 700;
            text-align: center; cursor: pointer;
        }
        
        .sku-display.visible { display: block; }
        .sku-display:hover { background: #16a34a; }
        
        .classification-box {
            background: var(--bg-tertiary); border: 1px solid var(--border-color);
            border-radius: var(--radius); padding: 12px;
        }
        
        .classification-box.ready { border-color: var(--accent-green); }
        .classification-category { font-size: 18px; font-weight: 700; color: var(--accent-yellow); }
        /* v2.9.13: Sub-line for type + sleeve detail */
        .classification-detail { font-size: 12px; color: var(--accent-orange); margin-top: 2px; font-weight: 500; }
        .classification-template { font-size: 12px; color: var(--text-secondary); margin-top: 4px; }
        .classification-template span { color: var(--accent-blue); font-weight: 600; }
        
        .tag-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-top: 10px; }
        
        .tag-item { background: var(--bg-secondary); padding: 6px 8px; border-radius: 6px; font-size: 11px; }
        .tag-label { color: var(--text-secondary); font-size: 9px; text-transform: uppercase; }
        .tag-value { font-weight: 600; margin-top: 2px; }
        
        .folder-display {
            padding: 8px 10px; background: var(--bg-tertiary); border-radius: 6px;
            font-size: 11px; margin-bottom: 8px; color: var(--text-secondary); cursor: pointer;
        }
        
        .folder-display.set { color: var(--accent-green); }
        .folder-display.warning { 
            border: 2px solid var(--accent-red); 
            animation: pulse-warning 1s ease-in-out 3;
            color: var(--accent-red);
        }
        @keyframes pulse-warning {
            0%, 100% { background: var(--bg-tertiary); }
            50% { background: rgba(239, 68, 68, 0.3); }
        }
        
        .photo-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
        
        .photo-thumb {
            position: relative; aspect-ratio: 1; border-radius: 6px;
            overflow: hidden; background: var(--bg-tertiary); cursor: pointer;
        }
        
        .photo-thumb:hover { outline: 2px solid var(--accent-blue); }
        .photo-thumb img { width: 100%; height: 100%; object-fit: cover; }
        
        .photo-thumb-label {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: rgba(0,0,0,0.8); padding: 3px;
            font-size: 8px; text-align: center; color: var(--accent-yellow);
        }
        
        .photo-thumb-delete {
            position: absolute; top: 2px; right: 2px;
            width: 18px; height: 18px; border-radius: 50%; border: none;
            background: var(--accent-red); color: white; font-size: 10px;
            cursor: pointer; opacity: 0; transition: opacity 0.2s;
        }
        
        .photo-thumb:hover .photo-thumb-delete { opacity: 1; }
        
        .camera-panel { display: flex; flex-direction: column; overflow: hidden; background: #000; }
        
        .camera-tabs { display: flex; gap: 4px; padding: 8px; background: var(--bg-secondary); flex-shrink: 0; }
        
        .camera-tab {
            flex: 1; padding: 12px 8px; border: none; border-radius: var(--radius);
            font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;
            background: var(--bg-tertiary); color: var(--text-secondary);
        }
        
        .camera-tab:hover { background: var(--bg-primary); color: var(--text-primary); }
        .camera-tab.active { background: var(--accent-blue); color: white; }
        .camera-tab.closeup.active { background: var(--accent-orange); }
        .camera-tab.weight.active { background: var(--accent-green); }
        .camera-tab.handheld.active { background: var(--accent-purple); }
        
        .camera-info {
            display: flex; align-items: center; justify-content: space-between;
            padding: 6px 12px; background: rgba(0,0,0,0.5);
            font-size: 11px; color: var(--text-secondary); flex-shrink: 0;
        }
        
        .camera-name { font-weight: 600; color: var(--text-primary); }
        .resolution-badge { background: var(--bg-secondary); padding: 3px 8px; border-radius: 4px; }
        .photo-count-badge { background: var(--accent-green); color: white; padding: 3px 10px; border-radius: 4px; font-weight: 600; }
        
        .video-container {
            flex: 1; position: relative; display: flex; align-items: center;
            justify-content: center; min-height: 0; cursor: pointer;
        }
        
        .video-container video { width: 100%; height: 100%; object-fit: contain; }
        .video-placeholder { color: var(--text-secondary); text-align: center; padding: 40px; }
        
        .video-hint {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); padding: 4px 10px; border-radius: 4px;
            font-size: 10px; color: var(--text-secondary); pointer-events: none;
            opacity: 0; transition: opacity 0.3s;
        }
        
        .video-container:hover .video-hint { opacity: 1; }
        
        .capture-flash {
            position: absolute; inset: 0; background: white;
            opacity: 0; pointer-events: none; transition: opacity 0.1s;
        }
        
        .capture-flash.active { opacity: 0.7; }
        
        .capture-area {
            display: flex; align-items: center; justify-content: center;
            gap: 20px; padding: 16px; background: var(--bg-secondary); flex-shrink: 0;
        }
        
        .capture-btn {
            width: 70px; height: 70px; border-radius: 50%;
            border: 4px solid var(--text-primary); background: transparent;
            cursor: pointer; transition: all 0.2s; position: relative;
        }
        
        .capture-btn::after {
            content: ''; position: absolute; inset: 5px; border-radius: 50%;
            background: var(--text-primary); transition: all 0.2s;
        }
        
        .capture-btn:hover::after { background: var(--accent-blue); }
        .capture-btn:active { transform: scale(0.95); }
        
        .complete-btn-camera {
            padding: 14px 24px; border: none; border-radius: var(--radius);
            font-size: 14px; font-weight: 600; cursor: pointer;
            background: var(--accent-green); color: white; transition: all 0.2s;
        }
        
        .complete-btn-camera:hover { filter: brightness(1.1); }
        .complete-btn-camera:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .ai-overlay {
            position: absolute; inset: 0; background: rgba(15, 23, 42, 0.9);
            display: flex; flex-direction: column; align-items: center;
            justify-content: center; gap: 12px;
            opacity: 0; visibility: hidden; transition: all 0.3s;
        }
        
        .ai-overlay.active { opacity: 1; visibility: visible; }
        .spinner { width: 36px; height: 36px; border: 3px solid var(--bg-tertiary); border-top-color: var(--accent-blue); border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        .measurement-list { display: flex; flex-direction: column; gap: 6px; }
        
        .measurement-item {
            display: flex; align-items: center; padding: 8px 10px;
            background: var(--bg-tertiary); border-radius: 6px; font-size: 12px;
        }
        
        .measurement-item.completed {
            background: linear-gradient(90deg, rgba(34,197,94,0.2), transparent);
            border-left: 3px solid var(--accent-green);
        }
        
        .measurement-num {
            width: 22px; height: 22px; border-radius: 50%;
            background: var(--bg-secondary); display: flex; align-items: center;
            justify-content: center; font-size: 10px; font-weight: 600;
            margin-right: 8px; flex-shrink: 0;
        }
        
        .measurement-name { flex: 1; }
        .measurement-value { font-weight: 600; color: var(--accent-green); }
        
        .transcript-box {
            background: var(--bg-tertiary); border-radius: 6px; padding: 10px;
            margin-top: 10px; font-size: 11px; color: var(--text-secondary); display: none;
        }
        
        .transcript-box.visible { display: block; }
        .transcript-label { font-weight: 600; color: var(--text-primary); margin-bottom: 4px; }
        .transcript-text { font-style: italic; }
        
        .btn {
            padding: 12px 16px; border: none; border-radius: var(--radius);
            font-size: 13px; font-weight: 600; cursor: pointer;
            transition: all 0.2s; width: 100%; margin-bottom: 8px;
        }
        
        .btn-primary { background: var(--accent-green); color: white; }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); }
        .btn-record { background: var(--accent-red); color: white; }
        .btn-stop { background: #dc2626; color: white; animation: pulse-stop 1s infinite; }
        .btn:hover { filter: brightness(1.1); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        @keyframes pulse-stop { 
            0%, 100% { opacity: 1; box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.7); } 
            50% { opacity: 0.9; box-shadow: 0 0 0 10px rgba(220, 38, 38, 0); } 
        }
        
        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.8);
            display: flex; align-items: center; justify-content: center;
            z-index: 1000; opacity: 0; visibility: hidden; transition: all 0.3s;
        }
        
        .modal-overlay.active { opacity: 1; visibility: visible; }
        
        .modal {
            background: var(--bg-secondary); border-radius: var(--radius);
            width: 90%; max-width: 500px; max-height: 90vh; overflow-y: auto;
        }
        
        .modal-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 14px 16px; border-bottom: 1px solid var(--border-color);
        }
        
        .modal-title { font-size: 16px; font-weight: 600; }
        
        .modal-close {
            width: 30px; height: 30px; border: none; border-radius: 50%;
            background: var(--bg-tertiary); color: var(--text-primary);
            font-size: 16px; cursor: pointer;
        }
        
        .modal-body { padding: 16px; }
        .form-group { margin-bottom: 14px; }
        .form-label { display: block; font-size: 11px; font-weight: 600; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase; }
        
        .form-select, .form-input {
            width: 100%; padding: 10px 12px;
            border: 1px solid var(--border-color); border-radius: var(--radius);
            background: var(--bg-tertiary); color: var(--text-primary); font-size: 13px;
        }
        
        .form-select:focus, .form-input:focus { outline: none; border-color: var(--accent-blue); }
        
        .barcode-container {
            position: relative; background: #000; aspect-ratio: 4/3;
            border-radius: var(--radius); overflow: hidden;
        }
        
        .barcode-container video, .barcode-container canvas { width: 100%; height: 100%; object-fit: cover; }
        
        .barcode-target {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 200px; height: 80px; border: 3px solid var(--accent-yellow); border-radius: 8px;
        }
        
        .barcode-status {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); padding: 8px 16px; border-radius: 6px;
            font-size: 12px; text-align: center;
        }
        
        .barcode-status.success { background: var(--accent-green); }
        .barcode-status.warning { background: var(--accent-yellow); color: black; }
        
        .barcode-confidence {
            position: absolute; top: 10px; right: 10px;
            background: rgba(0,0,0,0.8); padding: 6px 12px; border-radius: 6px; font-size: 11px;
        }
        
        .barcode-confidence.good { color: var(--accent-green); }
        .barcode-confidence.medium { color: var(--accent-yellow); }
        .barcode-confidence.poor { color: var(--accent-red); }
        
        .toast-container {
            position: fixed; top: 20px; right: 20px; z-index: 2000;
            display: flex; flex-direction: column; gap: 8px;
        }
        
        .toast {
            padding: 10px 16px; border-radius: var(--radius);
            font-size: 13px; font-weight: 500; animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        
        .toast.success { background: var(--accent-green); color: white; }
        .toast.error { background: var(--accent-red); color: white; }
        .toast.warning { background: var(--accent-yellow); color: black; }
        .toast.info { background: var(--accent-blue); color: white; }
        
        .weight-photo-status {
            display: flex; align-items: center; gap: 10px; padding: 12px;
            background: var(--bg-tertiary); border-radius: var(--radius);
            border: 1px dashed var(--border-color);
        }
        
        .weight-photo-status.captured {
            border: 1px solid var(--accent-green);
            background: rgba(34, 197, 94, 0.1);
        }
        
        .weight-status-icon { font-size: 20px; }
        .weight-status-text { font-size: 13px; color: var(--text-secondary); }
        
        .preview-modal {
            position: fixed; inset: 0; background: rgba(0, 0, 0, 0.95);
            display: flex; align-items: center; justify-content: center;
            z-index: 3000; opacity: 0; visibility: hidden; transition: all 0.3s; cursor: zoom-out;
        }
        
        .preview-modal.active { opacity: 1; visibility: visible; }
        
        .preview-modal img, .preview-modal canvas {
            max-width: 95vw; max-height: 95vh; object-fit: contain;
            border-radius: 8px; box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }
        
        .preview-close {
            position: absolute; top: 20px; right: 20px;
            width: 50px; height: 50px; border: none; border-radius: 50%;
            background: var(--bg-secondary); color: white; font-size: 24px;
            cursor: pointer; transition: all 0.2s;
        }
        
        .preview-close:hover { background: var(--accent-red); }
        
        .preview-info {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.8); padding: 10px 20px; border-radius: 8px;
            font-size: 14px; color: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="toast-container" id="toast-container"></div>
    
    <div class="app-container">
        <!-- Left Panel -->
        <div class="panel panel-left">
            <div class="header-bar">
                <div class="timer-section">
                    <div class="timer" id="timer">0:00</div>
                    <div class="timer-label">Item Time</div>
                </div>
                <div class="stats-section">
                    <div class="stats-row">
                        <div class="stat-item">
                            <div class="stat-value" id="item-count">0</div>
                            <div class="stat-label">Items</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="avg-time">0:00</div>
                            <div class="stat-label">Avg</div>
                        </div>
                    </div>
                </div>
                <div class="version-info">
                    <span class="version-badge" id="version-badge">v2.9.13</span>
                    <span class="retry-badge" id="retry-badge">‚ö†Ô∏è 0 pending</span>
                </div>
            </div>
            
            <div class="panel-scroll">
                <div class="section-card">
                    <div class="section-title">üè∑Ô∏è Item SKU</div>
                    <div class="sku-row" id="sku-row">
                        <input type="text" class="sku-input" id="sku-input" placeholder="Scan or type SKU...">
                        <button class="sku-btn sku-btn-scan" onclick="openBarcodeScanner()">üì∑</button>
                        <button class="sku-btn sku-btn-start" onclick="startNewItem()">START</button>
                    </div>
                    <div class="sku-display" id="sku-display" onclick="cancelItem()"></div>
                </div>
                
                <div class="section-card">
                    <div class="section-title">ü§ñ AI Classification</div>
                    <div class="classification-box" id="classification-box">
                        <div class="classification-category" id="classification-category">Waiting...</div>
                        <!-- v2.9.13: Type + sleeve detail line -->
                        <div class="classification-detail" id="classification-detail"></div>
                        <div class="classification-template">Template: <span id="classification-template">-</span></div>
                    </div>
                    <div class="tag-grid" id="tag-grid" style="display: none;">
                        <div class="tag-item"><div class="tag-label">Brand</div><div class="tag-value" id="tag-brand">-</div></div>
                        <div class="tag-item"><div class="tag-label">Size</div><div class="tag-value" id="tag-size">-</div></div>
                        <div class="tag-item"><div class="tag-label">Materials</div><div class="tag-value" id="tag-materials">-</div></div>
                        <div class="tag-item"><div class="tag-label">Country</div><div class="tag-value" id="tag-country">-</div></div>
                    </div>
                </div>
                
                <div class="section-card">
                    <div class="section-title">üíæ Save Location</div>
                    <div class="folder-display" id="folder-display" onclick="chooseSaveFolder()">üìÅ Click to choose folder</div>
                </div>
                
                <div class="section-card">
                    <div class="section-title">‚öñÔ∏è Weight Photo</div>
                    <div class="weight-photo-status" id="weight-photo-status">
                        <span class="weight-status-icon">üì∑</span>
                        <span class="weight-status-text" id="weight-status-text">No weight photo</span>
                    </div>
                    <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">
                        Switch to WEIGHT camera to capture scale display
                    </div>
                </div>
                
                <div class="section-card">
                    <div class="section-title">üì∏ Photos (<span id="photo-count">0</span>)</div>
                    <div class="photo-grid" id="photo-grid"></div>
                </div>
                
                <button class="btn btn-secondary" onclick="openSettings()">‚öôÔ∏è Settings</button>
            </div>
        </div>
        
        <!-- Camera Panel -->
        <div class="panel camera-panel">
            <div class="camera-tabs">
                <button class="camera-tab active" data-mode="main" onclick="switchCameraMode('main')">üì∑ MAIN</button>
                <button class="camera-tab closeup" data-mode="closeup" onclick="switchCameraMode('closeup')">üîç CLOSEUP</button>
                <button class="camera-tab weight" data-mode="weight" onclick="switchCameraMode('weight')">‚öñÔ∏è WEIGHT</button>
                <button class="camera-tab handheld" data-mode="handheld" onclick="switchCameraMode('handheld')">üì± HANDHELD</button>
            </div>
            
            <div class="camera-info">
                <span class="camera-name" id="camera-name">No camera</span>
                <span class="resolution-badge" id="resolution-badge">-</span>
                <span class="photo-count-badge"><span id="mode-photo-count">0</span> photos</span>
            </div>
            
            <div class="video-container" ondblclick="openVideoPreview()">
                <video id="video-preview" autoplay playsinline muted></video>
                <div class="video-placeholder" id="video-placeholder">üì∑ Select a camera in Settings</div>
                <div class="capture-flash" id="capture-flash"></div>
                <div class="ai-overlay" id="ai-overlay">
                    <div class="spinner"></div>
                    <div style="font-size: 13px; color: var(--text-secondary);">AI analyzing photos...</div>
                </div>
                <div class="video-hint">Double-click to preview full size</div>
            </div>
            
            <div class="capture-area">
                <button class="capture-btn" id="capture-btn" onclick="capturePhoto()"></button>
                <button class="complete-btn-camera" id="complete-btn-camera" onclick="completeItem()" disabled>‚úÖ COMPLETE</button>
            </div>
        </div>
        
        <!-- Right Panel -->
        <div class="panel panel-right">
            <div class="panel-scroll">
                <div class="section-card">
                    <div class="section-title">üìè Measurements</div>
                    <div class="measurement-list" id="measurement-list">
                        <div style="color: var(--text-secondary); font-size: 12px; text-align: center; padding: 16px;">
                            Classify item first
                        </div>
                    </div>
                    <div class="transcript-box" id="transcript-box">
                        <div class="transcript-label">üìù Transcript:</div>
                        <div class="transcript-text" id="transcript-text"></div>
                    </div>
                </div>
                
                <button class="btn btn-record" id="record-btn" onclick="toggleRecording()">üé§ TAP TO RECORD</button>
                
                <div class="section-card">
                    <div class="section-title">üóíÔ∏è Audio Notes</div>
                    <button class="btn btn-record" id="notes-record-btn" onclick="toggleNotesRecording()">üé§ TAP TO RECORD NOTES</button>
                    <div style="font-size: 10px; color: var(--text-secondary); margin-top: -4px;">
                        Verbal notes on features, condition, or insights
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Barcode Modal -->
    <div class="modal-overlay" id="barcode-modal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">üì∑ Scan Barcode</div>
                <button class="modal-close" onclick="closeBarcodeScanner()">√ó</button>
            </div>
            <div class="modal-body" style="padding: 0;">
                <div class="barcode-container" id="barcode-container">
                    <div class="barcode-target"></div>
                    <div class="barcode-confidence" id="barcode-confidence">--</div>
                    <div class="barcode-status" id="barcode-status">Starting scanner...</div>
                </div>
                <div style="padding: 12px; text-align: center;">
                    <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px;">
                        Hold barcode steady ‚Ä¢ Good lighting helps ‚Ä¢ Min 80% confidence required
                    </div>
                    <button class="btn btn-secondary" onclick="closeBarcodeScanner()">Cancel</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div class="modal-overlay" id="settings-modal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">‚öôÔ∏è Settings</div>
                <button class="modal-close" onclick="closeSettings()">√ó</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label class="form-label">Main Camera</label>
                    <select class="form-select" id="camera-main"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Closeup Camera</label>
                    <select class="form-select" id="camera-closeup"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Weight Camera (above scale)</label>
                    <select class="form-select" id="camera-weight"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Handheld Camera</label>
                    <select class="form-select" id="camera-handheld"></select>
                </div>
                <div class="form-group">
                    <label class="form-label">Barcode Scanner Camera</label>
                    <select class="form-select" id="camera-barcode"></select>
                </div>
                <hr style="border-color: var(--border-color); margin: 16px 0;">
                <div class="form-group">
                    <label class="form-label">üé§ Microphone (Measurements + Notes)</label>
                    <select class="form-select" id="mic-device"></select>
                </div>
                <hr style="border-color: var(--border-color); margin: 16px 0;">
                <div class="form-group">
                    <label class="form-label">Photographer ID</label>
                    <input type="text" class="form-input" id="photographer-id" placeholder="photographer_1" value="photographer_1">
                </div>
                <hr style="border-color: var(--border-color); margin: 16px 0;">
                <div class="form-group">
                    <label class="form-label">Lambda URL</label>
                    <input type="text" class="form-input" id="lambda-url" placeholder="https://...">
                </div>
                <div class="form-group">
                    <label class="form-label">üîê API Key (required)</label>
                    <input type="password" class="form-input" id="api-key" placeholder="Enter API key...">
                    <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">
                        Authenticates requests to Lambda. Get this from your team lead.
                    </div>
                </div>
                <button class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
            </div>
        </div>
    </div>
    
    <!-- Preview Modal -->
    <div class="preview-modal" id="preview-modal" onclick="closePreviewModal(event)">
        <button class="preview-close" onclick="closePreviewModal(event)">√ó</button>
        <canvas id="preview-canvas"></canvas>
        <img id="preview-image" style="display: none;">
        <div class="preview-info" id="preview-info"></div>
    </div>
    
    <canvas id="capture-canvas" style="display: none;"></canvas>
    <canvas id="resize-canvas" style="display: none;"></canvas>
    
    <script>
        // =============================================================================
        // VINTAGELISTER v2.9.13 - EBAY TAXONOMY LOOKUP
        // =============================================================================
        
        const VERSION = '2.9.13';
        const DEFAULT_LAMBDA_URL = 'https://6t5wk2ae23foojyfwmddauorey0pjqji.lambda-url.us-east-2.on.aws/';
        const AI_IMAGE_MAX_SIZE = 1024;
        const MAX_RETRIES = 3;
        const RETRY_DELAY = 5000;
        const BARCODE_MIN_CONFIDENCE = 0.80;
        
        const state = {
            lambdaUrl: localStorage.getItem('lambdaUrl') || DEFAULT_LAMBDA_URL,
            apiKey: localStorage.getItem('vl-api-key') || '',
            lambdaVersion: null,
            currentSKU: '',
            currentMode: 'main',
            currentStream: null,
            cameras: {
                main: { deviceId: localStorage.getItem('camera-main') || null },
                closeup: { deviceId: localStorage.getItem('camera-closeup') || null },
                weight: { deviceId: localStorage.getItem('camera-weight') || null },
                handheld: { deviceId: localStorage.getItem('camera-handheld') || null },
                barcode: { deviceId: localStorage.getItem('camera-barcode') || null }
            },
            availableCameras: [],
            availableMics: [],
            micDeviceId: localStorage.getItem('mic-device') || null,
            photos: { main: [], closeup: [], weight: [], handheld: [] },
            classification: null,
            // v2.9.13: Store detailed classification from Lambda v106.1
            classificationType: null,
            classificationSleeve: null,
            classificationIsCampCollar: false,
            templateKey: null,
            template: null,
            tagData: null,
            measurements: {},
            rawTranscript: '',
            audioBlob: null,
            saveDirectoryHandle: null,
            timerStart: null,
            timerInterval: null,
            isRecording: false,
            mediaRecorder: null,
            audioChunks: [],
            aiTriggered: false,
            timing: {
                itemStartTime: null, classificationTime: null,
                mainPhotosStartTime: null, mainPhotosEndTime: null,
                closeupStartTime: null, closeupEndTime: null,
                weightStartTime: null, weightEndTime: null,
                handheldStartTime: null, handheldEndTime: null,
                measurementsStartTime: null, measurementsEndTime: null,
                completeTime: null
            },
            completedItems: parseInt(localStorage.getItem('completedItems') || '0'),
            totalTime: parseInt(localStorage.getItem('totalTime') || '0'),
            retryQueue: JSON.parse(localStorage.getItem('retryQueue') || '[]'),
            discardedRecordings: [],
            recordingStartTime: null,
            photographerId: localStorage.getItem('photographerId') || 'photographer_1',
            notesAudioBlob: null,
            notesAudioChunks: [],
            isRecordingNotes: false,
            notesMediaRecorder: null,
            notesRecordingStartTime: null,
            lastNotesRecordingDuration: 0,
            discardedNotesRecordings: []
        };
        
        // =====================================================================
        // INIT
        // =====================================================================
        async function init() {
            console.log(`%c VintageLister v${VERSION} `, 'background: #3b82f6; color: white; font-size: 14px;');
            document.getElementById('lambda-url').value = state.lambdaUrl;
            document.getElementById('api-key').value = state.apiKey;
            if (!state.apiKey) {
                showToast('error', 'üîê API KEY REQUIRED - Open Settings to configure');
            }
            updateStats();
            updateRetryBadge();
            await checkLambda();
            await enumerateCameras();
            if (state.cameras.main.deviceId) await startCamera('main');
            
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && !e.target.matches('input, textarea')) { e.preventDefault(); capturePhoto(); }
                if (e.code === 'Escape') { closePreviewModal(); }
            });
            
            processRetryQueue();
            console.log('‚úÖ Init complete - v2.9.13 with eBay taxonomy lookup');
        }
        
        // =====================================================================
        // LAMBDA
        // =====================================================================
        async function checkLambda() {
            try {
                const headers = { 'Content-Type': 'application/json' };
                if (state.apiKey) headers['x-api-key'] = state.apiKey;
                const res = await fetch(state.lambdaUrl, {
                    method: 'POST', headers,
                    body: JSON.stringify({ action: 'diagnostics' })
                });
                const data = await res.json();
                if (data.success) {
                    state.lambdaVersion = data.version;
                    document.getElementById('version-badge').textContent = `v${VERSION} | Œª${data.version}`;
                    console.log(`‚úÖ Lambda v${data.version} healthy`);
                    showToast('success', `Connected to Lambda v${data.version}`);
                }
            } catch (err) {
                console.error('Lambda check failed:', err);
                showToast('error', 'Lambda connection failed');
            }
        }
        
        async function callLambda(action, body = {}) {
            const headers = { 'Content-Type': 'application/json' };
            if (state.apiKey) headers['x-api-key'] = state.apiKey;
            const res = await fetch(state.lambdaUrl, {
                method: 'POST', headers,
                body: JSON.stringify({ action, ...body })
            });
            return res.json();
        }
        
        // =====================================================================
        // CAMERA
        // =====================================================================
        async function enumerateCameras() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                stream.getTracks().forEach(t => t.stop());
                const devices = await navigator.mediaDevices.enumerateDevices();
                state.availableCameras = devices.filter(d => d.kind === 'videoinput');
                state.availableMics = devices.filter(d => d.kind === 'audioinput');
                populateCameraSelects();
            } catch (err) { console.error('Device enum failed:', err); }
        }
        
        function populateCameraSelects() {
            ['main', 'closeup', 'weight', 'handheld', 'barcode'].forEach(mode => {
                const sel = document.getElementById(`camera-${mode}`);
                if (!sel) return;
                sel.innerHTML = '<option value="">Select camera...</option>';
                state.availableCameras.forEach((cam, i) => {
                    const opt = document.createElement('option');
                    opt.value = cam.deviceId;
                    opt.textContent = cam.label || `Camera ${i + 1}`;
                    if (cam.deviceId === state.cameras[mode].deviceId) opt.selected = true;
                    sel.appendChild(opt);
                });
            });
            document.getElementById('photographer-id').value = state.photographerId;
            const micSel = document.getElementById('mic-device');
            if (micSel) {
                micSel.innerHTML = '<option value="">Default microphone</option>';
                state.availableMics.forEach((mic, i) => {
                    const opt = document.createElement('option');
                    opt.value = mic.deviceId;
                    opt.textContent = mic.label || `Microphone ${i + 1}`;
                    if (mic.deviceId === state.micDeviceId) opt.selected = true;
                    micSel.appendChild(opt);
                });
            }
        }
        
        async function startCamera(mode) {
            if (state.currentStream) state.currentStream.getTracks().forEach(t => t.stop());
            const deviceId = state.cameras[mode].deviceId;
            if (!deviceId) {
                document.getElementById('video-placeholder').style.display = 'block';
                document.getElementById('video-preview').style.display = 'none';
                return;
            }
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { deviceId: { exact: deviceId }, width: { ideal: 4096 }, height: { ideal: 2160 } }
                });
                state.currentStream = stream;
                const video = document.getElementById('video-preview');
                video.srcObject = stream;
                video.style.display = 'block';
                document.getElementById('video-placeholder').style.display = 'none';
                const settings = stream.getVideoTracks()[0].getSettings();
                document.getElementById('resolution-badge').textContent = `${settings.width}√ó${settings.height}`;
                const cam = state.availableCameras.find(c => c.deviceId === deviceId);
                document.getElementById('camera-name').textContent = cam?.label || 'Camera';
            } catch (err) { console.error('Start camera failed:', err); }
        }
        
        function switchCameraMode(mode) {
            const prevMode = state.currentMode;
            const now = Date.now();
            if (state.currentSKU) {
                if (prevMode === 'main' && state.timing.mainPhotosStartTime) state.timing.mainPhotosEndTime = now;
                else if (prevMode === 'closeup' && state.timing.closeupStartTime) state.timing.closeupEndTime = now;
                else if (prevMode === 'weight' && state.timing.weightStartTime) state.timing.weightEndTime = now;
                else if (prevMode === 'handheld' && state.timing.handheldStartTime) state.timing.handheldEndTime = now;
            }
            state.currentMode = mode;
            document.querySelectorAll('.camera-tab').forEach(t => t.classList.toggle('active', t.dataset.mode === mode));
            startCamera(mode);
            updatePhotoCount();
            if (state.currentSKU) {
                if (mode === 'closeup' && !state.timing.closeupStartTime) state.timing.closeupStartTime = now;
                else if (mode === 'weight' && !state.timing.weightStartTime) state.timing.weightStartTime = now;
                else if (mode === 'handheld' && !state.timing.handheldStartTime) state.timing.handheldStartTime = now;
            }
            if (mode === 'closeup' && !state.aiTriggered && state.photos.main.length > 0) triggerAI();
        }
        
        // =====================================================================
        // PHOTO CAPTURE
        // =====================================================================
        function capturePhoto() {
            if (!state.saveDirectoryHandle) { showToast('error', '‚ö†Ô∏è SELECT SAVE FOLDER FIRST'); highlightFolderSelector(); return; }
            if (!state.currentStream) { showToast('warning', 'No camera active'); return; }
            if (!state.currentSKU) { showToast('warning', 'Start an item first'); return; }
            
            const video = document.getElementById('video-preview');
            const canvas = document.getElementById('capture-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = video.videoWidth; canvas.height = video.videoHeight;
            ctx.drawImage(video, 0, 0);
            
            const flash = document.getElementById('capture-flash');
            flash.classList.add('active');
            setTimeout(() => flash.classList.remove('active'), 100);
            
            const currentMode = state.currentMode;
            canvas.toBlob(async blob => {
                state.photos[currentMode].push({ blob, mode: currentMode, timestamp: Date.now() });
                updatePhotoGrid(); updatePhotoCount();
                showToast('success', 'Photo captured');
                if (currentMode === 'weight') updateWeightPhotoStatus();
            }, 'image/jpeg', 0.92);
        }
        
        function updateWeightPhotoStatus() {
            const statusText = document.getElementById('weight-status-text');
            const statusContainer = document.getElementById('weight-photo-status');
            const count = state.photos.weight.length;
            if (count > 0) {
                statusText.textContent = `‚úÖ ${count} weight photo${count > 1 ? 's' : ''} captured`;
                statusText.style.color = 'var(--accent-green)';
                statusContainer.classList.add('captured');
            } else {
                statusText.textContent = 'No weight photo';
                statusText.style.color = 'var(--text-secondary)';
                statusContainer.classList.remove('captured');
            }
        }
        
        function updatePhotoCount() {
            const total = state.photos.main.length + state.photos.closeup.length + state.photos.weight.length + state.photos.handheld.length;
            document.getElementById('photo-count').textContent = total;
            document.getElementById('mode-photo-count').textContent = state.photos[state.currentMode].length;
        }
        
        function updatePhotoGrid() {
            const grid = document.getElementById('photo-grid');
            grid.querySelectorAll('img').forEach(img => { if (img.src.startsWith('blob:')) URL.revokeObjectURL(img.src); });
            const all = [...state.photos.main, ...state.photos.closeup, ...state.photos.weight, ...state.photos.handheld];
            grid.innerHTML = all.map((p, i) => `
                <div class="photo-thumb" onclick="openPhotoPreview(${i})">
                    <img src="${URL.createObjectURL(p.blob)}">
                    <div class="photo-thumb-label">${p.label || p.mode}</div>
                    <button class="photo-thumb-delete" onclick="event.stopPropagation(); deletePhoto(${i})">√ó</button>
                </div>
            `).join('');
        }
        
        function deletePhoto(idx) {
            let count = 0;
            for (const mode of ['main', 'closeup', 'weight', 'handheld']) {
                if (idx < count + state.photos[mode].length) {
                    state.photos[mode].splice(idx - count, 1);
                    if (mode === 'weight') updateWeightPhotoStatus();
                    break;
                }
                count += state.photos[mode].length;
            }
            updatePhotoGrid(); updatePhotoCount();
        }
        
        // =====================================================================
        // PREVIEW MODAL
        // =====================================================================
        function openVideoPreview() {
            if (!state.currentStream) return;
            const video = document.getElementById('video-preview');
            const canvas = document.getElementById('preview-canvas');
            document.getElementById('preview-image').style.display = 'none';
            canvas.style.display = 'block';
            canvas.width = video.videoWidth; canvas.height = video.videoHeight;
            canvas.getContext('2d').drawImage(video, 0, 0);
            document.getElementById('preview-info').textContent = `${state.currentMode.toUpperCase()} camera ‚Ä¢ ${video.videoWidth}√ó${video.videoHeight} ‚Ä¢ Click anywhere to close`;
            document.getElementById('preview-modal').classList.add('active');
        }
        
        function openPhotoPreview(idx) {
            const all = [...state.photos.main, ...state.photos.closeup, ...state.photos.weight, ...state.photos.handheld];
            if (idx < 0 || idx >= all.length) return;
            const photo = all[idx];
            document.getElementById('preview-canvas').style.display = 'none';
            const img = document.getElementById('preview-image');
            img.style.display = 'block';
            img.src = URL.createObjectURL(photo.blob);
            document.getElementById('preview-info').textContent = `${(photo.label || photo.mode).toUpperCase()} ‚Ä¢ Photo ${idx + 1} of ${all.length} ‚Ä¢ Click anywhere to close`;
            document.getElementById('preview-modal').classList.add('active');
        }
        
        function closePreviewModal(event) {
            if (!event || event.target.id === 'preview-modal' || event.target.classList.contains('preview-close')) {
                document.getElementById('preview-modal').classList.remove('active');
                const img = document.getElementById('preview-image');
                if (img.src.startsWith('blob:')) { URL.revokeObjectURL(img.src); img.src = ''; }
            }
        }
        
        // =====================================================================
        // AI CLASSIFICATION
        // =====================================================================
        async function triggerAI() {
            if (state.photos.main.length === 0) return;
            state.aiTriggered = true;
            document.getElementById('ai-overlay').classList.add('active');
            
            try {
                const mainPhotos = await Promise.all(state.photos.main.slice(0, 4).map(p => resizeImageForAI(p.blob)));
                let tagPhoto = null;
                if (state.photos.closeup.length > 0) tagPhoto = await resizeImageForAI(state.photos.closeup[0].blob);
                
                const result = await callLambda('classify', { mainPhotos, tagPhoto });
                if (result.success) {
                    state.classification = result.category;
                    // v2.9.13: Store detailed classification from Lambda v106.1
                    state.classificationType = result.type || null;
                    state.classificationSleeve = result.sleeveLength || null;
                    state.classificationIsCampCollar = result.isCampCollar || false;
                    state.templateKey = result.templateKey;
                    state.template = result.template;
                    state.tagData = result.tagData;
                    state.timing.classificationTime = Date.now();
                    
                    if (result.photoLabels) {
                        state.photos.main.forEach((p, i) => { if (result.photoLabels[i]) p.label = result.photoLabels[i]; });
                    }
                    
                    updateClassificationDisplay();
                    updatePhotoGrid();
                    updateMeasurementList();
                    console.log(`‚úÖ Classified: ${result.type} ¬∑ ${result.sleeveLength} ‚Üí ${result.templateKey}`);
                    showToast('success', `Classified: ${result.type || result.category}`);
                } else {
                    throw new Error(result.error || 'Classification failed');
                }
            } catch (err) {
                console.error('AI error:', err);
                showToast('error', 'AI failed: ' + err.message);
            } finally {
                document.getElementById('ai-overlay').classList.remove('active');
            }
        }
        
        async function resizeImageForAI(blob) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const objectUrl = URL.createObjectURL(blob);
                img.onload = () => {
                    const canvas = document.getElementById('resize-canvas');
                    const ctx = canvas.getContext('2d');
                    let w = img.width, h = img.height;
                    if (w > AI_IMAGE_MAX_SIZE || h > AI_IMAGE_MAX_SIZE) {
                        if (w > h) { h = Math.round(h * AI_IMAGE_MAX_SIZE / w); w = AI_IMAGE_MAX_SIZE; }
                        else { w = Math.round(w * AI_IMAGE_MAX_SIZE / h); h = AI_IMAGE_MAX_SIZE; }
                    }
                    canvas.width = w; canvas.height = h;
                    ctx.drawImage(img, 0, 0, w, h);
                    URL.revokeObjectURL(objectUrl);
                    resolve(canvas.toDataURL('image/jpeg', 0.8).split(',')[1]);
                };
                img.onerror = () => { URL.revokeObjectURL(objectUrl); reject(new Error('Failed to load image for resize')); };
                img.src = objectUrl;
            });
        }
        
        function updateClassificationDisplay() {
            document.getElementById('classification-box').classList.add('ready');
            // v2.9.13: Show type as primary, category as context
            const displayType = state.classificationType || state.classification || 'Unknown';
            document.getElementById('classification-category').textContent = displayType;
            
            // v2.9.13: Show sleeve + category detail line
            const parts = [];
            if (state.classificationSleeve && state.classificationSleeve !== 'na') parts.push(state.classificationSleeve);
            if (state.classification && state.classification !== displayType) parts.push(state.classification);
            if (state.classificationIsCampCollar) parts.push('Camp Collar');
            document.getElementById('classification-detail').textContent = parts.join(' ¬∑ ');
            
            document.getElementById('classification-template').textContent = `${state.template?.name || '-'} (${state.template?.count || 0})`;
            if (state.tagData && !state.tagData.error) {
                document.getElementById('tag-grid').style.display = 'grid';
                document.getElementById('tag-brand').textContent = state.tagData.brand || '-';
                document.getElementById('tag-size').textContent = state.tagData.size || '-';
                document.getElementById('tag-materials').textContent = state.tagData.materials || '-';
                document.getElementById('tag-country').textContent = state.tagData.country || '-';
            }
        }
        
        function updateMeasurementList() {
            const list = document.getElementById('measurement-list');
            if (!state.template?.measurements) {
                list.innerHTML = '<div style="color: var(--text-secondary); font-size: 12px; text-align: center;">Classify first</div>';
                return;
            }
            list.innerHTML = state.template.measurements.map((m, i) => `
                <div class="measurement-item" data-idx="${i}">
                    <span class="measurement-num">${i + 1}</span>
                    <span class="measurement-name">${m}</span>
                    <span class="measurement-value" id="mv-${i}">-</span>
                </div>
            `).join('');
            document.getElementById('complete-btn-camera').disabled = false;
            if (!state.timing.measurementsStartTime) state.timing.measurementsStartTime = Date.now();
        }
        
        // =====================================================================
        // VOICE RECORDING
        // =====================================================================
        async function toggleRecording() { if (state.isRecording) stopRecording(); else startRecording(); }
        
        async function startRecording() {
            if (state.isRecordingNotes) { showToast('error', '‚ö†Ô∏è Stop notes recording first'); return; }
            if (state.audioBlob) { if (!confirm('You already have a measurement recording. Re-recording will replace it. Continue?')) return; }
            try {
                const audioConstraints = state.micDeviceId ? { deviceId: { exact: state.micDeviceId } } : true;
                const stream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });
                state.mediaRecorder = new MediaRecorder(stream);
                state.audioChunks = [];
                state.recordingStartTime = Date.now();
                if (!state.timing.measurementsStartTime) state.timing.measurementsStartTime = Date.now();
                state.mediaRecorder.ondataavailable = e => state.audioChunks.push(e.data);
                state.mediaRecorder.onstop = async () => {
                    const recordingDuration = (Date.now() - state.recordingStartTime) / 1000;
                    const blob = new Blob(state.audioChunks, { type: 'audio/webm' });
                    if (state.audioBlob) {
                        state.discardedRecordings.push({ blob: state.audioBlob, duration: state.lastRecordingDuration || 0, timestamp: new Date().toISOString() });
                    }
                    state.audioBlob = blob;
                    state.lastRecordingDuration = recordingDuration;
                    stream.getTracks().forEach(t => t.stop());
                    await transcribeAudio(blob);
                };
                state.mediaRecorder.start();
                state.isRecording = true;
                const btn = document.getElementById('record-btn');
                btn.classList.remove('btn-record'); btn.classList.add('btn-stop');
                btn.textContent = 'üõë TAP TO STOP';
            } catch (err) { showToast('error', 'Mic access denied'); }
        }
        
        function stopRecording() {
            if (state.mediaRecorder && state.isRecording) {
                state.mediaRecorder.stop(); state.isRecording = false;
                state.timing.measurementsEndTime = Date.now();
                const btn = document.getElementById('record-btn');
                btn.classList.remove('btn-stop'); btn.classList.add('btn-record');
                btn.textContent = 'üé§ TAP TO RECORD';
            }
        }
        
        // =====================================================================
        // NOTES AUDIO RECORDING
        // =====================================================================
        async function toggleNotesRecording() { if (state.isRecordingNotes) stopNotesRecording(); else startNotesRecording(); }
        
        async function startNotesRecording() {
            if (state.isRecording) { showToast('error', '‚ö†Ô∏è Stop measurement recording first'); return; }
            if (state.notesAudioBlob) { if (!confirm('You already have a notes recording. Re-recording will replace it. Continue?')) return; }
            try {
                const audioConstraints = state.micDeviceId ? { deviceId: { exact: state.micDeviceId } } : true;
                const stream = await navigator.mediaDevices.getUserMedia({ audio: audioConstraints });
                state.notesMediaRecorder = new MediaRecorder(stream);
                state.notesAudioChunks = [];
                state.notesRecordingStartTime = Date.now();
                state.notesMediaRecorder.ondataavailable = e => state.notesAudioChunks.push(e.data);
                state.notesMediaRecorder.onstop = async () => {
                    const recordingDuration = (Date.now() - state.notesRecordingStartTime) / 1000;
                    const blob = new Blob(state.notesAudioChunks, { type: 'audio/webm' });
                    if (state.notesAudioBlob) {
                        state.discardedNotesRecordings.push({ blob: state.notesAudioBlob, duration: state.lastNotesRecordingDuration || 0, timestamp: new Date().toISOString() });
                    }
                    state.notesAudioBlob = blob;
                    state.lastNotesRecordingDuration = recordingDuration;
                    stream.getTracks().forEach(t => t.stop());
                    showToast('success', `Notes recorded (${Math.round(recordingDuration)}s)`);
                };
                state.notesMediaRecorder.start();
                state.isRecordingNotes = true;
                const btn = document.getElementById('notes-record-btn');
                btn.classList.remove('btn-record'); btn.classList.add('btn-stop');
                btn.textContent = 'üõë TAP TO STOP';
            } catch (err) { showToast('error', 'Mic access denied'); }
        }
        
        function stopNotesRecording() {
            if (state.notesMediaRecorder && state.isRecordingNotes) {
                state.notesMediaRecorder.stop(); state.isRecordingNotes = false;
                const btn = document.getElementById('notes-record-btn');
                btn.classList.remove('btn-stop'); btn.classList.add('btn-record');
                btn.textContent = 'üé§ TAP TO RECORD NOTES';
            }
        }
        
        async function transcribeAudio(blob) {
            try {
                showToast('info', 'Transcribing...');
                const reader = new FileReader();
                reader.readAsDataURL(blob);
                reader.onloadend = async () => {
                    const base64 = reader.result.split(',')[1];
                    const result = await callLambda('whisper', { audio: base64, filename: 'audio.webm' });
                    if (result.success && result.text) {
                        state.rawTranscript = result.text;
                        document.getElementById('transcript-text').textContent = result.text;
                        document.getElementById('transcript-box').classList.add('visible');
                        parseMeasurements(result.text);
                        showToast('success', 'Transcription done');
                    }
                };
            } catch (err) { showToast('error', 'Transcription failed'); }
        }
        
        function parseMeasurements(text) {
            const regex = /(\d+(?:\.\d+)?)\s*(?:and\s+(?:a\s+)?(?:half|quarter|three[- ]?quarter)s?)?(?:\s*inches?|\s*in|\s*")?/gi;
            const matches = [...text.matchAll(regex)];
            if (!state.template) return;
            const extractedValues = matches.map(m => {
                let val = parseFloat(m[1]);
                const fullMatch = m[0].toLowerCase();
                if (fullMatch.includes('half')) val += 0.5;
                else if (fullMatch.includes('quarter') && !fullMatch.includes('three')) val += 0.25;
                else if (fullMatch.includes('three') && fullMatch.includes('quarter')) val += 0.75;
                return val;
            });
            state.template.measurements.forEach((m, i) => {
                const el = document.getElementById(`mv-${i}`);
                const item = document.querySelector(`.measurement-item[data-idx="${i}"]`);
                if (extractedValues[i] !== undefined) {
                    el.textContent = extractedValues[i] + '"';
                    item?.classList.add('completed');
                    state.measurements[m] = extractedValues[i];
                }
            });
        }
        
        // =====================================================================
        // FOLDER SELECTION
        // =====================================================================
        function highlightFolderSelector() {
            const display = document.getElementById('folder-display');
            display.classList.add('warning');
            display.textContent = '‚ö†Ô∏è CLICK TO SELECT FOLDER - REQUIRED';
            display.scrollIntoView({ behavior: 'smooth', block: 'center' });
            setTimeout(() => { if (!state.saveDirectoryHandle) { display.classList.remove('warning'); display.textContent = 'üìÅ Click to choose folder'; } }, 3000);
        }
        
        async function chooseSaveFolder() {
            try {
                state.saveDirectoryHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                const display = document.getElementById('folder-display');
                display.textContent = `üìÇ ${state.saveDirectoryHandle.name}`;
                display.classList.add('set');
                showToast('success', `Folder: ${state.saveDirectoryHandle.name}`);
            } catch (err) { if (err.name !== 'AbortError') showToast('error', 'Folder access denied'); }
        }
        
        // =====================================================================
        // COMPLETE ITEM
        // =====================================================================
        async function completeItem() {
            if (!state.currentSKU) return;
            
            const missing = [];
            if (!state.audioBlob) missing.push('üìè Measurement recording');
            if (!state.notesAudioBlob) missing.push('üóíÔ∏è Audio notes recording');
            if (state.photos.weight.length === 0) missing.push('‚öñÔ∏è Weight photo');
            if (missing.length > 0) {
                missing.forEach(item => showToast('error', `Missing: ${item}`));
                showToast('warning', `Complete these ${missing.length} item${missing.length > 1 ? 's' : ''} before finishing`);
                return;
            }
            
            state.timing.completeTime = Date.now();
            const totalDuration = state.timing.itemStartTime ? Math.round((state.timing.completeTime - state.timing.itemStartTime) / 1000) : 0;
            const mainPhotosDuration = state.timing.mainPhotosEndTime && state.timing.mainPhotosStartTime ? Math.round((state.timing.mainPhotosEndTime - state.timing.mainPhotosStartTime) / 1000) : 0;
            const closeupDuration = state.timing.closeupEndTime && state.timing.closeupStartTime ? Math.round((state.timing.closeupEndTime - state.timing.closeupStartTime) / 1000) : 0;
            const weightDuration = state.timing.weightEndTime && state.timing.weightStartTime ? Math.round((state.timing.weightEndTime - state.timing.weightStartTime) / 1000) : 0;
            const handheldDuration = state.timing.handheldEndTime && state.timing.handheldStartTime ? Math.round((state.timing.handheldEndTime - state.timing.handheldStartTime) / 1000) : 0;
            const measurementsDuration = state.timing.measurementsEndTime && state.timing.measurementsStartTime ? Math.round((state.timing.measurementsEndTime - state.timing.measurementsStartTime) / 1000) : 0;
            const recordingDuration = state.lastRecordingDuration || 0;
            const recordingRating = recordingDuration <= 30 ? 'excellent' : recordingDuration <= 60 ? 'good' : 'needs_improvement';
            const notesRecordingDuration = state.lastNotesRecordingDuration || 0;
            
            const itemData = {
                sku: state.currentSKU,
                category: state.classification,
                templateKey: state.templateKey,
                template: state.template,
                tagData: null,
                measurements: state.measurements,
                rawTranscript: state.rawTranscript,
                audioBlob: state.audioBlob,
                discardedRecordings: state.discardedRecordings,
                notesAudioBlob: state.notesAudioBlob,
                discardedNotesRecordings: state.discardedNotesRecordings,
                photos: {
                    main: state.photos.main.map(p => ({ blob: p.blob, label: p.label })),
                    closeup: state.photos.closeup.map(p => ({ blob: p.blob, label: p.label })),
                    weight: state.photos.weight.map(p => ({ blob: p.blob, label: p.label })),
                    handheld: state.photos.handheld.map(p => ({ blob: p.blob, label: p.label }))
                },
                jsonData: {
                    sku: state.currentSKU,
                    timestamp: new Date().toISOString(),
                    version: VERSION,
                    processingStatus: 'pending',
                    category: state.classification,
                    // v2.9.13: Include detailed classification
                    type: state.classificationType,
                    sleeveLength: state.classificationSleeve,
                    isCampCollar: state.classificationIsCampCollar,
                    templateKey: state.templateKey,
                    template: state.template,
                    tagData: null,
                    measurements: {},
                    rawTranscript: state.rawTranscript,
                    weight: { source: 'photo', photoCount: state.photos.weight.length, value: null },
                    audioRecordings: {
                        final: { duration: recordingDuration, timestamp: new Date().toISOString() },
                        discarded: state.discardedRecordings.map((d, i) => ({ index: i + 1, duration: d.duration, timestamp: d.timestamp })),
                        totalAttempts: state.discardedRecordings.length + 1,
                        kpiTargets: { targetDuration: 60, excellentDuration: 30, actualDuration: recordingDuration, rating: recordingRating }
                    },
                    notesAudio: {
                        hasNotes: !!state.notesAudioBlob,
                        final: state.notesAudioBlob ? { duration: notesRecordingDuration, timestamp: new Date().toISOString() } : null,
                        discarded: state.discardedNotesRecordings.map((d, i) => ({ index: i + 1, duration: d.duration, timestamp: d.timestamp })),
                        totalAttempts: state.notesAudioBlob ? state.discardedNotesRecordings.length + 1 : state.discardedNotesRecordings.length
                    },
                    timing: {
                        itemStartTime: state.timing.itemStartTime ? new Date(state.timing.itemStartTime).toISOString() : null,
                        classificationTime: state.timing.classificationTime ? new Date(state.timing.classificationTime).toISOString() : null,
                        mainPhotosStartTime: state.timing.mainPhotosStartTime ? new Date(state.timing.mainPhotosStartTime).toISOString() : null,
                        mainPhotosEndTime: state.timing.mainPhotosEndTime ? new Date(state.timing.mainPhotosEndTime).toISOString() : null,
                        closeupStartTime: state.timing.closeupStartTime ? new Date(state.timing.closeupStartTime).toISOString() : null,
                        closeupEndTime: state.timing.closeupEndTime ? new Date(state.timing.closeupEndTime).toISOString() : null,
                        weightStartTime: state.timing.weightStartTime ? new Date(state.timing.weightStartTime).toISOString() : null,
                        weightEndTime: state.timing.weightEndTime ? new Date(state.timing.weightEndTime).toISOString() : null,
                        handheldStartTime: state.timing.handheldStartTime ? new Date(state.timing.handheldStartTime).toISOString() : null,
                        handheldEndTime: state.timing.handheldEndTime ? new Date(state.timing.handheldEndTime).toISOString() : null,
                        measurementsStartTime: state.timing.measurementsStartTime ? new Date(state.timing.measurementsStartTime).toISOString() : null,
                        measurementsEndTime: state.timing.measurementsEndTime ? new Date(state.timing.measurementsEndTime).toISOString() : null,
                        completeTime: state.timing.completeTime ? new Date(state.timing.completeTime).toISOString() : null,
                        durations: { mainPhotos: mainPhotosDuration, closeup: closeupDuration, weight: weightDuration, handheld: handheldDuration, measurements: measurementsDuration, total: totalDuration }
                    },
                    photoCount: { main: state.photos.main.length, closeup: state.photos.closeup.length, weight: state.photos.weight.length, handheld: state.photos.handheld.length },
                    photographerId: state.photographerId,
                    aiResults: null, qcFlags: null, eraEstimation: null, tagSizeAnalysis: null
                }
            };
            
            state.completedItems++;
            state.totalTime += totalDuration;
            localStorage.setItem('completedItems', state.completedItems);
            localStorage.setItem('totalTime', state.totalTime);
            updateStats();
            showToast('success', `${state.currentSKU} submitted!`);
            stopTimer(); resetItem();
            processItemInBackground(itemData);
        }
        
        // =====================================================================
        // BACKGROUND PROCESSING
        // =====================================================================
        async function processItemInBackground(itemData, retryCount = 0) {
            const sku = itemData.sku;
            try {
                if (state.saveDirectoryHandle) { await saveToLocalFolder(itemData); }
                await uploadToS3(itemData);
                await callLambda('n8n', { formData: itemData.jsonData });
            } catch (err) {
                console.error(`‚ùå [${sku}] Background process failed:`, err);
                if (retryCount < MAX_RETRIES) {
                    setTimeout(() => processItemInBackground(itemData, retryCount + 1), RETRY_DELAY);
                } else {
                    showToast('warning', `‚ö†Ô∏è ${sku} upload incomplete - queued for retry`);
                    addToRetryQueue(itemData);
                }
            }
        }
        
        async function saveToLocalFolder(itemData) {
            try {
                const skuFolder = await state.saveDirectoryHandle.getDirectoryHandle(itemData.sku, { create: true });
                const mainFolder = await skuFolder.getDirectoryHandle('main', { create: true });
                if (itemData.photos.main.length > 0) {
                    for (let i = 0; i < itemData.photos.main.length; i++) {
                        const fh = await mainFolder.getFileHandle(`${itemData.sku}_main_${String(i+1).padStart(2,'0')}.jpg`, { create: true });
                        const w = await fh.createWritable(); await w.write(itemData.photos.main[i].blob); await w.close();
                    }
                } else { await createNAFile(mainFolder, null, itemData.sku); }
                
                const closeupFolder = await skuFolder.getDirectoryHandle('closeup', { create: true });
                if (itemData.photos.closeup.length > 0) {
                    for (let i = 0; i < itemData.photos.closeup.length; i++) {
                        const fh = await closeupFolder.getFileHandle(`${itemData.sku}_closeup_${String(i+1).padStart(2,'0')}.jpg`, { create: true });
                        const w = await fh.createWritable(); await w.write(itemData.photos.closeup[i].blob); await w.close();
                    }
                } else { await createNAFile(closeupFolder, null, itemData.sku); }
                
                const weightFolder = await skuFolder.getDirectoryHandle('weight', { create: true });
                if (itemData.photos.weight.length > 0) {
                    for (let i = 0; i < itemData.photos.weight.length; i++) {
                        const fh = await weightFolder.getFileHandle(`${itemData.sku}_weight_${String(i+1).padStart(2,'0')}.jpg`, { create: true });
                        const w = await fh.createWritable(); await w.write(itemData.photos.weight[i].blob); await w.close();
                    }
                } else { await createNAFile(weightFolder, null, itemData.sku); }
                
                const handheldFolder = await skuFolder.getDirectoryHandle('handheld', { create: true });
                if (itemData.photos.handheld.length > 0) {
                    for (let i = 0; i < itemData.photos.handheld.length; i++) {
                        const fh = await handheldFolder.getFileHandle(`${itemData.sku}_handheld_${String(i+1).padStart(2,'0')}.jpg`, { create: true });
                        const w = await fh.createWritable(); await w.write(itemData.photos.handheld[i].blob); await w.close();
                    }
                } else { await createNAFile(handheldFolder, null, itemData.sku); }
                
                const measurementsFolder = await skuFolder.getDirectoryHandle('measurements', { create: true });
                if (itemData.audioBlob) {
                    const fh = await measurementsFolder.getFileHandle(`${itemData.sku}_audio_final.webm`, { create: true });
                    const w = await fh.createWritable(); await w.write(itemData.audioBlob); await w.close();
                }
                if (itemData.discardedRecordings?.length > 0) {
                    for (let i = 0; i < itemData.discardedRecordings.length; i++) {
                        const fh = await measurementsFolder.getFileHandle(`${itemData.sku}_audio_discard_${String(i+1).padStart(2,'0')}.webm`, { create: true });
                        const w = await fh.createWritable(); await w.write(itemData.discardedRecordings[i].blob); await w.close();
                    }
                }
                if (itemData.rawTranscript) {
                    const fh = await measurementsFolder.getFileHandle(`${itemData.sku}_transcript_raw.txt`, { create: true });
                    const w = await fh.createWritable(); await w.write(itemData.rawTranscript); await w.close();
                }
                
                const dataFolder = await skuFolder.getDirectoryHandle('data', { create: true });
                const dfh = await dataFolder.getFileHandle(`${itemData.sku}_data.json`, { create: true });
                const dw = await dfh.createWritable(); await dw.write(JSON.stringify(itemData.jsonData, null, 2)); await dw.close();
                
                const notesFolder = await skuFolder.getDirectoryHandle('notes', { create: true });
                if (itemData.notesAudioBlob) {
                    const fh = await notesFolder.getFileHandle(`${itemData.sku}_audio_notes.webm`, { create: true });
                    const w = await fh.createWritable(); await w.write(itemData.notesAudioBlob); await w.close();
                    if (itemData.discardedNotesRecordings?.length > 0) {
                        for (let i = 0; i < itemData.discardedNotesRecordings.length; i++) {
                            const fh2 = await notesFolder.getFileHandle(`${itemData.sku}_audio_notes_discard_${String(i+1).padStart(2,'0')}.webm`, { create: true });
                            const w2 = await fh2.createWritable(); await w2.write(itemData.discardedNotesRecordings[i].blob); await w2.close();
                        }
                    }
                } else { await createNAFile(notesFolder, null, itemData.sku); }
                
                return true;
            } catch (err) { console.error('Local save error:', err); return false; }
        }
        
        async function createNAFile(folder, _, sku) {
            const fh = await folder.getFileHandle(`${sku}_NA.txt`, { create: true });
            const w = await fh.createWritable(); await w.write(`No data for ${sku}`); await w.close();
        }
        
        // =====================================================================
        // S3 UPLOAD
        // =====================================================================
        async function uploadToS3(itemData) {
            const files = [];
            const sku = itemData.sku;
            
            for (let i = 0; i < itemData.photos.main.length; i++) { files.push({ name: `main/${sku}_main_${String(i+1).padStart(2,'0')}.jpg`, contentType: 'image/jpeg', blob: itemData.photos.main[i].blob }); }
            if (itemData.photos.main.length === 0) files.push({ name: `main/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No main photos for ${sku}`]) });
            
            for (let i = 0; i < itemData.photos.closeup.length; i++) { files.push({ name: `closeup/${sku}_closeup_${String(i+1).padStart(2,'0')}.jpg`, contentType: 'image/jpeg', blob: itemData.photos.closeup[i].blob }); }
            if (itemData.photos.closeup.length === 0) files.push({ name: `closeup/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No closeup photos for ${sku}`]) });
            
            for (let i = 0; i < itemData.photos.weight.length; i++) { files.push({ name: `weight/${sku}_weight_${String(i+1).padStart(2,'0')}.jpg`, contentType: 'image/jpeg', blob: itemData.photos.weight[i].blob }); }
            if (itemData.photos.weight.length === 0) files.push({ name: `weight/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No weight photo for ${sku}`]) });
            
            for (let i = 0; i < itemData.photos.handheld.length; i++) { files.push({ name: `handheld/${sku}_handheld_${String(i+1).padStart(2,'0')}.jpg`, contentType: 'image/jpeg', blob: itemData.photos.handheld[i].blob }); }
            if (itemData.photos.handheld.length === 0) files.push({ name: `handheld/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No handheld photos for ${sku}`]) });
            
            if (itemData.audioBlob) files.push({ name: `measurements/${sku}_audio_final.webm`, contentType: 'audio/webm', blob: itemData.audioBlob });
            if (itemData.discardedRecordings?.length > 0) {
                for (let i = 0; i < itemData.discardedRecordings.length; i++) { files.push({ name: `measurements/${sku}_audio_discard_${String(i+1).padStart(2,'0')}.webm`, contentType: 'audio/webm', blob: itemData.discardedRecordings[i].blob }); }
            }
            if (itemData.rawTranscript) files.push({ name: `measurements/${sku}_transcript_raw.txt`, contentType: 'text/plain', blob: new Blob([itemData.rawTranscript]) });
            
            if (itemData.notesAudioBlob) files.push({ name: `notes/${sku}_audio_notes.webm`, contentType: 'audio/webm', blob: itemData.notesAudioBlob });
            if (itemData.discardedNotesRecordings?.length > 0) {
                for (let i = 0; i < itemData.discardedNotesRecordings.length; i++) { files.push({ name: `notes/${sku}_audio_notes_discard_${String(i+1).padStart(2,'0')}.webm`, contentType: 'audio/webm', blob: itemData.discardedNotesRecordings[i].blob }); }
            }
            if (!itemData.notesAudioBlob) files.push({ name: `notes/${sku}_NA.txt`, contentType: 'text/plain', blob: new Blob([`No notes audio for ${sku}`]) });
            
            files.push({ name: `data/${sku}_data.json`, contentType: 'application/json', blob: new Blob([JSON.stringify(itemData.jsonData, null, 2)]) });
            
            const presignResult = await callLambda('presign', { sku, files: files.map(f => ({ name: f.name, contentType: f.contentType })) });
            if (!presignResult.success) throw new Error('Failed to get presigned URLs');
            for (const file of files) {
                const url = presignResult.urls[file.name];
                if (url) await fetch(url, { method: 'PUT', headers: { 'Content-Type': file.contentType }, body: file.blob });
            }
        }
        
        function addToRetryQueue(itemData) {
            state.retryQueue.push({ sku: itemData.sku, jsonData: itemData.jsonData, timestamp: Date.now() });
            localStorage.setItem('retryQueue', JSON.stringify(state.retryQueue));
            updateRetryBadge();
        }
        
        function updateRetryBadge() {
            const badge = document.getElementById('retry-badge');
            if (state.retryQueue.length > 0) { badge.textContent = `‚ö†Ô∏è ${state.retryQueue.length} pending`; badge.classList.add('visible'); }
            else { badge.classList.remove('visible'); }
        }
        
        async function processRetryQueue() {
            if (state.retryQueue.length === 0) return;
            const toRetry = [...state.retryQueue]; state.retryQueue = [];
            for (const item of toRetry) {
                try { await callLambda('n8n', { formData: item.jsonData }); } catch (e) { state.retryQueue.push(item); }
            }
            localStorage.setItem('retryQueue', JSON.stringify(state.retryQueue));
            updateRetryBadge();
        }
        
        // =====================================================================
        // SKU & TIMER
        // =====================================================================
        function startNewItem() {
            const sku = document.getElementById('sku-input').value.trim().toUpperCase();
            if (!sku) { showToast('warning', 'Enter a SKU'); return; }
            if (!state.saveDirectoryHandle) { showToast('error', '‚ö†Ô∏è SELECT SAVE FOLDER BEFORE STARTING'); highlightFolderSelector(); return; }
            
            const now = Date.now();
            state.currentSKU = sku;
            state.photos = { main: [], closeup: [], weight: [], handheld: [] };
            state.classification = null;
            state.classificationType = null;
            state.classificationSleeve = null;
            state.classificationIsCampCollar = false;
            state.templateKey = null; state.template = null; state.tagData = null;
            state.measurements = {}; state.rawTranscript = ''; state.audioBlob = null;
            state.aiTriggered = false;
            state.timing = { itemStartTime: now, classificationTime: null, mainPhotosStartTime: now, mainPhotosEndTime: null, closeupStartTime: null, closeupEndTime: null, weightStartTime: null, weightEndTime: null, handheldStartTime: null, handheldEndTime: null, measurementsStartTime: null, measurementsEndTime: null, completeTime: null };
            state.discardedRecordings = []; state.lastRecordingDuration = 0;
            state.notesAudioBlob = null; state.notesAudioChunks = []; state.isRecordingNotes = false;
            state.notesMediaRecorder = null; state.notesRecordingStartTime = null;
            state.lastNotesRecordingDuration = 0; state.discardedNotesRecordings = [];
            
            document.getElementById('sku-row').style.display = 'none';
            document.getElementById('sku-display').textContent = sku;
            document.getElementById('sku-display').classList.add('visible');
            document.getElementById('classification-box').classList.remove('ready');
            document.getElementById('classification-category').textContent = 'Waiting...';
            document.getElementById('classification-detail').textContent = '';
            document.getElementById('classification-template').textContent = '-';
            document.getElementById('tag-grid').style.display = 'none';
            document.getElementById('measurement-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 12px; text-align: center;">Classify first</div>';
            document.getElementById('transcript-box').classList.remove('visible');
            document.getElementById('complete-btn-camera').disabled = true;
            updateWeightPhotoStatus(); updatePhotoGrid(); updatePhotoCount();
            startTimer(); switchCameraMode('main');
            showToast('success', `Started: ${sku}`);
        }
        
        function cancelItem() { if (!confirm(`Cancel item ${state.currentSKU}?`)) return; resetItem(); showToast('info', 'Item cancelled'); }
        
        function resetItem() {
            state.currentSKU = '';
            state.photos = { main: [], closeup: [], weight: [], handheld: [] };
            state.classification = null; state.classificationType = null;
            state.classificationSleeve = null; state.classificationIsCampCollar = false;
            state.templateKey = null; state.template = null; state.tagData = null;
            state.measurements = {}; state.rawTranscript = ''; state.audioBlob = null;
            state.aiTriggered = false;
            state.timing = { itemStartTime: null, classificationTime: null, mainPhotosStartTime: null, mainPhotosEndTime: null, closeupStartTime: null, closeupEndTime: null, weightStartTime: null, weightEndTime: null, handheldStartTime: null, handheldEndTime: null, measurementsStartTime: null, measurementsEndTime: null, completeTime: null };
            state.discardedRecordings = []; state.lastRecordingDuration = 0;
            state.notesAudioBlob = null; state.notesAudioChunks = []; state.isRecordingNotes = false;
            state.notesMediaRecorder = null; state.notesRecordingStartTime = null;
            state.lastNotesRecordingDuration = 0; state.discardedNotesRecordings = [];
            
            document.getElementById('sku-input').value = '';
            document.getElementById('sku-row').style.display = 'flex';
            document.getElementById('sku-display').classList.remove('visible');
            document.getElementById('classification-box').classList.remove('ready');
            document.getElementById('classification-category').textContent = 'Waiting...';
            document.getElementById('classification-detail').textContent = '';
            document.getElementById('classification-template').textContent = '-';
            document.getElementById('tag-grid').style.display = 'none';
            document.getElementById('measurement-list').innerHTML = '<div style="color: var(--text-secondary); font-size: 12px; text-align: center;">Classify first</div>';
            document.getElementById('transcript-box').classList.remove('visible');
            document.getElementById('complete-btn-camera').disabled = true;
            updateWeightPhotoStatus();
            
            const btn = document.getElementById('record-btn');
            btn.classList.remove('btn-stop'); btn.classList.add('btn-record'); btn.textContent = 'üé§ TAP TO RECORD';
            const notesBtn = document.getElementById('notes-record-btn');
            notesBtn.classList.remove('btn-stop'); notesBtn.classList.add('btn-record'); notesBtn.textContent = 'üé§ TAP TO RECORD NOTES';
            
            updatePhotoGrid(); updatePhotoCount(); stopTimer();
            document.getElementById('timer').textContent = '0:00';
        }
        
        function startTimer() { stopTimer(); state.timerStart = Date.now(); state.timerInterval = setInterval(() => { const s = Math.floor((Date.now() - state.timerStart) / 1000); document.getElementById('timer').textContent = `${Math.floor(s/60)}:${String(s%60).padStart(2,'0')}`; }, 1000); }
        function stopTimer() { if (state.timerInterval) clearInterval(state.timerInterval); }
        function updateStats() {
            document.getElementById('item-count').textContent = state.completedItems;
            if (state.completedItems > 0) { const avg = Math.round(state.totalTime / state.completedItems); document.getElementById('avg-time').textContent = `${Math.floor(avg/60)}:${String(avg%60).padStart(2,'0')}`; }
        }
        
        // =====================================================================
        // BARCODE SCANNER
        // =====================================================================
        let barcodeDetected = false;
        
        function openBarcodeScanner() {
            barcodeDetected = false;
            document.getElementById('barcode-modal').classList.add('active');
            document.getElementById('barcode-status').textContent = 'Starting...';
            document.getElementById('barcode-status').classList.remove('success', 'warning');
            document.getElementById('barcode-confidence').textContent = '--';
            document.getElementById('barcode-confidence').className = 'barcode-confidence';
            
            const deviceId = state.cameras.barcode.deviceId || state.availableCameras[0]?.deviceId;
            Quagga.init({
                inputStream: { type: 'LiveStream', target: document.getElementById('barcode-container'), constraints: { deviceId: deviceId ? { exact: deviceId } : undefined, facingMode: 'environment' }, willReadFrequently: true },
                decoder: { readers: ['code_128_reader', 'ean_reader', 'ean_8_reader', 'upc_reader', 'upc_e_reader'] },
                locate: true, frequency: 10
            }, err => {
                if (err) { document.getElementById('barcode-status').textContent = 'Scanner error'; return; }
                document.getElementById('barcode-status').textContent = 'Point at barcode...';
                Quagga.start();
                Quagga.onProcessed(result => { if (result?.codeResult) { const c = calculateBarcodeConfidence(result); updateConfidenceDisplay(c); } });
                Quagga.onDetected(result => {
                    if (barcodeDetected) return;
                    const confidence = calculateBarcodeConfidence(result);
                    const code = result.codeResult.code;
                    if (confidence >= BARCODE_MIN_CONFIDENCE) {
                        barcodeDetected = true; Quagga.stop();
                        document.getElementById('barcode-status').textContent = `‚úÖ ${code}`;
                        document.getElementById('barcode-status').classList.add('success');
                        document.getElementById('sku-input').value = code;
                        setTimeout(() => { closeBarcodeScanner(); showToast('success', `Scanned: ${code}`); }, 500);
                    } else {
                        document.getElementById('barcode-status').textContent = '‚ö†Ô∏è Low confidence - hold steady';
                        document.getElementById('barcode-status').classList.add('warning');
                        setTimeout(() => { if (!barcodeDetected) { document.getElementById('barcode-status').textContent = 'Point at barcode...'; document.getElementById('barcode-status').classList.remove('warning'); } }, 1500);
                    }
                });
            });
        }
        
        function calculateBarcodeConfidence(result) {
            if (!result?.codeResult?.decodedCodes) return 0;
            let totalError = 0, errorCount = 0;
            for (const d of result.codeResult.decodedCodes) { if (d.error != null) { totalError += d.error; errorCount++; } }
            if (errorCount === 0) return 0.5;
            return Math.max(0, Math.min(1, 1 - ((totalError / errorCount) * 2)));
        }
        
        function updateConfidenceDisplay(confidence) {
            const el = document.getElementById('barcode-confidence');
            el.textContent = `${(confidence * 100).toFixed(0)}%`;
            el.classList.remove('good', 'medium', 'poor');
            el.classList.add(confidence >= 0.80 ? 'good' : confidence >= 0.60 ? 'medium' : 'poor');
        }
        
        function closeBarcodeScanner() {
            barcodeDetected = false;
            try { Quagga.stop(); Quagga.offDetected(); Quagga.offProcessed(); } catch {}
            document.getElementById('barcode-modal').classList.remove('active');
        }
        
        // =====================================================================
        // SETTINGS
        // =====================================================================
        function openSettings() { document.getElementById('settings-modal').classList.add('active'); }
        function closeSettings() { document.getElementById('settings-modal').classList.remove('active'); }
        
        function saveSettings() {
            ['main', 'closeup', 'weight', 'handheld', 'barcode'].forEach(mode => {
                const sel = document.getElementById(`camera-${mode}`);
                if (sel) { state.cameras[mode].deviceId = sel.value; localStorage.setItem(`camera-${mode}`, sel.value); }
            });
            const url = document.getElementById('lambda-url').value.trim();
            if (url) { state.lambdaUrl = url; localStorage.setItem('lambdaUrl', url); }
            const apiKey = document.getElementById('api-key').value.trim();
            state.apiKey = apiKey;
            if (apiKey) localStorage.setItem('vl-api-key', apiKey);
            else { localStorage.removeItem('vl-api-key'); showToast('warning', '‚ö†Ô∏è No API key set'); }
            state.photographerId = document.getElementById('photographer-id').value.trim() || 'photographer_1';
            localStorage.setItem('photographerId', state.photographerId);
            const micSel = document.getElementById('mic-device');
            if (micSel) { state.micDeviceId = micSel.value || null; if (micSel.value) localStorage.setItem('mic-device', micSel.value); else localStorage.removeItem('mic-device'); }
            closeSettings(); showToast('success', 'Settings saved');
            startCamera(state.currentMode); checkLambda();
        }
        
        // =====================================================================
        // TOAST
        // =====================================================================
        function showToast(type, msg) {
            const c = document.getElementById('toast-container');
            const t = document.createElement('div');
            t.className = `toast ${type}`; t.textContent = msg;
            c.appendChild(t);
            setTimeout(() => { t.style.opacity = '0'; setTimeout(() => t.remove(), 300); }, 3000);
        }
        
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
